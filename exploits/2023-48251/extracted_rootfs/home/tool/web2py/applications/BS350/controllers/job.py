import json
import syslog
import traceback
import Activity
import FilePaths
import time
import fsio
import datetime
import glob
import shutil
import os
import re
import subprocess
import JobConvertToLua
import LuaConvertToJson
import logConfig
import status_mod
import m7z_mod


# Fake globals for syntax check
import notify_activity
import sys_capabilities

if False:
  response = None
  request = None
  session = None
  db = None

status_mod.sessionUserMgr.setLastVisit(session, request)
if logConfig.jobSessFrgt:
  session.forget(response)


@auth.requires(request.ajax==True, requires_login=True)
def fileEmpty(path):
    return os.stat(path).st_size == 0


@auth.requires(request.ajax==True, requires_login=True)
def getLastEditJob():
  jobIds = range(0, 256)
  lastmodif = 0.0
  lastSlot = 0
  try:
    for i, slot in enumerate(jobIds):
      filename = os.path.join(FilePaths.JOB_PATH, 'job%03d.lua' % slot)
      if os.path.isfile(filename):
        modif = os.path.getmtime(filename)
        if lastmodif < modif:
          lastmodif = modif
          lastSlot = slot
  except:
    pass

  return response.json({'lastModif':  lastSlot})


@auth.requires(request.ajax==True, requires_login=True)
def processJobs():
  if request.env.request_method == "GET":
    jobs = []
    jobIds = range(0, 256)

    for i, slot in enumerate(jobIds):
      filename = os.path.join(FilePaths.JOB_PATH, 'job%03d.lua' % slot)
      #filename_atoms = os.path.join(FilePaths.JOB_PATH, 'atoms%03d.lua' % (slot))
      job = {"id": i + 1, "Name": 'n.a', "Slot": slot}
      appended = False
      if os.path.isfile(filename):
        try:
          if fileEmpty(filename):
            os.remove(filename)
          #if fileEmpty(filename_atoms):
          # os.remove(filename_atoms)
          f = file(filename, 'r')
          for line in f.read().split('\n'):
            if "jobName" in str(line):
                job = {"id": i + 1, "Name": str(line)[14:-1].replace("\'", ""), "Slot": slot}
                break

          jobs.append(job)
          appended = True
        except Exception as e:
          print("Exeception retrieving jobs :", e.args)
      if not appended:
        job = {'id': i + 1, 'Name': 'n.a', 'Slot': slot, 'Comment': '', 'Date': 978303600, 'Version': '',
              'steps': [
              {'id': 1, 'Type': 0, 'Column': 0, 'Row': 0, 'IO_Next': 2, 'execPy': "BeginStep('START');step['actions'][1]='ToolDisable()';step['actions'][2]='ResetOkNokCounter()'",
              "children": [
              {"myText": "General", "expanded": True, "children": [
              {"myText": "Name", "myValue": "Start", "type": "EDITBOX", "invisible": False, "readonly": False, "maxLength": 40, "stepname":"Start", 'execPy': "step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')", "leaf": True},
		      {"myText": "Comment", "myValue": "", "type": "EDITBOX", "invisible": False, "readonly": False, "maxLength": 40, "leaf": True, 'execPy': "step['comment'] = firstLevel.get('myValue')"}]},
              {"myText":"Options", "expanded": True, "children": [
              {"type": "EDITBOX", "myText": "Timeout (sec)", "myValue": "0.3", "invisible": True, "execPy": "StartStep['timeout'] = float(firstLevel.get('myValue')) * 1000", "leaf": True},
              {"type": "CHECKBOX", "myText": "Channel Cw set by Job", "myValue": "false", "readonly": "false", "invisible": True, "execPy": "StartStep['selectsCw'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"type": "CHECKBOX", "myText": "Channel En set by Job", "myValue": "false", "readonly": "false", "invisible": True, "execPy": "StartStep['selectsEn'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"myText": "Show job step info in display", "myValue": "true", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['displayJobSteps'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"myText": "Job step info display time", "myValue": "1", "type": "NUMBERFIELD_U", "min": 0.1, "max": 10, "step": 0.1, "default": 1, "invisible": False, "readonly": False, "execPy": "StartStep['displayTime'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Job abort when NOK result in job step", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['stopOnNok'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Clear ID code at end of job", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['ClearIDCode'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"type": "CHECKBOX", "myText": "Job abort when Timeout", "myValue": "false", "readonly": True, "invisible": True, "execPy": "StartStep['stopOnTimeout'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Clear JobApp Out Signals", "myValue": "false", "type": "CHECKBOX", "invisible": True, "readonly": False, "leaf": True, "execPy": "step['ClearJobAppOut'] = firstLevel.get('myValue');step['actions'][3]='ClearJobAppOut()';FinalizeStep()"}
              ]}]},

              {'id': 2, 'Type': 2, 'Column': 0, 'Row': 1, "execPy": "BeginStep('END')", "children": [
              {"myText": "General", "expanded": True, "children": [
              {"myText": "Name", "myValue": "End", "type": "EDITBOX", "invisible": False, "readonly": False, "maxLength": 40, "stepname":"End", "execPy": "step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Comment", "myValue": "", "type": "EDITBOX", "invisible": False, "readonly": False, "maxLength": 40, "leaf": True, 'execPy': "step['comment'] = firstLevel.get('myValue')"}
              ]},
              {"myText": "Options", "expanded": True, "children": [
              {"myText": "Enable tool", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": True, "leaf": True, "execPy": "step['actions'][1] = 'ToolDisable()';FinalizeStep()"}
              ]}]}]
        }
        jobs.append(job)
    return response.json(jobs)

  if request.env.request_method == "POST":
    jobuser = session.auth.user.username
    data = json.loads(request.body.read())
    if not isinstance(data, list):
      data = [data]
    my_response = JobConvertToLua.testWriteJob(data, FilePaths.JOB_PATH, jobuser, session)

    return response.json(my_response)


@auth.requires(request.ajax==True, requires_login=True)
def removeJob():
  if request.env.request_method == "POST":
    requestSlot = int(request.vars.slot)
    if request.vars.defectJob is not None:
      if bool(request.vars.defectJob) is True:
        syslog.syslog(syslog.LOG_ERR, 'Broken job%03d.lua found! Successfully removed' % requestSlot)

    filename = os.path.join(FilePaths.JOB_PATH, 'job%03d.lua' % requestSlot)
    if os.path.isfile(filename):
      os.remove(filename)
      notify_activity.configChanged(filename, Activity.JOB_REMOVED, [requestSlot], session=session)


@auth.requires(request.ajax==True, requires_login=True)
def singleJob():
  if request.env.request_method == "GET":
    requestSlot = int(request.vars.slot)
    filename = os.path.join(FilePaths.JOB_PATH, 'job%03d.lua' % (requestSlot))
    read = False
    data = {}
    if os.path.isfile(filename):
      try:
        if fileEmpty(filename):
          os.remove(filename)
        job = LuaConvertToJson.getJob(filename)

        if len(job.get('steps')) == 0:
          job = {'id': 1, 'Name': 'n.a', 'Slot': requestSlot, 'Comment': '', 'Date': 978303600, 'Version': '',
              'steps': [
              {'id': 1, 'Type': 0, 'Column': 0, 'Row': 0, 'IO_Next': 2, 'execPy': "BeginStep('START');step['actions'][1]='ToolDisable()';step['actions'][2]='ResetOkNokCounter()'",
              "children": [
              {"myText": "General", "expanded": True, "children": [
              {"myText": "Name", "myValue": "Start", "type": "EDITBOX", "invisible": False, "readonly": False, "stepname":"Start", 'execPy': "step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')", "leaf": True},
		      {"myText": "Comment", "myValue": "", "type": "EDITBOX", "invisible": False, "readonly": False, "leaf": True, 'execPy': "step['comment'] = firstLevel.get('myValue')"}]},
              {"myText":"Options", "expanded": True, "children": [
              {"type": "EDITBOX", "myText": "Timeout (sec)", "myValue": "0.3", "invisible": True, "execPy": "StartStep['timeout'] = float(firstLevel.get('myValue')) * 1000", "leaf": True},
              {"type": "CHECKBOX", "myText": "Channel Cw set by Job", "myValue": "false", "readonly": "false", "invisible": True, "execPy": "StartStep['selectsCw'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"type": "CHECKBOX", "myText": "Channel En set by Job", "myValue": "false", "readonly": "false", "invisible": True, "execPy": "StartStep['selectsEn'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"myText": "Show job step info in display", "myValue": "true", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['displayJobSteps'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"myText": "Job step info display time", "myValue": "1", "type": "NUMBERFIELD_U", "min": 0.1, "max": 10, "step": 0.1, "default": 1, "invisible": False, "readonly": False, "execPy": "StartStep['displayTime'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Job abort when NOK result in job step", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['stopOnNok'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Clear ID code at end of job", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['ClearIDCode'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"type": "CHECKBOX", "myText": "Job abort when Timeout", "myValue": "false", "readonly": True, "invisible": True, "execPy": "StartStep['stopOnTimeout'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Clear JobApp Out Signals", "myValue": "false", "type": "CHECKBOX", "invisible": True, "readonly": False, "leaf": True, "execPy": "step['ClearJobAppOut'] = firstLevel.get('myValue');step['actions'][3]='ClearJobAppOut()';FinalizeStep()"}
              ]}]},

              {'id': 2, 'Type': 2, 'Column': 0, 'Row': 1, "execPy": "BeginStep('END')", "children": [
              {"myText": "General", "expanded": True, "children": [
              {"myText": "Name", "myValue": "End", "type": "EDITBOX", "invisible": False, "readonly": False, "stepname":"End", "execPy": "step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Comment", "myValue": "", "type": "EDITBOX", "invisible": False, "readonly": False, "leaf": True, 'execPy': "step['comment'] = firstLevel.get('myValue')"}
              ]},
              {"myText": "Options", "expanded": True, "children": [
              {"myText": "Enable tool", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": True, "leaf": True, "execPy": "step['actions'][1] = 'ToolDisable()';FinalizeStep()"}
              ]}]}]}

        job['id'] = requestSlot + 1


        job['Slot'] = requestSlot
        read = True
      except Exception as e:
        syslog.syslog(syslog.LOG_ERR, traceback.format_exc())
        print("Exeception in LuaConvertToJson  :", e.args)
        if not read:
          job = {'id': 1, 'Name': 'n.a', 'Slot': requestSlot, 'Comment': '', 'Date': 978303600, 'Version': '',
              'steps': [
              {'id': 1, 'Type': 0, 'Column': 0, 'Row': 0, 'IO_Next': 2, 'execPy': "BeginStep('START');step['actions'][1]='ToolDisable()';step['actions'][2]='ResetOkNokCounter()'",
              "children": [
              {"myText": "General", "expanded": True, "children": [
              {"myText": "Name", "myValue": "Start", "type": "EDITBOX", "invisible": False, "readonly": False, "stepname":"Start", 'execPy': "step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')", "leaf": True},
		      {"myText": "Comment", "myValue": "", "type": "EDITBOX", "invisible": False, "readonly": False, "leaf": True, 'execPy': "step['comment'] = firstLevel.get('myValue')"}]},
              {"myText":"Options", "expanded": True, "children": [
              {"type": "EDITBOX", "myText": "Timeout (sec)", "myValue": "0.3", "invisible": True, "execPy": "StartStep['timeout'] = float(firstLevel.get('myValue')) * 1000", "leaf": True},
              {"type": "CHECKBOX", "myText": "Channel Cw set by Job", "myValue": "false", "readonly": "false", "invisible": True, "execPy": "StartStep['selectsCw'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"type": "CHECKBOX", "myText": "Channel En set by Job", "myValue": "false", "readonly": "false", "invisible": True, "execPy": "StartStep['selectsEn'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"myText": "Show job step info in display", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['displayJobSteps'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"myText": "Job step info display time", "myValue": "1", "type": "NUMBERFIELD_U", "min": 0.1, "max": 10, "step": 0.1, "default": 1, "invisible": False, "readonly": False, "execPy": "StartStep['displayTime'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Job abort when NOK result in job step", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['stopOnNok'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Clear ID code at end of job", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": False, "execPy": "StartStep['ClearIDCode'] = Get1or0(firstLevel.get('myValue'))", "leaf": True},
              {"type": "CHECKBOX", "myText": "Job abort when Timeout", "myValue": "false", "readonly": True, "invisible": True, "execPy": "StartStep['stopOnTimeout'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Clear JobApp Out Signals", "myValue": "false", "type": "CHECKBOX", "invisible": True, "readonly": False, "leaf": True, "execPy": "step['ClearJobAppOut'] = firstLevel.get('myValue');step['actions'][3]='ClearJobAppOut()';FinalizeStep()"}
              ]}]},

              {'id': 2, 'Type': 2, 'Column': 0, 'Row': 1, "execPy": "BeginStep('END')", "children": [
              {"myText": "General", "expanded": True, "children": [
              {"myText": "Name", "myValue": "End", "type": "EDITBOX", "invisible": False, "readonly": False, "stepname":"End", "execPy": "step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')", "leaf": True},
              {"myText": "Comment", "myValue": "", "type": "EDITBOX", "invisible": False, "readonly": False, "leaf": True, 'execPy': "step['comment'] = firstLevel.get('myValue')"}
              ]},
              {"myText": "Options", "expanded": True, "children": [
              {"myText": "Enable tool", "myValue": "false", "type": "CHECKBOX", "invisible": False, "readonly": True, "leaf": True, "execPy": "step['actions'][1] = 'ToolDisable()';FinalizeStep()"}
              ]}]}]}

          job['id'] = requestSlot + 1
          job['Slot'] = requestSlot

      data['job'] = job
      data['hasScanner'] = sys_capabilities.hasScanner()
    return response.json(data)



@auth.requires(request.ajax==True, requires_login=True)
def existingJobs():
  file_list = glob.glob(FilePaths.JOB_PATH + "/job*.lua", )
  job_re = re.compile(r"^(" + FilePaths.JOB_PATH + '/' + "job)([0-9]{1,3})(\.lua)$")
  def job_number(job_filename):
    if job_re.match(job_filename):
      return job_re.match(job_filename).groups()[1]
    else:
      return None
  job_numbers = filter(lambda x: x != None, map(job_number, file_list))
  job_numbers = map(lambda x: int(x), job_numbers)
  return response.json(job_numbers)



def __genJobFileName(number):
  while len(str(number)) < 3:
    number = "0" + str(number)
  name = 'job{0}'.format(number)

  ts = time.time()
  dateStamp = datetime.datetime.fromtimestamp(ts).strftime('%Y_%m_%d')
  return dateStamp + '_' + name.strip() + '.nxjob'


@auth.requires(request.ajax==True, requires_login=True)
def exportJobFile():
  res = {'success': False, 'msg': 'Unknown error'}
  fsio.fsLock.acquire()
  number = str(request.vars.num).zfill(3)
  try:
    expfname = __genJobFileName(request.vars.num)
    filename = 'job' + number + '.lua'
    filename_atom = 'atoms' + number + '.lua'
    targetJob = '{0}/{1}'.format(FilePaths.JOB_PATH, filename)
    targetAtom = '{0}/{1}'.format(FilePaths.JOB_PATH, filename_atom)
    res = {'success': True, 'msg': '/tmp/' + expfname}
    pwd = FilePaths.gen_rev_pwd("jobs/job000.lua")
    syslog.syslog(syslog.LOG_INFO, "START exportJobFile.subprocess to " + expfname + " at " + time.asctime())
    p = subprocess.Popen(['{0}/job_exporter.sh'.format(FilePaths.SH_TOOL_PATH),
                          pwd,
                          expfname,
                          targetJob,
                          targetAtom,
                          '/tmp'],
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    syslog.syslog(syslog.LOG_INFO, "DONE exportJobFile.subprocess to " + expfname + " at " + time.asctime())
    syslog.syslog(syslog.LOG_INFO, "RESULT exportJobFile.subprocess to stdout: " + str(stdout))
    syslog.syslog(syslog.LOG_INFO, "RESULT exportJobFile.subprocess to stderr: " + str(stderr))
    if p.returncode != 0:
      # Failure
      res['success'] = False
      res['msg'] = str(stderr)
  except Exception, e:
    res['success'] = False
    res['msg'] = str(e)
  finally:
    fsio.fsLock.release()

  return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def exportAll():
  res = {'success': False, 'msg': 'Unknown error'}
  try:
    filenames = glob.glob(FilePaths.JOB_PATH + "/job*.lua")
    filenames = ' '.join(filenames)
    filenames_atom = glob.glob(FilePaths.JOB_PATH + "/atoms*.lua")
    filenames_atom = ' '.join(filenames_atom)

    expfname = datetime.datetime.fromtimestamp(time.time()).strftime('%Y_%m_%d') + '_' + 'allJobs.zip'
    pwd = FilePaths.gen_rev_pwd("jobs/job000.lua")
    res = {'success': True, 'msg': '/tmp/' + expfname}
    syslog.syslog(syslog.LOG_INFO, "START job.exportAll.subprocess to " + expfname + " at " + time.asctime())
    p = subprocess.Popen(['{0}/exportAll.sh'.format(FilePaths.SH_TOOL_PATH), pwd, expfname, filenames, filenames_atom, '/tmp'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    syslog.syslog(syslog.LOG_INFO, "DONE job.exportAll.subprocess to " + expfname + " at " + time.asctime())
    syslog.syslog(syslog.LOG_INFO, "RESULT job.exportAll.subprocess to stdout: " + str(stdout))
    syslog.syslog(syslog.LOG_INFO, "RESULT job.exportAll.subprocess to stderr: " + str(stderr))
    if p.returncode != 0:
      # Failure
      res['success'] = False
      res['msg'] = str(stderr)
  except Exception as e:
    res['success'] = False
    res['msg'] = str(e)
  return response.json(res)


@auth.requires_login()
def importJobFile():
  try:
    job = str(request.vars.job).zfill(3)
    filename = request.vars.fileupload.filename.split("\\")[-1]
  except:
    return response.json({'success': False, 'msg': 'Invalid parameters'})

  targetpath = '{0}/job{1}.lua'.format(FilePaths.JOB_PATH, job)
  targetpath_atom = '{0}/atoms{1}.lua'.format(FilePaths.JOB_PATH, job)
  targetfname = 'job{0}.lua'.format(job)

  res = {'success': False, 'msg': 'Unknown  error'}
  destRootDir = '/tmp/'
  destDir = 'luajob'
  filename = 'luajob.zip'
  destPath = destRootDir + destDir + '/'

  fsio.fsXngLock.acquire()
  try:
    filepath = destRootDir + filename
    with open(filepath, 'w') as f:
        f.write(request.vars.fileupload.value)
    pwd = FilePaths.gen_rev_pwd("jobs/job000.lua")
    returncode = m7z_mod.test_pwd(filepath, pwd)
    if returncode != 0:
        return response.json(m7z_mod.get_import_impossible_msg())

    p = subprocess.Popen(['{0}/job_importer.sh'.format(FilePaths.SH_TOOL_PATH), pwd, filename, destRootDir, destDir],
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    if p.returncode != 0:
      # Failure
      res['success'] = False
      res['msg'] = str(stderr)
    else:
      #must be one file and lua extension else error
      if os.path.exists(destPath):
        p, d, f = os.walk(destPath).next()
        if len(f) == 1:
          if f[0].endswith('.lua') and f[0].startswith("job"):
            #read the file
            fname = destPath + f[0]
            fsio.shcopy(fname, targetpath)
            notify_activity.configChanged("/home/tool/config/job_importer",
                                          Activity.JOB_CHANGED,
                                          activityArgs=[job],
                                          session=session)
            return response.json({'success': True, 'msg': ':-)'})
          else:
              pass
              #res = {'success': False, 'msg': 'No lua file inside source file'}
        else:
          res = {'success': False, 'msg': 'More than one file inside source file'}
      else:
        res = {'success': False, 'msg': 'Expansion process failed'}
  except Exception, e:
    res['success'] = False
    res['msg'] = str(e)
  finally:
    fsio.fsXngLock.release()
  return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def importAll():
  try:
    filename = request.vars.fileupload.filename.split("\\")[-1]
  except:
    return response.json({'success': False, 'msg': 'Invalid parameters'})

  res = {'success': False, 'msg': 'Unknown  error'}
  destRootDir = '/tmp/'
  destDir = 'luajob'
  filename = 'luajob.zip'
  destPath = destRootDir + destDir + '/'

  fsio.fsXngLock.acquire()
  try:
    filepath = destRootDir + filename
    with open(filepath, 'w') as f:
      f.write(request.vars.fileupload.value)

    pwd = FilePaths.gen_rev_pwd("jobs/job000.lua")
    returncode = m7z_mod.test_pwd(filepath, pwd)
    if returncode != 0:
        return response.json(m7z_mod.get_import_impossible_msg())

    p = subprocess.Popen(['{0}/job_importer.sh'.format(FilePaths.SH_TOOL_PATH),
                          pwd,
                          filename,
                          destRootDir,
                          destDir],
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    if p.returncode != 0:
      # Failure
      res['success'] = False
      res['msg'] = str(stderr)
    else:
      for root, subFolders, files in os.walk(FilePaths.JOB_PATH):
        for incFile in files:
          if (incFile.startswith("job") or incFile.startswith("atoms")) and incFile.endswith(".lua"):
            os.remove(os.path.join(FilePaths.JOB_PATH, incFile))
      if os.path.exists(destPath):
        p, d, f = os.walk(destPath).next()
        if len(f) > 0:
          for tempFile in f:
            if tempFile.endswith('.lua'):
              if "atom" in tempFile:
                fsio.shcopyNb(destPath + tempFile, os.path.join(FilePaths.JOB_PATH, tempFile))
                pass
              elif "job" in tempFile:
                fsio.shcopyNb(destPath + tempFile, os.path.join(FilePaths.JOB_PATH, tempFile))
                pass
            else:
                pass
                # res = {'success': False, 'msg': 'No lua file inside source file'}
          return response.json({'success': True, 'msg': ':-)'})
        else:
          res = {'success': False, 'msg': 'No file inside source file'}
      else:
        res = {'success': False, 'msg': 'Expansion process failed'}
  except Exception, e:
    res['success'] = False
    res['msg'] = str(e)
  finally:
    fsio.fsXngLock.release()
  return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def extractSlot(incFile):
  match = re.match("job(.*).lua", incFile)
  slot = match.groups()[0]
  return slot


@auth.requires(request.ajax==True, requires_login=True)
def remove_all_jobs():
  for root, subFolders, files in os.walk(FilePaths.JOB_PATH):
    activities = []
    for incFile in files:
      if incFile.startswith("job") and incFile.endswith(".lua"):
        slot = extractSlot(incFile)
        os.remove(os.path.join(FilePaths.JOB_PATH, incFile))
        activities.append(notify_activity.ActivityLogParams(
          activityArgs=[slot],
          activityType=Activity.JOB_REMOVED
        ))
    notify_activity.configChangedBatch(
      activities=activities,
      filename=FilePaths.CONFIG_JOB_IMPORTER,
      session=session
    )


@auth.requires(request.ajax==True, requires_login=True)
def importSelected():
  res = {'success': False, 'msg': 'Unknown  error'}
  destRootDir = '/tmp/'
  flistName = 'jobnamelist.txt'
  destDir = 'luajob'
  filename = 'luajob.zip'
  destPath = destRootDir + destDir + '/'

  fsio.fsXngLock.acquire()
  try:
    import base64
    filedata = base64.b64decode(request.vars.filedata)
    filepath = destRootDir + filename
    with open(filepath, 'w') as f:
        f.write(filedata)
    excludeList = request.vars.excludeList
    namesdata = ""
    if excludeList != None:
        if type(excludeList) == type([]):
            namesdata = '\n'.join(excludeList)
        else:
            namesdata = excludeList
    with open(destRootDir + flistName, 'w') as f:
        f.write(namesdata)
    pwd = FilePaths.gen_rev_pwd("jobs/job000.lua")
    returncode = m7z_mod.test_pwd(filepath, pwd)
    if returncode != 0:
        return response.json(m7z_mod.get_import_impossible_msg())
    if os.path.exists(destPath):
      prgs = glob.glob(destPath+'*')
      for f in prgs:
        syslog.syslog(syslog.LOG_ERR, "Filepath to delete: {0}".format(f))
        if os.path.isfile(f):
            os.remove(f)
        elif os.path.isdir(f):
            if f.startswith("/tmp"):
                shutil.rmtree(f)
    else:
        os.makedirs(destPath)



    p = subprocess.Popen(['/home/tool/bin/7za',  'x', filepath, '-p'+pwd, '-o'+destPath, '-x@'+destRootDir+flistName, '-y'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    if p.returncode != 0:
      # Failure
      res['success'] = False
      res['msg'] = str(stderr)
      if res['msg'] == "":
        res['msg'] = 'System Error'
    else:
      # CR12502 we do _not_ want to remove all jobs before importing selected:
      # remove_all_jobs()
      if os.path.exists(destPath):
        p, d, f = os.walk(destPath).next()
        if len(f) > 0:
          activities = []
          for tempFile in f:
            if tempFile.endswith('.lua'):
              fsio.shcopy(destPath + tempFile, os.path.join(FilePaths.JOB_PATH, tempFile))
              slot = extractSlot(tempFile)
              activities.append(
                  notify_activity.ActivityLogParams(
                      activityArgs=[slot],
                      activityType=Activity.JOB_CREATED
                  )
              )
            else:
                pass
                #res = {'success': False, 'msg': 'No lua file inside source file'}
          notify_activity.configChangedBatch(
              activities=activities,
              filename=FilePaths.CONFIG_JOB_IMPORTER,
              session=session
          )
          return response.json({'success': True, 'msg': ':-)'})
        else:
          res = {'success': False, 'msg': 'No file inside source file'}
      else:
        res = {'success': False, 'msg': 'Expansion process failed'}
  except Exception, e:
    syslog.syslog(syslog.LOG_DEBUG, traceback.format_exc())
    syslog.syslog(syslog.LOG_DEBUG, traceback.format_stack())
    res['success'] = False
    res['msg'] = str(e)
  finally:
    fsio.fsXngLock.release()
  return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def exportSelected():
  res = {'success': False, 'msg': 'Unknown error'}
  try:
    allfilenames = glob.glob(FilePaths.JOB_PATH + "/job*.lua")
    excludeList = request.vars.excludeList
    filenames = []
    if excludeList != None:
      for name in allfilenames:
        if type(excludeList) == type([]):
          if name not in excludeList:
            filenames.append(name)
        else:
          if name != excludeList:
            filenames.append(name)
    else:
      filenames = allfilenames

    filenames = ' '.join(filenames)
    if filenames == "":
      # Failure
      res['success'] = False
      res['msg'] = "Error no files included in export"
      return response.json(res)
    expfname = datetime.datetime.fromtimestamp(time.time()).strftime('%Y_%m_%d') + '_' + 'selectedJobs.nxjbx'
    pwd = FilePaths.gen_rev_pwd("jobs/job000.lua")
    res = {'success': True, 'msg': '/tmp/' + expfname}
    syslog.syslog(syslog.LOG_INFO, "START job.exportAll.subprocess to " + expfname + " at " + time.asctime())
    p = subprocess.Popen(['{0}/exportAll.sh'.format(FilePaths.SH_TOOL_PATH), pwd, expfname, filenames, '', '/tmp'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    syslog.syslog(syslog.LOG_INFO, "DONE job.exportAll.subprocess to " + expfname + " at " + time.asctime())
    syslog.syslog(syslog.LOG_INFO, "RESULT job.exportAll.subprocess to stdout: " + str(stdout))
    syslog.syslog(syslog.LOG_INFO, "RESULT job.exportAll.subprocess to stderr: " + str(stderr))
    if p.returncode != 0:
        # Failure
        res['success'] = False
        res['msg'] = str(stderr)
  except Exception as e:
    res['success'] = False
    res['msg'] = str(e)
  return response.json(res)
