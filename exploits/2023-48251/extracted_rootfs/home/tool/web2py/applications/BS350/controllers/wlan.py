# coding: utf8
import glob
import json
import shutil
import subprocess
import tempfile
import traceback
import WGDBus
import Activity
import fsio
import os
import syslog
import logConfig
import status_mod

from FilePaths import WLAN_FILENAME
from FilePaths import WLAN_DEFAULT_FILENAME

# Fake globals for syntax check
import notify_activity

if False:
  response = None
  request = None
  session = None
  db = None

status_mod.sessionUserMgr.setLastVisit(session, request)
if logConfig.wlanSessFrgt:
    session.forget(response)

FCC_FILENAME = '/home/tool/config/fcc.json'
CA_CERT_FILENAME = '/home/tool/config/wlan/cert/ca-cert.pem'
CLIENT_CERT_FILENAME = '/home/tool/config/wlan/cert/client-cert.pem'
PRIVATE_KEY_FILENAME = '/home/tool/config/wlan/cert/private-key.pem'
CERT_FILEPATH = '/home/tool/config/wlan/cert/'


@auth.requires(request.ajax==True, requires_login=True)
def fcc():
  if request.env.request_method == "GET":
    res = fsio.jsonload(FCC_FILENAME)
    wlanRes = fsio.jsonload(WLAN_FILENAME)
    res['fcc-test-mode'] = wlanRes['fcc-test-mode']

    return json.dumps(res)

  if request.env.request_method == "POST":
    data = json.loads(request.body.read())
    fccTestMode = data['fcc-test-mode']
    data.pop('fcc-test-mode', None)
    wlanRes = fsio.jsonload(WLAN_FILENAME)

    fsio.jsondump(FCC_FILENAME, data)
    if wlanRes['fcc-test-mode'] != fccTestMode:
      wlanRes['fcc-test-mode'] = fccTestMode
      # if fccTestMode:
      #  wlanRes['interface'] = True
      fsio.jsondump_sorted(WLAN_FILENAME, wlanRes)

    notify_activity.configChanged(FCC_FILENAME, Activity.FCC_CHANGED, session=session)
    WGDBus.setFccTestMode(fccTestMode)


@auth.requires(request.ajax==True, requires_login=True)
def fccStartTx():
    import subprocess, os
    pid = os.getpid()
    f = open(r'/tmp/restartWlan_' + str(pid), 'a')
    exitCode = subprocess.call(['/opt/ti-wireless/WL6.1.6.0.3/fcc-test/fcc-test.sh start'], shell=True, stderr=subprocess.STDOUT, stdout=f)
    # exitCode = subprocess.call(['ls'], shell=True, stderr=subprocess.STDOUT, stdout=f)
    f.close()
    return exitCode


@auth.requires(request.ajax==True, requires_login=True)
def fccStopTx():
    import subprocess, os
    pid = os.getpid()
    f = open(r'/tmp/restartWlan_' + str(pid), 'a')
    exitCode = subprocess.call(['/opt/ti-wireless/WL6.1.6.0.3/fcc-test/fcc-test.sh stop'], shell=True, stderr=subprocess.STDOUT, stdout=f)
    # exitCode = subprocess.call(['ls'], shell=True, stderr=subprocess.STDOUT, stdout=f)
    f.close()
    return exitCode


def cleanDir(keepFiles):
  try:
    if keepFiles != None:
      p = os.path.expandvars(CERT_FILEPATH)
      dirpath, dirnames, filenames = os.walk(p).next()
      if filenames != None:
        if len(filenames) != 0:
          for f in filenames:
            delF = True
            for cf in keepFiles:
              if cf == f:
                delF = False
                break
            if delF:
              path = os.path.join(CERT_FILEPATH, f)
              os.remove(path)
  except:
    return '1'
  return '0'


@auth.requires(request.ajax==True, requires_login=True)
def cleanDirReq():
    return cleanDir(request.vars.cert)


@auth.requires(request.ajax==True, requires_login=True)
def cfg():
  if request.env.request_method == "GET":
    res = fsio.jsonload(WLAN_FILENAME)
    return json.dumps(res)

  if request.env.request_method == "POST":
    res = fsio.jsonload(WLAN_FILENAME)
    data = json.loads(request.vars.data)
    data['fcc-test-mode'] = res['fcc-test-mode']
    data['power-mode'] = 1
    data['802-11-h'] = False
    data['power-level'] = 0
    data['power-level-default'] = 0
    data['doze-mode'] = 2
    # CR 8266: fcc test mode is completly independent, if a user changes the wlan configuration
    # we do not need to disable it:
    #if data['interface'] == False:
    #  data['fcc-test-mode'] = False
    fsio.jsondump_sorted(WLAN_FILENAME, data)
    #WGDBus.setFccTestMode(False)
    #CR9249
    cleanDir(request.vars.cert)
    notify_activity.configChanged(WLAN_FILENAME, Activity.WLAN_CHANGED, session=session)
    return restartWlan()


@auth.requires(request.ajax==True, requires_login=True)
def resetToFactory():
    fsio.shcopyfile(WLAN_DEFAULT_FILENAME, WLAN_FILENAME)
    notify_activity.configChanged(WLAN_FILENAME, Activity.WLAN_CHANGED, session=session)
    return restartWlan()


@auth.requires(request.ajax==True, requires_login=True)
def resetFccToFactory():
    fsio.shcopyfile('/home/tool/config/default/fcc.json', FCC_FILENAME)
    notify_activity.configChanged(WLAN_FILENAME, Activity.WLAN_CHANGED, session=session)
    return restartWlan()


@auth.requires(request.ajax==True, requires_login=True)
def active():
    # syslog.syslog(syslog.LOG_DEBUG, "started wlan/active()")
    res = fsio.jsonload(WLAN_FILENAME)
    # syslog.syslog(syslog.LOG_DEBUG, "wlan/active() " + WLAN_FILENAME + " loaded")
    return response.json(res['interface'])



@auth.requires(request.ajax==True, requires_login=True)
def fccTestModeActive():
    res = fsio.jsonload(WLAN_FILENAME)
    return response.json(res['fcc-test-mode'])

#def active():
#  #syslog.syslog(syslog.LOG_DEBUG, "started wlan/active()")
#  res = FileIface.getWlanActive()
#  #syslog.syslog(syslog.LOG_DEBUG, "wlan/active() " + str(res))
#  return response.json(res)
#
#def fccTestModeActive():
#  res = FileIface.getFccTestModeActive()
#  return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def restartWlan():
    import subprocess, os
    pid = os.getpid()
    f = open(r'/tmp/restartWlan_' + str(pid), 'a')
    exitCode = subprocess.call(['/opt/ti-wireless/WL6.1.6.0.3/install.sh restart'], shell=True, stderr=subprocess.STDOUT, stdout=f, close_fds=True)
    # exitCode = subprocess.call(['ls'], shell=True, stderr=subprocess.STDOUT, stdout=f)
    f.close()
    return exitCode


@auth.requires_login()
def uploadCaCert():
    filename = request.vars.fileupload.filename.split("\\")[-1]
    fileupload_filepath = CERT_FILEPATH + filename
    fsio.write(fileupload_filepath, request.vars.fileupload.value)
    notify_activity.configChanged(filename, Activity.WLAN_CHANGED, session=session)
    res = dict()
    res['success'] = True
    res['ca_cert'] = filename
    return response.json(res)


@auth.requires_login()
def uploadClientCert():
    filename = request.vars.fileupload.filename.split("\\")[-1]
    fileupload_filepath = CERT_FILEPATH + filename
    fsio.write(fileupload_filepath, request.vars.fileupload.value)
    notify_activity.configChanged(filename, Activity.WLAN_CHANGED, session=session)
    res = dict()
    res['success'] = True
    res['client_cert'] = filename
    return response.json(res)



@auth.requires_login()
def uploadPrivateKey():
    filename = request.vars.fileupload.filename.split("\\")[-1]
    fileupload_filepath = CERT_FILEPATH + filename
    fsio.write(fileupload_filepath, request.vars.fileupload.value)
    notify_activity.configChanged(filename, Activity.WLAN_CHANGED, session=session)
    res = dict()
    res['success'] = True
    res['private_key'] = filename
    return response.json(res)


@auth.requires_login()
def uploadP12Cert():
    password = request.vars.password_p12_cert
    filename = request.vars.fileupload.filename.split("\\")[-1]
    file = tempfile.mkstemp()
    fileupload_filepath = file[1]
    fsio.write(fileupload_filepath, request.vars.fileupload.value)
    cmd_line = ['/opt/ti-wireless/ssl/convert-p12-to-pem.sh', 'base', fileupload_filepath, password]
    p = subprocess.Popen(cmd_line, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    res = dict()
    if p.returncode == 0:
        res['success'] = True
        res['certs'] = {}
        res['certs']['ca_cert'] = "ca-cert.pem"
        res['certs']['client_cert'] = "client-cert.pem"
        res['certs']['private_key'] = "private-key.pem"
        res['certs']['private_key_passwd'] = password
        set_pem_names(password=password)
        res['p12_cert'] = filename
    else:
        res['success'] = False
        res['p12_cert'] = filename
        res['msg'] = stderr
    os.unlink(fileupload_filepath)
    return response.json(res)


def set_pem_names(password=None):
    wfile = fsio.jsonload(WLAN_FILENAME)
    wfile.get('connections')[0].get('security')['ca_cert'] = "ca-cert.pem"
    wfile.get('connections')[0].get('security')['client_cert'] = "client-cert.pem"
    wfile.get('connections')[0].get('security')['private_key'] = "private-key.pem"
    if password is not None:
        wfile.get('connections')[0].get('security')['private_key_passwd'] = password
    fsio.jsondump_sorted(WLAN_FILENAME, wfile)
    notify_activity.configChanged(WLAN_FILENAME, Activity.WLAN_CHANGED, session=session)


@auth.requires(request.ajax==True, requires_login=True)
def extract_private_key_passwd():
    passwd = ""
    wlan = fsio.jsonload(WLAN_FILENAME)
    try:
        passwd = wlan.get('connections')[0].get('security').get('private_key_passwd')
    except:
        syslog.syslog(syslog.LOG_ERR,
                      "could not get private key passwd from wlan.json: {0}".format(traceback.format_exc()))
        for l in traceback.format_stack():
            syslog.syslog(syslog.LOG_ERR, "wlan.json struct... stack: {0}".format(l))
    passwd = passwd.strip()
    return passwd


@auth.requires_login()
def uploadP12CertAdd():
    filename = request.vars.fileupload.filename.split("\\")[-1]
    file = tempfile.mkstemp()
    fileupload_filepath = file[1]
    fsio.write(fileupload_filepath, request.vars.fileupload.value)
    cmd_line = ['/opt/ti-wireless/ssl/convert-p12-to-pem.sh', 'add', fileupload_filepath, extract_private_key_passwd()]
    p = subprocess.Popen(cmd_line, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    res = dict()
    if p.returncode == 0:
        res['success'] = True
        res['certs'] = {}
        res['certs']['ca_cert'] = "ca-cert.pem"
        res['certs']['client_cert'] = "client-cert.pem"
        res['certs']['private_key'] = "private-key.pem"
        set_pem_names()
        res['p12_cert_add'] = filename
    else:
        res['success'] = False
        res['p12_cert_add'] = filename
        res['msg'] = stderr
    os.unlink(fileupload_filepath)
    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def certFilenames():
    #res = [{'filename': 'abc'}, {'filename': 'def'}]
    lpem = glob.glob(CERT_FILEPATH + "*.pem")
    lder = glob.glob(CERT_FILEPATH + "*.der")
    l = lpem + lder
    l.sort()

    def getcerts(item):
        b = os.path.basename(item)
        return {'filename': b}
    res = map(getcerts, l)
    return response.json(res)
