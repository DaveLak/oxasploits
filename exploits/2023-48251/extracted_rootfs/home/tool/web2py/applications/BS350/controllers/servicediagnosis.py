#!/usr/bin/env python
import os
import re
import string
import time
import xml.etree.ElementTree as ET
import zipfile
from Queue import Queue, Empty
from shutil import rmtree
from subprocess import Popen, PIPE, call
from syslog import syslog, LOG_DEBUG, LOG_WARNING, LOG_ERR
from threading import Thread

import Activity
import FileIface
import fsio
import logConfig as db
import status_mod
import WGDBus


# Fake globals for syntax check
if False:
    session = None
    request = None
    response = None

status_mod.sessionUserMgr.setLastVisit(session, request)

PATH_PRUE = '/home/tool/bin/PruefSoftware.py'
PATH_FW = '/home/tool/config/service/FwPack/'
PATH_IMG = '/Images/'
PATH_TP = '/home/tool/config/service/TypePlates/'


@auth.requires(request.ajax==True, requires_login=True)
def isFullVersion():
    if os.path.exists(PATH_FW) and os.path.exists(PATH_IMG):
        return True

    return False


################
#   hardware   #
################
class ReaderThread(Thread):
    def __init__(self, stream, queue):
        Thread.__init__(self)
        self.stream = stream
        self.queue = queue
        self.signal = False
        self.daemon = True

    def run(self):
        while not self.signal:
            line = self.stream.readline()
            if line:
                self.queue.put(line)
            else:
                time.sleep(0.1)

    def stop(self):
        self.signal = True


class NonBlockingStreamReader:

    def __init__(self, stream):
        """
        stream: the stream to read from.
                Usually a process' stdout or stderr.
        """
        self._q = Queue()
        self._t = ReaderThread(stream, self._q)
        self._t.start()

    def __del__(self):
        self._t.stop()
        # Problems joining with 100ms sleep; if join times out thread will be ended anyway
        self._t.join(1)

    def readline(self, timeout = None):
        try:
            line = self._q.get(block = timeout is not None,
                    timeout = timeout)
            return line
        except Empty:
            return None


class PruefSoftwareClient:
    def __init__(self):
        # !!!!!! close_fds needs to be set to True to prevent spamming web2py file desc streams !!!!
        # causes requests to disappear
        self._p = Popen(['chrt','-r','1','python','-u',PATH_PRUE,'-g','browser'], close_fds=True, shell=False,stdin=PIPE, stdout=PIPE, stderr=PIPE)
        self._nbsr = NonBlockingStreamReader(self._p.stdout)

    def write(self, command):
        self._p.stdin.write('<Command>'+ command + '</Command>\n')

    def close(self):
        self.write('exit')


@auth.requires(request.ajax==True, requires_login=True)
def client_running():
    if os.path.exists("/var/run/diag/service"):
        return FileIface.getPruefSoftwareActive()
    return 0


################
#  Control fct #
################
@auth.requires(request.ajax==True, requires_login=True)
def startClient():
    ret = {'success': True, 'msg': 'no error'}
    try:
        WGDBus.BusInst.pruefsoftware_started(True)

        if not client_running():
            db.pruefsoftware_client = PruefSoftwareClient()

    except Exception, e:
        ret['msg'] = str(e)
        ret['success'] = False
        syslog(LOG_ERR, 'Exception Pruefsoftware {}'.format(e))

    return response.json(ret)


@auth.requires(request.ajax==True, requires_login=True)
def readFromClient():
    output = db.pruefsoftware_client._nbsr.readline(0)
    return response.json(output)


@auth.requires(request.ajax==True, requires_login=True)
def writeToClient():
    try:
        command = request.vars['command']
        db.pruefsoftware_client.write(command)
        return 'OK'
    except Exception, e:
        syslog(LOG_DEBUG, 'Exception while write to client: {}'.format(e))
        return e


@auth.requires(request.ajax==True, requires_login=True)
def closeClient():
    try:
        if client_running():
            db.pruefsoftware_client.close()
        return
    except Exception, e:
        db.pruefsoftware_client = 0
        syslog(LOG_WARNING, 'Exception while closing pruefsoftware: {}'.format(e))
        return response.json('Exception {}'.format(e))


@auth.requires(request.ajax==True, requires_login=True)
def resetClient():
    try:
        db.pruefsoftware_client = 0
        WGDBus.BusInst.pruefsoftware_started(False)
    except Exception, e:
        return response.json(e)
    return


@auth.requires(request.ajax==True, requires_login=True)
def getTestNames():
    try:
        db.pruefsoftware_client.write('Tstfunc')
        time.sleep(1)
        res = readFromClient()
        tmp = string.replace(res[1:-3], '\\', '')
        root = ET.fromstring(tmp)
        ret = []
        for child in root:
            ret.append({'cmd': child.text, 'name': child.get('name'), 'info': child.get('info')})

        return response.json(ret)

    except Exception, e:
        syslog(LOG_WARNING, 'Error in getNames: '.format(e))
        return response.json(e)


def exportTestLog():
    data = request.vars.data

    cl_filename = "HwTest.log"
    response.headers['Content-Type'] = "text/plain"
    response.headers['Content-disposition'] = 'attachment; filename=%s' % cl_filename

    return data


##################
#   type plate   #
##################
@auth.requires(request.ajax==True, requires_login=True)
def getTemplateNames():
    ret = []

    # check existing directory
    if os.path.exists(PATH_TP):
        for item in next(os.walk(PATH_TP))[2]:
            if item.endswith('.typ'):
                ret.append({'text': item})
    if not ret:
        ret.append({'text': 'no template available'})

    return response.json(ret)


@auth.requires(request.ajax==True, requires_login=True)
def readTemplate():
    res = False
    templateName = request.vars['templateName']

    try:
        with open(PATH_TP + templateName, 'r') as f:
            res = f.read()
    except Exception, e:
        syslog(LOG_WARNING, "Exception in readTemplate: {}".format(e))

    return res


@auth.requires_login()
def importTemplate():
    res = {'success': True, 'msg': 'no error'}
    filename = request.vars.fileupload.filename

    fsio.fsXngLock.acquire()
    try:
        if not os.path.exists(PATH_TP):
            os.makedirs(PATH_TP)

        filepath = PATH_TP + filename
        with open(filepath, 'w') as f:
            f.write(request.vars.fileupload.value)

        res['msg'] = filename
    except Exception, e:
        res['success'] = False
        res['msg'] = str(e)

    finally:
        fsio.fsXngLock.release()

    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def readTypePlate():
    db.pruefsoftware_client.write('TypPltRd')
    tmp = ''
    res = ''
    # read from pipe until empty after first receive
    while (tmp is not 'null') or (res is ''):
        if tmp is not 'null':
            res += tmp
        else:
            time.sleep(0.5)
        tmp = readFromClient()

    res = string.replace(res[1:-3], '\\r\\n', '')
    res = string.replace(res, '\\', '')
    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def writeTypePlate():
    typePlateString = request.vars['typePlateString']

    try:
        tmp = re.search('MNR:\S*', typePlateString)
        mnr = tmp.group() if tmp is not None else 'MNR not found'
        tmp = re.search('Seriennummer:\S*', typePlateString)
        serialnumber = tmp.group() if tmp is not None else 'Seriennummer not found'
        tmp = re.search('TIX:\S*', typePlateString)
        tix = tmp.group() if tmp is not None else 'TIX not found'

        Activity.LOG(session, Activity.TYPEPLATE_CHANGED, 'Type Plate written: ', mnr + ' ' + serialnumber + ' ' + tix)

    except Exception, e:
        syslog(LOG_WARNING, 'Exception in writeTypePlate: {}'.format(e))

    typePlateString = string.replace( typePlateString, ':undefined', '')
    db.pruefsoftware_client.write(("TypPltWr<TypePlate>%s</TypePlate>"%typePlateString))


def exportTypePlate():
    msg = request.vars.msg

    cl_filename = "exportedTypePlate.typ"
    response.headers['Content-Type'] = "text/plain"
    response.headers['Content-disposition'] = 'attachment; filename=%s' % cl_filename

    return msg


def exportPrintData():
    msg = request.vars.msg

    cl_filename = "PrinterData.dat"
    response.headers['Content-Type'] = "text/plain"
    response.headers['Content-disposition'] = 'attachment; filename=%s' % cl_filename

    return msg

#######################
#   firmware update   #
#######################
@auth.requires(request.ajax==True, requires_login=True)
def getFwDirs():
    ### return all subdirectory from path in json format
    ret = []

    if os.path.exists(PATH_FW):
        for item in next(os.walk(PATH_FW))[1]: # 1: dirs, 2: files
            ret.append({'text': item})

    if not ret:
        ret.append({'text': 'no FwPack available'})

    return response.json(ret)


@auth.requires(request.ajax==True, requires_login=True)
def getMAC():
    try:
        db.pruefsoftware_client.write('GetMAC')
        time.sleep(2)
        res = readFromClient()
        mac = re.search('..-..-..-..-..-..', res.replace(' ', ''), flags=re.IGNORECASE)
        return mac.group()

    except Exception, e:
        return e

# def importFwPack():
#     ret = {"success": True}
#     filename = request.vars.fileupload.filename
#     filename = filename.replace(' ','')
#
#     tmp = re.search('NxFw.+', filename)
#
#     # rm possible path (IE) from filename
#     if tmp is not None:
#         filename = tmp.group()
#     else:
#         syslog(LOG_DEBUG, "Filename have to start with 'NxFw'")
#         return response.json({"success": False, "msg": 'Filename have to start with "NxFw"'})
#
#     filepath = PATH_FW + filename
#
#     try:
#         zip_ref = zipfile.ZipFile(request.vars.fileupload.file, 'r')
#         zip_ref.extractall(filepath.split('.')[0])
#         zip_ref.close()
#     except Exception, e:
#         syslog(LOG_WARNING, "Exception while importing, {}".format(e))
#         ret["success"] = False
#         ret['msg'] = str(e)

    return response.json(ret)


@auth.requires(request.ajax==True, requires_login=True)
def clear_cache():
    # clear cache after fileupload...
    call("echo 1 > /proc/sys/vm/drop_caches", shell=True)


@auth.requires(request.ajax==True, requires_login=True)
def removeFwPack():
    selPackName = request.vars['selPackName']

    if os.path.exists(PATH_FW + selPackName):
        rmtree(PATH_FW + selPackName)


@auth.requires(request.ajax==True, requires_login=True)
def updateFirmware():
    fwName = request.vars.version
    try:
        with open('/etc/version', 'r') as f:
            oldFw = f.read()
        Activity.LOG(session, Activity.FIRMWARE_CHANGED, 'Firmware update from {0} to {1}'.format(oldFw, fwName))
    except Exception, e:
        syslog(LOG_WARNING, "read version: {}".format(e))

    try:
        path = '/home/tool/config/service/FwPack/' + fwName

        # create symlinks
        dir1 = '/boot/'
        if os.path.exists(path):
            filelist = ['MLO.mmc', 'MLO.nand', 'NxLtFw.bin', 'u-boot.bin', 'uImage']
            for file in filelist:
                if os.path.islink(dir1 + file):
                    os.unlink(dir1 + file)
                elif os.path.isfile(dir1 + file):
                    os.remove(dir1 + file)
                os.symlink(path+'/'+file, dir1 + file)

            dir2 = '/Images'
            if not os.path.exists(dir2):
                os.mkdir(dir2)
            dir2 += '/rootfs.ubi'
            if os.path.islink(dir2):
                os.unlink(dir2)
            os.symlink(path+'/rootfs.ubi', dir2)

            db.pruefsoftware_client.write('WrFlash')

            return 'WrFlash started'

    except Exception, e:
        syslog(LOG_WARNING, "Exception while updateFirmware: {}".format(e))
        return e
