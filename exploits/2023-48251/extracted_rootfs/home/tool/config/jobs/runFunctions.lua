require "math"
c = require "constants"
plc=require "plcsignals"
math.randomseed(os.time())
math.random(); math.random();math.random()

module(..., package.seeall)

local config = {
   stopOnNok = true,
   stopOnTimeout = true
}

local initNode = {
   name = "initNode",
   timeout = 300,
   type = c.TypeStartNode,
   selectsCw = 0,
   selectsEn = 0,

}

local localDummyAtom = {
   name = "$localDummyAtom$$",
   type = c.TypeDevice,
   timeout  = 300,
   mode = c.DeviceModeLocal,
   dest = "0"  -- keine Knotennr. --
}

local waitForJobResultAtom = {
   name = "$waitForJobResultAtom$$",
   timeout = 300,
   type = c.TypeTriggerIn,
   mode = c.TriggerInModeJobResult,
   dest = 0,
   state = 0,
   range = 0,
}

local jobInitialized = false
local atomsPublished = false
local plausiChecked = false

local accu = {
}

local publishedAtoms = {
}

local atomSequence = {}

local function resetSettings()
   jobInitialized = false
   atomsPublished = false
   plausiChecked = false
   initNode = {
      name = "initNode",
      timeout = 300,
      type = c.TypeStartNode,
      selectsCw = 0,
      selectsEn = 0,
   }
   config = {
      stopOnNok = true,
      stopOnTimeout = true
   }
   accu = {}
   publishedAtoms = {}
   atomSequence = {}
end

--nodes und atome innerhalb des jobs aufraeumen
function cleanUpNodes(atoms,nodes)
  atoms=nil
  nodes=nil
end

function setConfiguration(configuration)
   config = configuration
end

function setInitNode(node)
   initNode = node
   --cpp.job:logMsg("setInitNode type " .. tostring(initNode.type))
end

local function abortJob(node)
   --assert(node.result, "Node \"" .. node.name .. "\" did not produce a result")
   --cpp.job:logMsg("abortJob " .. tostring(node.name) .. " evaluation " .. tostring(node.result.evaluation))

   --[[if node.atom.type == c.TriggerOutModeJobResult and initNode.type ~= c.TypeIdleStartNode then
     initNode.type = c.TypeIdleStartNode
   end]]
   if node.result.evaluation == c.jobResultValueOK then
      return false
   end
   if node.result.ko == c.jobResultValueKo then
      return true
   end
   if node.result.timeout == c.jobResultValueTimeout and config.stopOnTimeout then
      return true
   end
   return config.stopOnNok
end

local function initializeJob()
   if jobInitialized == true then
      return
   end
   cpp.job:action(initNode)
   jobInitialized = true
end

local function doAtom(atom)
   assert(atom, "Atom is NIL")
   if (atom.timeout == nil) then
      atom.timeout = 300
   end
   --cpp.job:logMsg("doAtom " .. tostring(atom.name))
   if ( atom.type == c.TypeTriggerOut and (atom.mode == c.TriggerOutModeSetOkNok or atom.mode == c.TriggerOutModeDelOkNok))then
     return cpp.job:setOkNokValues(atom)
   elseif ( atom.type == c.TypeTriggerOut and atom.mode == c.TriggerOutModeScanInit ) then
     return cpp.job:setScannerParams(atom)
   elseif (atom.type == c.TypeTriggerOut and atom.mode == c.TriggerOutModeIdCodeInit ) then
     return cpp.job:setIdCodeMasking(atom)
   elseif (atom.type == c.TypeTriggerOut and atom.mode == c.TriggerOutModeOperationMode ) then
     return cpp.job:declareOperationMode(atom)
   else
     if(atom.action~=nil)then
       --action pruefen
       assert(loadstring(atom.action),"error in action")
       --action ausfuehren
       loadstring(atom.action)()
       --aufraumen
       atom.action=nil
     end
     return cpp.job:action(atom)
   end
end

local function selectUndoDevices(pos)
   for i = pos, 1, -1 do
      local name = atomSequence[i]
      assert(publishedAtoms[name], "Wrong Atom " .. name .. " in AtomSequence found during deviceSelection")
      if publishedAtoms[name].type == c.TypeDevice or publishedAtoms[name].type == c.TypeDeviceGrp then
      --if publishedAtoms[name].type == c.TypeDevice then
	 return  doAtom(publishedAtoms[name])
      end
   end
   -- keine Node auswahl gefunden, nehme local dummy
   doAtom(localDummyAtom)
end

local function cleanUpJob()
   for i =  #atomSequence, 1, -1 do
      local name = atomSequence[i]
      assert(publishedAtoms[name], "Wrong Atom " .. name .. " in AtomSequence found during cleanUp")
      local undoAtom = publishedAtoms[name.."UNDO"]
      if  undoAtom ~= nil then
	 -- Undo atom gefunden!
	 selectUndoDevices(i)
	 doAtom(undoAtom)
      end
   end

end



local function finishJob()
   --cpp.job:logMsg("finishJob - start")
   local evalNode = {}
   evalNode.name = "EvalNode"
   evalNode.timeout = 300
   cpp.job:logMsg("finishJob - InitNode-> " .. tostring(initNode.type))
   if (initNode.type == c.TypeIdleStartNode) then
      --cpp.job:logMsg("finishJob - InitNode=c.TypeIdleStartNode")
      evalNode.type = c.TypeIdleEndNode
   else
      --cpp.job:logMsg("finishJob - InitNode!=c.TypeIdleStartNode")
      evalNode.type = c.TypeEndNode
   end
   evalNode.evaluation = c.jobResultValueOK
   for k,v  in pairs(accu) do
      if v.result.evaluation == c.jobResultValueNOK then
	 evalNode.evaluation = c.jobResultValueNOK
      end
   end
   cleanUpJob()
   cpp.job:action(evalNode)
   --- ab hier d�rfen keine Devices mehr ausgew�hlt werden, da durch clearSelectedDevices()
   -- alle Devices entfernt wurden.
   if (evalNode.type == c.TypeEndNode) then
	--doAtom(localDummyAtom)
	doAtom(waitForJobResultAtom)
   end
   --cleanUpJob()
   --cpp.job:logMsg("reset settings - start")
   resetSettings()
   --cpp.job:logMsg("reset settings - end")
   --cpp.job:logMsg("finishJob - end")
end

local function selectNextNode(node)
   if abortJob(node) then
      return go(EndNode)
   end
     --dump noderesult
   --cpp.job:logMsg("selectNextNode '" .. node.name .. "' - evaluation: " .. node.result["evaluation"] .. ", ko: " .. node.result["ko"] .. ", timeout: " .. node.result["timeout"])
   --cpp.job:logMsg("selectNextNode '" .. node.name .. "' - evaluation: " .. node.result["evaluation"] .. ", ko: " .. node.result["ko"] .. ", timeout: " .. node.result["timeout"] .. ", idcodestatus: " .. node.result["idcodestatus"])
   
   for k, v in pairs(node.successor) do
      assert(v.var, "var is nil")
      if(node.result[v.var] == v.val) then
	if v.var == "timeout" or ( v.var == "evaluation" and val == c.jobResultValueNOK) then
	  if node.atom.attempts then
	    cpp.job:logMsg("selectNextNode - attempts: " .. node.atom.attempts)
	    if node.atom.attempts > 1 and node.repeat_successor~=nil then
	      node.atom.attempts=node.atom.attempts-1
	      for i, j in pairs(node.repeat_successor) do
		assert(j.var, "var is nil")
		if(j.var== v.var and j.val == v.val)then
		  return go(j.next)
		end
	      end
	    end
	  end
	end
	--cpp.job:logMsg("selectNextNode - matching successor: " .. tostring(v.var) .. "->" .. tostring(v.val))
	return go(v.next)
      end
   end
   -- Kein Nachfolger Bestimmbar, oh oh
   return go(EndNode)
end

local function checkEnde(node)
   --cpp.job:logMsg("checkEnde " .. node.name)
   return node.ende == true
end


function go(node)
   assert(node, "node is nil")
   assert(atomsPublished, "Atoms not published to Firmware, please call \"publishAtoms()\" within your job")
   assert(plausiChecked, "No plausiblility check done , please call \"checkPlausib()\" first to your job")
   assert(node.name, "Node has no name")
   --cpp.job:logMsg("go " .. node.name)
   if checkEnde(node) then
      return finishJob()
   end
   initializeJob()
   if (node.step) then
	cpp.job:step(node.step)
   end
   node.result = doAtom(node.atom)
   assert(node.result, "Atom \"" .. node.atom.name .. "\" has not produced a result")
   table.insert(atomSequence, node.atom.name)
   accu[node.name]  = node
   return selectNextNode(accu[node.name])
end



-- Der Endnode hiltf uns auszusteigen
EndNode = {
   name = "EndNode",
   ende = true

}
function publishAtoms(atoms, publishFunction)
   for k,v in pairs(atoms) do
      if v.timeout == nil then
 		v.timeout = 300
 	  end
      v.name = k
      assert(v.type, "Type of Atom \"" .. v.name .."\" is NIL")
      publishFunction(v)
      publishedAtoms[v.name] = v
   end
   publishFunction(localDummyAtom)
   publishedAtoms[localDummyAtom.name] = localDummyAtom
   publishFunction(waitForJobResultAtom) 
   publishedAtoms[waitForJobResultAtom.name] = waitForJobResultAtom
   atomsPublished = true
end


function checkPlausib(nodes)
   for k,v in pairs (nodes) do
      v.name = k
   end
   plausiChecked = true
end

local function selectNextNodeOP(node, mid)
   for k, v in pairs(node.successor) do
	if (v.val == nil) then
	  --cpp.logMsg("selectNextNodeOP - v.var=" .. v.var )
	else
		if( node.result[v.var] == nil) then
			--print("value in table is nil")
		else 
			--print ("v.var=" .. v.var .. "   v.val=" .. v.val .. "   node.result[v.var]=" .. node.result[v.var])
		end
	end
        return goOP(v.next, mid, 1)
   end
end

function goOP(node, mid, call)
	assert(node, "node is nil")
	assert(atomsPublished, "Atoms not published to Firmware, please call \"publishAtoms()\" within your job")
	assert(plausiChecked, "No plusiblility check done , please call \"checkPlausib()\" first to your job")
	assert(node.name, "Node has no name")
	if( call == 0 ) then
		opstr=""
		forcedOrder=-1
		countOkAndNok=0
		schrauberSperren=-1
		prg99Freigeben=-1
		cntOfPset=0;
	end

	if (node.step) then
		--print("step")
	end
	if ( node.ende == true ) then
		--print(opstr)
		-- alles nun zusammensetzen
		if( forcedOrder == -1 ) then
			forcedOrder=1
		end
		if( schrauberSperren == -1 ) then
			schrauberSperren=0
		end
		if( prg99Freigeben == -1 ) then
			prg99Freigeben=0
		end
		midstr="02"..string.sub(initNode.jobName, 0, 25)
		midstr=midstr..string.rep(" ", 25 - #initNode.jobName)
		midstr=midstr.."03"..forcedOrder
		midstr=midstr.."04".."0000"			-- Maxtime for first tightening
		midstr=midstr.."05".."00000"			-- Maxtime to complete job
		midstr=midstr.."06"..countOkAndNok	-- Job batch mode
		midstr=midstr.."07"..schrauberSperren	-- Lock at job done
		midstr=midstr.."08".."0"				-- Use line control
		midstr=midstr.."09".."0"				-- Repeat Job
		midstr=midstr.."10"..prg99Freigeben		-- Tool loosening
		midstr=midstr.."11".."0"				-- Reserved
		midstr=midstr.."12"..string.format("%02d", cntOfPset).."13"..opstr	-- Anzahl Pset
		return midstr
	end
	--print("atom=" .. node.name)
	--print("atom.type=" .. node.atom.type)
	--print("atom.mode=" .. node.atom.mode)
	if( node.atom.mode == c.TriggerOutModeSetOkNok ) then
		cpp.job:logMsg("setze ok nok counter")
     
		max=table.maxn(node.atom.valueList)
		if( node.atom.state == 6 ) then
		
			if( schrauberSperren == -1 ) then
				schrauberSperren = node.atom.valueList[1]
			else
				if( node.atom.valueList[1] == 0 ) then		-- sobald 1 nicht sperren konfiguriert imme rnicht gesperrt �bertragen
					schrauberSperren = 0
				end
			end

			if( prg99Freigeben == -1 ) then
				prg99Freigeben = node.atom.valueList[1]
			else
				if( node.atom.valueList[2] == 0 ) then		-- sobald 1 1x programm freigeben definiert ist, dies imemr so setzen.
					prg99Freigeben = 0
				end
			end
			--prg99nachOkSperren     =  node.atom.valueList[3]
			--prg99nachNokSperren    =  node.atom.valueList[4]
			--summeUeberAlleZaehler  =  node.atom.valueList[5]
			--steckNussSignaleSetzen =  node.atom.valueList[6]
			-- Ab Formatkennung 5
			--decrementOkCounter =  node.atom.valueList[7]
			-- Ab Formatkennung 6
			--counterParaSource  =  node.atom.valueList[8]
			--blinkBxnSignals    =  node.atom.valueList[9]
			--bxnCoding          =  node.atom.valueList[10]
			--PrgAutoSel		=  node.atom.valueList[11]

			cfg=11;
			cnt=(max-cfg)/4
			if( cnt > 0 ) then
			
				-- Abarbeitungsreihenfolge bestimmen
				if( forcedOrder == -1 ) then
					if( cnt > 1 ) then
						forcedOrder=0	-- free
					else
						forcedOrder=1	-- forced
					end
				elseif ( forcedOrder == 0 ) then
					if( cnt == 1 ) then
						forcedOrder=2	-- free und forced
					end
				elseif ( forcedOrder == 1 ) then
					if( cnt > 1 ) then
						forcedOrder=2	-- free und forced
					end
				elseif ( forcedOrder == 2 ) then
					-- nix mehr tun
				else 
					forcedOrder=2
				end
			
				cv=0;
				for i=cfg+1,max,1 do
					if( node.atom.valueList[i] == nil ) then
						cpp.job:logMsg( "nil")
					else
						--print("Program: " .. node.atom.valueList[i] )
					end
				
					if( cv == 0 ) then
								
						cntOfPset=cntOfPset+1
					
						-- Nummer, two ascii channel id + three ascii pset + one ascii auto value
						opstr=opstr.."01:"..string.format("%03d", node.atom.valueList[i])..":".."0:"
					end
					if( cv == 1 ) then
						-- OK Limit
						opstr=opstr..string.format("%02d", node.atom.valueList[i])..";"
					end
					if( cv == 2 ) then
						-- NOK Limit
						if( node.atom.valueList[i] > 0 ) then
							countOkAndNok=1;
						end
					end
					if( cv == 3 ) then
						-- SocketTray und EndeKennung
					end
				
					cv=cv+1
					if( cv == 4 ) then
						cv=0
					end
				end
			end
		else
			cpp.job:logMsg("unknown ok nok counter configuration format")
		end
	end

	node.result = 1
	return selectNextNodeOP(node, mid)
end
