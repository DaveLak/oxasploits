import os
import pprint
import subprocess
import time
import multiprocessing
import syslog
import traceback
import fsio
import status_mod
import logConfig
import threading

__author__ = 'frank.sattelberger@bittwister.com'


if False:
  response = None
  request = None
  session = None
  db = None

status_mod.sessionUserMgr.setLastVisit(session, request)
if logConfig.networkSessFrgt:
    session.forget(response)


@auth.requires(request.ajax==True, requires_login=True)
def ping():
    res = {}
    target = request.vars.ping_target
    p = subprocess.Popen(['ping', "-I", "tiwlan0", "-c2", "-W2", target], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()
    if p.returncode != 0:
        # Failure
        res['success'] = True
        res['led'] = "red"
        if len(str(stderr)) > 0:
            res['msg'] = str("{target} DOWN".format(target=target))
        else:
            res['msg'] = str("{target} DOWN".format(target=target))
    else:
        res['success'] = True
        res['led'] = "green"
        res['msg'] = str("{target} UP".format(target=target))
    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def set_thread_running():
    logConfig.network_thread_running = True

@auth.requires(request.ajax==True, requires_login=True)
def set_thread_stop():
    logConfig.network_thread_running = False

@auth.requires(request.ajax==True, requires_login=True)
def thread_active():
    return logConfig.network_thread_running


@auth.requires(request.ajax==True, requires_login=True)
def set_capture_time(cap_time):
    logConfig.network_capture_time = cap_time

@auth.requires(request.ajax==True, requires_login=True)
def get_capture_time():
    return logConfig.network_capture_time


class workerThread (threading.Thread):
    def __init__(self, capture_time):
        threading.Thread.__init__(self)
        self.capture_time = capture_time
    def run(self):
        syslog.syslog(syslog.LOG_ERR, "WORKER started {0}".format(self.capture_time))

        timer = 0
        while thread_active():
            time.sleep(1)
            timer += 1
            if timer >= (self.capture_time * 60):
                break

        if thread_active():
            subprocess.Popen(['/etc/log/tcpdump.sh', 'stop'])

        syslog.syslog(syslog.LOG_ERR, "WORKER woke up")


@auth.requires(request.ajax==True, requires_login=True)
def start_tcpdump():
    capture_time = int(request.vars.tcpdump_capture_time)
    tcpdump_target = request.vars.tcpdump_target

    set_capture_time(capture_time)
    res = {}
    res['success'] = False
    if capture_time > 0:
        try:
            p = subprocess.Popen(['/etc/log/tcpdump.sh', tcpdump_target], close_fds=True)
            p.communicate()
            if p.returncode == 0:
                res['success'] = True
                res['msg'] = "Tcpdump started"

            set_thread_running()
            t = workerThread(capture_time)
            t.start()

            return response.json(res)
        except Exception, e:
            syslog.syslog(syslog.LOG_ERR, traceback.format_exc())
            res['success'] = False
            return response.json(res)

    try:
        p = subprocess.Popen(['/etc/log/tcpdump.sh', tcpdump_target], close_fds=True)  # , stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.poll()
        if p.returncode != 0:
            res['success'] = False
            if len(str(p)) > 0:
                res['msg'] = str(p)
            else:
                res['msg'] = str(p)

            return response.json(res)
    except Exception, e:
        res['msg'] = e.message
        res['success'] = False
        return response.json(res)

    res = {}
    res['success'] = True
    res['msg'] = "Hello"

    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def stop_tcpdump():
    tcpdump_target = request.vars.tcpdump_target

    p = subprocess.Popen(['/etc/log/tcpdump.sh', 'stop'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (stdout, stderr) = p.communicate()

    set_thread_stop()

    res ={}
    if p.returncode != 0:
        res['success'] = False
        if len(str(stderr)) > 0:
            res['msg'] = str(stderr)
        else:
            res['msg'] = str(stdout)

        return response.json(res)

    fname = '/var/run/' + tcpdump_target +'.dump'
    if os.path.getsize(fname) < 100000L:
        p = subprocess.Popen(['/usr/bin/tcpdump', '-r', fname], stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        (stdout, stderr) = p.communicate()
    else:
        res['success'] = True
        res['msg'] = "Tcpdump file to big to show in browser"
        return response.json(res)
    res = {}
    if p.returncode != 0:
        res['success'] = False
        if len(str(stderr)) > 0:
            res['msg'] = str(stderr)
        else:
            res['msg'] = str(stdout)

        return response.json(res)

    res['success'] = True
    if len(str(stdout)) < 10000:
        res['msg'] = str(stdout)
    else:
        res['msg'] = "Output to long"

    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def get_capture_time_rq():
    res = {'capture_time': get_capture_time()}
    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def end_tcpdump():
    tcpdump_target = request.vars.tcpdump_target

    fname = '/var/run/' + tcpdump_target + '.dump'
    res = { 'success': False, 'msg': '' }

    if os.path.isfile(fname):
        if os.path.getsize(fname) < 100000L:
            p = subprocess.Popen(['/usr/bin/tcpdump', '-r', fname], stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
            (stdout, stderr) = p.communicate()
            if p.returncode != 0:
                res['success'] = False
                if len(str(stderr)) > 0:
                    res['msg'] = str(stderr)
                else:
                    res['msg'] = str(stdout)

                return response.json(res)

            res['success'] = True
            if len(str(stdout)) < 10000:
                res['msg'] = str(stdout)
            else:
                res['msg'] = "Output to long"

        else:
            res['success'] = True
            res['msg'] = "Tcpdump file to big to show in browser"
            return response.json(res)

    return response.json(res)


def download_tcpdump():
    tcpdump_target = str(request.vars.tcpdump_target)

    filename = tcpdump_target + '.dump'
    cl_filename = tcpdump_target + '.cap'
    response.headers['Content-Type'] = "application/vnd.tcpdump.pcap"
    response.headers['Content-disposition'] = 'attachment; filename=%s' % cl_filename
    fullname = os.path.join("/var/run/", filename)
    res = ""
    if os.path.exists(fullname):
        res = response.stream(open(fullname, "rb"), chunk_size=4096)
        os.remove(fullname)
    return res


@auth.requires(request.ajax==True, requires_login=True)
def find_clients():
    stop_find_clients()
    res = {}
    res['success'] = True
    try:
        p = subprocess.Popen(['/etc/log/find-clients.sh', request.get_vars.network, request.get_vars.start,
                              request.get_vars.stop], close_fds=True)
        if p.returncode == 0:
            res['success'] = True
            res['msg'] = "Find Clients started"
    except OSError, e:
        res['success'] = False
        res['msg'] = e.strerror
    except Exception, e:
        res['success'] = False
        res['msg'] = traceback.format_exc()

    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def stop_find_clients():
    try:
        p = subprocess.Popen('kill -9 `pidof find-clients.sh`', shell=True)
        p.communicate()
    except Exception, e:
        syslog.syslog(syslog.LOG_ERR, traceback.format_exc())


@auth.requires(request.ajax==True, requires_login=True)
def gettiwlan0firstthreebytes():
    res = {}
    res['success'] = True
    try:
        p = subprocess.Popen("ip -4 addr show tiwlan0 | grep inet | awk '{print $2}' | cut -f 1 -d '/' | "
                             "cut -f 1-3 -d '.'", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (stdout, stderr) = p.communicate()
        res['msg'] = stdout
    except Exception, e:
        syslog.syslog(syslog.LOG_ERR, "tiwlan0 if ip addr error: {0}".format(stderr))
        res['success'] = False
        res['msg'] = "tiwlan0 ip address not retrievable"

    return response.json(res)


