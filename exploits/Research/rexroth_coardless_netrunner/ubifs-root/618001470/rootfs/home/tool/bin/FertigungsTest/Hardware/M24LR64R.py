# -*- coding: cp1252 -*-
'''
Created on 20.10.2011

@author: sth2mt
'''
'''
'''
'''
    def __new__(type):
        print "M24LR64Rnew"
        if not '_the_instance' in type.__dict__:
            print "neue Instanz anlegen"
            type.__instance__ = object.__new__(type)
        else:
            print "Instanz exisiert schon, vorhandene wird zurueckgegeben"
            pass
        return type.__instance__
'''
'''
import threading
import thread


class SingletonType(type):
    def __new__(mcls, name, bases, namespace):
        namespace.setdefault('__lock__', threading.RLock())
        namespace.setdefault('__instance__', None)
        return super(SingletonType, mcls).__new__(mcls, name, bases, namespace)

    def __call__(cls, *args, **kw):
        cls.__lock__.acquire()
        try:
            if cls.__instance__ is None:
                instance = cls.__new__(cls, *args, **kw)
                instance.__init__(*args, **kw)
                cls.__instance__ = instance
        finally:
            cls.__lock__.release()
        return cls.__instance__
'''

import FertigungsTest.Hardware.DatenBus.I2CDev as I2CDev
import time
 
class Treiber(object):
    '''
    classdocs
    '''
    # Achtung dies ist Pseudo Singleton -> variablen werden statisch verwendet. Aufgeraumt wird erst wenn alle instanzen weg sindwird nur einmal instaniiert !!!!
    ObjCount = 0
    _Thread_name = "M24LR64R"
    stout = False
    I2CEepromUser =   0x50
    I2CEepromSystem = 0x54
    Login = False
    I2CPassword = b'\x00\x00\x00\x00'
    I2CPasswordWrong = b'\xff\xff\xff\xff'
    O_I2CDev = None


    def __init__(self):
        '''
        Constructor
        '''
        Treiber.ObjCount += 1
        self.printf("%i.Construktor %s" % (Treiber.ObjCount,Treiber._Thread_name))
        self.I2CEeprom = Treiber.I2CEepromUser
        if Treiber.O_I2CDev==None:
            Treiber.O_I2CDev = I2CDev.Treiber(2)



        pass
        
        
    def __del__(self):
        '''
        Destructor
        '''
        self.printf("%i Destruktor %s" % (Treiber.ObjCount,Treiber._Thread_name))
        
        if Treiber.ObjCount == 1:
            self.printf("Reste aufraumen")
            del(Treiber.O_I2CDev)
            Treiber.O_I2CDev = None
            
        if Treiber.ObjCount > 0:
            Treiber.ObjCount -= 1
            
        pass
    
        
    def setUserMode(self):
        self.I2CEeprom = Treiber.I2CEepromUser
        return True

    def setSystemMode(self):
        self.I2CEeprom = Treiber.I2CEepromSystem
        return True


    def sendPasswordI2C(self,s_Password,c_validationcode):
        try:
            if len(s_Password) != 4:
                print "M24LR64R.sendPasswordI2C(0x%x) Laenge %i !=4" %(self.I2CEeprom, len(s_Password))
                return False
            self.setSystemMode()
            self.printf( "M24LR64R.sendPasswordI2C() 0x%x" % self.I2CEeprom)
            cPasswortSEQ = s_Password + ("%c" % c_validationcode) + s_Password
            # als string initialisieren
            string = "0x%02x" % ord(cPasswortSEQ[0])
            for i in range (1,9,1):
                string += (",0x%02x"% ord(cPasswortSEQ[i]))  
            self.printf(string)
            Treiber.O_I2CDev.f_Write16(self.I2CEeprom,0x900,cPasswortSEQ,9)
            self.Login = True
            self.printf( "M24LR64R.sendPasswordI2C() 0x%x OK" % self.I2CEeprom)
            self.setUserMode()
            return True
        except IOError,e:
            print "M24LR64R.sendPasswordI2C() Error 0x%x %s" %(self.I2CEeprom, e)
            self.setUserMode()
            self.Login = False
            return False
        pass

    def LogOnI2C(self):
        self.printf( "M24LR64R.LogOnI2C()")
        if self.sendPasswordI2C(Treiber.I2CPassword,b'\x09'):
            self.Login = True
            return True
        else:
            print "M24LR64R.LogOnI2C() Error 0x%x" % self.I2CEeprom
            self.Login = False
            return False
        pass
    
    def LogOffI2C(self):
        # Gleiches Passwortr nochmals setzen
        if self.sendPasswordI2C(Treiber.I2CPasswordWrong,b'\x09'):
            self.printf("LogOffI2C OK\n")
            return True
        else:
            self.printf("LogOff Error\n")
            return False
        pass
    
    def ChangePasswordI2C(self,s_newPassword):
        self.printf( "M24LR64R.ChangePasswordI2C()")
        if len(s_newPassword) != 4:
            print "M24LR64R.sendPasswordI2C(%s) Laenge %i !=4" %(s_newPassword, len(s_newPassword))
            return False
        if self.sendPasswordI2C(s_newPassword,b'\x07'):
            Treiber.Login = False
            self.printf( "M24LR64R.ChangePasswordI2C() 0x%x OK" % self.I2CEeprom)
            return True
        else:
            print "M24LR64R.ChangePasswordI2C(%s) Error" % s_newPassword
            # zur Sicherheit auf ausgeloogt setzen
            Treiber.Login = False
            return False
        pass
    
    def ReadI2CWriteLock(self):
        try:
            self.setSystemMode()
            self.printf( "M24LR64R.ReadI2CWriteLock() 0x%x" % self.I2CEeprom)
            sWriteLockArea = self.read(0x800, 8)

            if self.stout:
                for i in range(0,len(sWriteLockArea),1):
                    print "0x%x," % ord(sWriteLockArea[i]),
                print "\n"
            
            self.printf( "M24LR64R.ReadI2CWriteLock() 0x%x OK" % self.I2CEeprom)
            self.setUserMode()
            
            return True
        except IOError,e:
            print "M24LR64R.ReadI2CWriteLock() Error 0x%x %s" %(self.I2CEeprom, e)
            self.setUserMode()
            return False
        pass
    
    def WriteI2CWriteLock(self,sWriteLockArea):
        try:
            self.setSystemMode()
            self.printf( "M24LR64R.WriteI2CWriteLock() 0x%x" % self.I2CEeprom)
            if self.stout:
                for i in range(0,8,1):
                    print "0x%x," % ord(sWriteLockArea[i]),
                print "\n"
            self.write(0x800, sWriteLockArea)
            self.printf("write(0x800,sWriteLockArea:%s)"%sWriteLockArea)
            
            self.printf( "M24LR64R.WriteI2CWriteLock() 0x%x OK" % self.I2CEeprom)
            self.setUserMode()
            
            
            return True
        except IOError,e:
            print "M24LR64R.WriteI2CWriteLock() Error 0x%x %s" %(self.I2CEeprom, e)
            self.setUserMode()
            return False
        
        pass
    

    def read(self,iOffset,iAnzahl):
        # einlesen
        if (iAnzahl < 0) & ((iAnzahl+iOffset) > 0x1FFF):
            return None 
        try:
        # Lesen iAnzahl Byte
            self.printf ("M24LR64R.read(Adress=0x%x  iOffset=%i,Anzahl=%i)" %(self.I2CEeprom,iOffset,iAnzahl))
            s_string=Treiber.O_I2CDev.f_Read16(self.I2CEeprom,iOffset,iAnzahl)
            
            #if self.stout:
            #   for i in range(0,iAnzahl,1):
            #      print "0X%2X,"%ord(s_string[i]),
                
            return s_string
        except IOError,e:
            print "M24LR64R.read(Adress=0x%x  iOffset=%i,Anzahl=%i) Error %s" %(self.I2CEeprom,iOffset,iAnzahl, e)
            return None
        

    def write(self,iOffset,cbytes):
        # Es koennen nur 4Bytes am Stueck geschrieben werden
        AnzahlUebrig=len(cbytes)
        Uebertragen=0
        self.printf( "M24LR64R.write(Adress=0x%x iOffset=%i,Anzahl=%i)" %(self.I2CEeprom,iOffset,len(cbytes)))
        if (iOffset < 0) & ((iOffset+len(cbytes)) >0x1FFF):
            self.printf( "M24LR64R.write(iOffset=%i,Anzahl=%i) Error Endof Memory" %(iOffset,len(cbytes)))
            return False
        # Lesen 1 Byte
        rest_row=4-(iOffset & 0x03)
        self.printf( "M24LR64R.write(rest_row=0x%x )" %(rest_row))
        try:
            index = 0
            Uebertragen = 0
            if (rest_row<4) and (rest_row>0) :
                if AnzahlUebrig>rest_row:
                    NumberToWrite = rest_row
                else:
                    NumberToWrite = AnzahlUebrig
                #1. row aufuellen
                self.printf( "M24LR64R.write %i. f_Write16(cbytes[%i:%i] NumberToWrite=%i -> row aufuellen " %(index,Uebertragen,NumberToWrite,NumberToWrite))
                if Treiber.O_I2CDev.f_Write16(self.I2CEeprom,iOffset,cbytes[0:NumberToWrite],NumberToWrite)<0:
                    raise IOError
                AnzahlUebrig-=NumberToWrite
                Uebertragen=len(cbytes)-AnzahlUebrig
                index += 1


            while AnzahlUebrig:
                if AnzahlUebrig < 4:
                    NumberToWrite = AnzahlUebrig 
                else:
                    NumberToWrite = 4
                Uebertragen=len(cbytes)-AnzahlUebrig
                self.printf( "M24LR64R.write %i. f_Write16(cbytes[%i:%i] NumberToWrite=%i " %(index,Uebertragen,Uebertragen+4,NumberToWrite))
                if Treiber.O_I2CDev.f_Write16(self.I2CEeprom,iOffset+Uebertragen,cbytes[Uebertragen:Uebertragen+4],NumberToWrite)<0:
                    raise IOError
                AnzahlUebrig -= NumberToWrite
                index+=1
                
                    
            return True
        except IOError,e:
            time.sleep(0.1)
            print "M24LR64R.write(iOffset=%i,Anzahl=%i) Error %s" %(iOffset,len(cbytes), e)
            return False
        pass

    
    def printf(self,string):
        if Treiber.stout:
            print string
        pass
        