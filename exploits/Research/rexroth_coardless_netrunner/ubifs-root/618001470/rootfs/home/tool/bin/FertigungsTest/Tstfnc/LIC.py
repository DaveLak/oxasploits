# -*- coding: cp1252 -*-
'''
Created on 24.11.2011

@author: sth2mt
'''
import time
import threading
import thread
from ctypes import pythonapi, py_object
import signal, os
import FertigungsTest.GUI.Display as Display
import FertigungsTest.Hardware.AD7999 as AD7999


# <Command>LicTst</Command>
# <Command>exit</Command>


def kill(thread,iStopTimeout,tid):
    if thread:
        thread.printf ("kill iStopTimeout=%d"%iStopTimeout)
        time.sleep(iStopTimeout)
        #nach xs hart beenden
        if thread.isAlive():
            
            res = pythonapi.PyThreadState_SetAsyncExc(tid,py_object(SystemExit))
            if res == 0:
                raise ValueError("nonexistent thread id (%s)" % thread._Thread_name)
            elif res > 1:
                pythonapi.PyThreadState_SetAsyncExc(tid,0)
                raise SystemError("PyThreadState_SetAsyncExc failed")
            else :
                thread.printf ("kill Thread %s" % thread._Thread_name)
                thread.errorcode=2000
                thread.isTimeout=True
                thread.__del__()
        else:
            thread.printf ( "kill %s not allive" % thread._Thread_name)
    else:
        print "kill: no handle"
   
        

class Prueffunktionen(threading.Thread):
    '''
    classdocs
    '''
    def __init__(self, O_Parser,O_Serializer,param=None):
        '''
        Constructor
        '''
        self._Thread_name = "LicTst"
        self.stout = False
        self.printf( "Constructor %s" % self._Thread_name)
        threading.Thread.__init__(self)
        super(Prueffunktionen,self).__init__()
        self._EventStop = threading.Event()
        self.iStopTimeout = 2 # Stop Timeout bis zum Kill
        self.iTimeout = 35 # Stop Timeout bis zum Kill
        self.errorcode=2000 # Fehlercode vorbelegen, Wenn Ok wird zurueckgesetzt
        self.isTimeout=False
        self.bBattery=True
        self.VersorgungsSpannung=5
        self.WartezeitLICsec=20 #Zeit bei abgezogenem Akku, die LIC System mit Energie versorgen kann.
        
        
        self.O_XmlParser = O_Parser
        self.O_XML_Cmd = O_Serializer
        self.O_Display = Display.Treiber()
        self.O_AD7999 = AD7999.Treiber()
        self.O_Display.setHeadlines("Endpr\xc3\xbcfung","LIC")
        self.O_Display.paintDisplay()
        #test signalhandler
        def sig_handler_BatteryRemoved( signum, frame):
            self.printf( "%s::sig_handler_battery() Battery removed" % self._Thread_name)
            self.bBattery=False
            self.VersorgungsSpannung=0
            return
        def sig_handler_BatteryInsert( signum, frame):
            self.printf( "%s::sig_handler_battery() Battery insert" % self._Thread_name)
            self.bBattery=True
            self.VersorgungsSpannung=5
            return
        signal.signal(signal.SIGUSR1, sig_handler_BatteryRemoved)
        signal.signal(signal.SIGUSR2, sig_handler_BatteryInsert)

        #sprintf(a_c_ShellCmd,"echo %d > /proc/pwrctrl/batalert", getpid());
        #printf("a_c_ShellCmd: %s\n", a_c_ShellCmd);
        os.system("echo %d > /proc/pwrctrl/batalert"%os.getpid())
        
        
        pass
    
    def __del__(self):
        
        '''
        Destructor
        '''
        self.printf( "Destructor %s" % self._Thread_name)
        print "%s"%self.O_XML_Cmd.BuildRueckgabewert(self._Thread_name,"Rueckgabewert von %s"%self._Thread_name,None,self.errorcode,None)
 
        # Display bedienen
        if (self.isTimeout | self._EventStop.isSet()):
            #Abbruch der Funktion -> Fehler anzeigen
            if self._EventStop.isSet():
                self.O_Display.setAction("Abbruch","","")
            else:
                #Timeout der Funktion -> Fehler anzeigen
                self.O_Display.setAction("Timeout","","")
            self.O_Display.setOKNOK(0)
            self.O_Display.clrSelect()
        else:
            # kein Abbruch oder Timeout -> System ausschalten
            self.printf( "poweroff")
            self.O_Display.clrSelect()
            for i in range(5,0,-1):
                if not self.errorcode:
                    self.O_Display.setAction("Ts\xc3\xbc\xc3\xbc\xc3\xbc\xc3\xbcsss !",("Hasta la vista! %is"%i),"OK",None,self.O_Display.sColorGreen)
                else:
                    self.O_Display.setAction("Ts\xc3\xbc\xc3\xbc\xc3\xbc\xc3\xbcsss !",("Hasta la vista! %is"%i),"NOK",None,self.O_Display.sColorRed)
                self.O_Display.paintDisplay()
                time.sleep(1)

            # System in PwrDown fahren    
            os.system("poweroff")
            
        del(self.O_AD7999)
        del(self.O_Display)    
        # Belegung der Prueffunktion im Parseer objekt loeschen -> Freigabe
        self.O_XmlParser.AktivePrueffunktion=None
       
        pass
    
    def stop(self):
        # Thread normal beenden
        self.printf("stop")
        if self.isAlive():
            self._EventStop.set()
            # Kill-thread falls dieser thread sich nicht nach 30s beendet
            for tid, tobj in threading._active.items():
                if tobj is self:
                    thread.start_new_thread(kill,(self,self.iStopTimeout,tid))
        #print "stop Ende"
        pass
    def run(self):
        # Ablauf starten
        self.printf("Ablauf starten")
        print "%s"%self.O_XML_Cmd.BuildTimeout(self.iTimeout,self._Thread_name)
        print "%s"%self.O_XML_Cmd.BuildPrintMainText("LithiumIonenKondensator pruefen")

        # Watchdogtimer anstarten -> beendet Thread anch timeout
        for tid, tobj in threading._active.items():
            if tobj is self:
                thread.start_new_thread(kill,(self,self.iTimeout-self.iStopTimeout-1,tid))

        
        self.Ablauf()
        self.printf("Nach Ablauf")
        self.__del__()
        pass
    
    def stopped(self):
        return self._EventStop.isSet()
    


    def Ablauf(self):
        self.printf("Lic Test")
        self.O_Display.ResetLastError()
        self.O_Display.setAction("Versorgung","abschalten...","")
        self.O_Display.setFortschritt(10)
        self.O_Display.paintDisplay()
        # 5 s Warten
        self.O_AD7999.readAnalog(2)
        for i in range (0,9,1):
            self.O_Display.setFortschritt(5+i*5)
            print "%s"%self.O_XML_Cmd.BuildProgressbar(5+i*5)
            #self.VersorgungsSpannung=(self.O_AD7999.readAnalog(2)*5.0)/255
            self.O_Display.setAction("Versorgung","%1.2f V"%(self.VersorgungsSpannung),"")
            
            #if self.VersorgungsSpannung<1:
            if self.bBattery == False:
                break

        
            time.sleep(.5)   
            if self.stopped():
                return
        # Versorgungspannung pruefen ob abgeschaltet
        uSpannung = self.O_AD7999.readAnalog(2)
        self.printf("uSpannung %i"%uSpannung)
        #if uSpannung < 50 :
        if self.bBattery == True :
            # Fehler Abbruch, Versorgung nicht durch Pruefstand abgeschaltet
            return

            
        for i in range ((self.WartezeitLICsec/5*10),0,-1):
            self.O_Display.setFortschritt(90-i)
            print "%s"%self.O_XML_Cmd.BuildProgressbar(90-i)
            #self.VersorgungsSpannung=(self.O_AD7999.readAnalog(2)*5.0)/255
            self.O_Display.setAction("Versorgung","%1.2f V"%(self.VersorgungsSpannung),"%1.1f sec"%(i*0.5))
            
            self.printf("Warte auf Ende")
        
            time.sleep(.5)   
            if self.stopped():
                return
           
        if self.bBattery == False :
            self.errorcode = 0

        self.O_Display.setOKNOK(not self.errorcode)            
        self.O_Display.setFortschritt(100)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(100)
           
        self.printf("Lic Test -> Ende")
        pass
    
    def printf(self,string):
        if self.stout:
            print string
        pass

    pass

pass               