import json
import os
import shutil
import sqlite3
import syslog
import sys
from collections import OrderedDict
import subprocess
import fcntl
import fsio


# needs to be self-sufficient, no dependency on webgui whatsoever (no constants sharing)
import traceback

AUTH_UPDATE_JSON_FILE = '/home/tool/web2py/applications/BS350/config/auth_update/auth_update.json'
AUTH_DB = "/home/tool/config/auth.sq3"
CONSOLE_DEBUG = False

__author__ = 'frank'


class FileSync(object):

    @staticmethod
    def jsonload(filename):
        """Not thread safe"""
        st = os.stat(filename)
        assert(st.st_size > 0), "Read Stat:Empty file"

        with open(filename, 'r') as f:
            try:
                fcntl.lockf(f, fcntl.LOCK_SH)
                data = json.load(f)
            finally:
                fcntl.lockf(f, fcntl.LOCK_UN)
        return data


    @staticmethod
    def jsondump_sorted(filename, data):
        """Not thread safe"""
        with open(filename, 'a') as f:
            try:
                fcntl.lockf(f, fcntl.LOCK_EX)
                f.truncate(0)
                json.dump(data, f, indent=2, sort_keys=True)
                f.flush()
                os.fsync(f.fileno())
            finally:
                fcntl.lockf(f, fcntl.LOCK_UN)
            #os.fsync(f.fileno())

        st = os.stat(filename)
        assert(st.st_size > 0), "Write Stat:Empty file"


class PostUpdate(object):
    def __init__(self):
        self.post_update_file = "/mnt/data/config/postupdate"
        self.lastcfg = None
        if self.hasPostupdateFile():
            self.lastcfg = self.get_lastcfg()

    def hasPostupdateFile(self):
        return os.path.exists(self.post_update_file) and os.path.isfile(self.post_update_file)

    def lastcfg_has_file(self, filename):
        if self.lastcfg:
            lastcfg_file = os.path.join(self.lastcfg, filename)
            return os.path.exists(lastcfg_file) and os.path.isfile(lastcfg_file)
        else:
            return False


    def get_lastcfg(self):
        res = {}
        puf = open(self.post_update_file, 'r')
        puf_data = puf.read()
        puf_data = puf_data.strip()
        lines = puf_data.split("\n")
        for line in lines:
            pair = line.split("=")
            if len(pair) == 2:
                res[pair[0].strip()] = pair[1].strip().replace('"', '')
        return res['lastcfg']

    def copyLastAuth(self):
        try:
            if self.hasPostupdateFile():
                lastcfg = self.get_lastcfg()
                shutil.copy(lastcfg + "/auth.sq3", "/home/tool/config/auth.sq3")
        except:
            a, b, c = sys.exc_info()
            if CONSOLE_DEBUG:
                print "could not copy auth.sq3: " + str(b)
            syslog.syslog(syslog.LOG_ERR, "could not copy auth.sq3: " + str(b))

    def remove_postupdate_file(self):
        if self.hasPostupdateFile():
            os.remove(self.post_update_file)

    def set_security(self):
        try:
            if self.lastcfg_has_file("SecSrv.json"):
                shutil.copy(os.path.join(self.lastcfg, "SecSrv.json"), "/home/tool/config/SecSrv.json")
                sec_srv = json.load(open("/home/tool/config/SecSrv.json", 'r'))
                has_https = sec_srv.get("database").get("https")
                if has_https:
                    subprocess.check_call("cp /etc/init.d/web2py_https.sh /etc/init.d/web2py.sh", shell=True)
                else:
                    subprocess.check_call("cp /etc/init.d/web2py_normal.sh /etc/init.d/web2py.sh", shell=True)
                if CONSOLE_DEBUG:
                    print "set https to '{0}'".format(str(has_https))
                syslog.syslog(syslog.LOG_INFO, "set https to '{0}'".format(str(has_https)))
        except:
            a, b, c = sys.exc_info()
            if CONSOLE_DEBUG:
                print "setting security was not possible: " + str(b)
            syslog.syslog(syslog.LOG_ERR, "setting security was not possible: " + str(b))

    """
    def set_backup_restore_to_off_if_was_off(self):
        try:
            gui_config = FileSync.jsonload("/home/tool/config/guiconfig.json")
            old_gui_config = FileSync.jsonload(self.lastcfg + "/guiconfig.json")
            old_entries = old_gui_config.get('view').get("MainMenu").get('entries')
            entries = gui_config.get('view').get("MainMenu").get('entries')
            old_exchange_entry = None
            for old_entry in old_entries:
                if old_entry.get('state') == "exchange":
                    old_exchange_entry = old_entry
                    break

            # possible cases:
            # no entry with state: "exchange" found.  +++ set new to false!!!
            # entry with state: "exchange" found.
            #     1. no active property at all        --- do nothing
            #     2. active property is false         +++ set new to false!!!
            #     3. active property is true          --- do nothing
            if old_exchange_entry == None:
                self.adjust_exchange_active(entries, gui_config)
            elif old_entry.get('active') == None:
                pass
            elif old_entry.get('active') == False:
                self.adjust_exchange_active(entries, gui_config)
        except:
            exc_str = traceback.format_exc()
            syslog.syslog(syslog.LOG_ERR, "Error on backup restore setting to old negative value: {0}".format(exc_str))
            stack_list = traceback.format_stack()
            for stack_entry in stack_list:
                syslog.syslog(syslog.LOG_ERR, stack_entry)

    def adjust_exchange_active(self, entries, gui_config):

        for entry in entries:
            if entry.get('state') == "exchange":
                entry['active'] = False
                FileSync.jsondump_sorted("/home/tool/config/guiconfig.json", gui_config)
                break
    """

class AuthUpdater(object):
    def __init__(self):
        self.db = sqlite3.connect(AUTH_DB)
        self.DEVELOPER_ID = 1
        self.SERVICE_ID = 2
        self.FCC_ID = 3
        self.LEVEL_4 = 14
        self.LEVEL_5 = 15
        self.group_map = {
          'developer': self.DEVELOPER_ID,
          'service': self.SERVICE_ID,
          'fcc': self.FCC_ID,
          'level_4': self.LEVEL_4,
          'level_5': self.LEVEL_5
        }

    def group_id_map(self, group_str):
        return self.group_map[group_str]

    def create_auth_version_table(self):
        self.db.execute("""CREATE TABLE IF NOT EXISTS auth_version (version str NOT NULL)""")

    def check_auth_version_available(self):
        return self.db.execute("""SELECT count(*) FROM auth_version""").fetchone()[0]

    def has_auth_version(self):
        if self.db.execute("SELECT count(*) FROM auth_version").fetchone()[0] > 0:
            return True
        return False

    def get_auth_version(self):
        rows = self.db.execute("""SELECT * FROM auth_version""")

        return rows.fetchone()[0]

    def update_auth_version(self, new_auth_version):
        count = self.check_auth_version_available()
        if count > 0:
            self.db.execute("""DELETE FROM auth_version""")
        self.db.execute("""INSERT INTO auth_version (version) VALUES ('""" + new_auth_version + """')""")
        return self.get_auth_version()

    def has_permission(self, perm_id):
        #entry.get('perm_id'), entry.get('name'), entry.get('controller')
        return self.db.execute("""SELECT count(*) FROM permission_list
                                  where id = {perm_id}"""
                               .format(perm_id=perm_id)).fetchone()[0] > 0

    def get_admin_groups(self):
        result = self.db.execute("""
            select
              --group_concat(
              ap.group_id
              --)
              FROM auth_permission as ap
                join permission_list as pl
                  on ap.perm_id = pl.id
              where pl.controller = 'PermissionsCtrl' and ap.access = 'w';""").fetchall()
        return sorted(map(lambda el: el[0], result))




    def add_permission(self, id, name, controller):
        self.db.execute("""INSERT INTO "permission_list" (id, name, controller) VALUES({id},'{name}','{controller}')"""
                        .format(id=id, name=name, controller=controller))

    def has_authorization(self, group_id, perm_id):
        return self.db.execute("""SELECT count(*) FROM auth_permission
                                  where perm_id = {perm_id} and group_id = {group_id}"""
                               .format(perm_id=perm_id, group_id=group_id)).fetchone()[0] > 0

    def update_authorization(self, group_id, perm_id, value):
        self.db.execute("""UPDATE auth_permission
                           SET access='{value}'
                           where group_id={group_id} and perm_id={perm_id}"""
                        .format(group_id=group_id, perm_id=perm_id, value=value))

    def add_authorization(self, group_id, my_id, perm_id, type):
        if CONSOLE_DEBUG:
            print "add_authorization group_id=" + str(group_id) + \
                      ", my_id=" + str(my_id) + \
                      ", perm_id=" + str(perm_id) + \
                      ", type=" + str(type)
        syslog.syslog(syslog.LOG_INFO,
                      "add_authorization group_id=" + str(group_id) +
                      ", my_id=" + str(my_id) +
                      ", perm_id=" + str(perm_id) +
                      ", type=" + str(type))
        self.db.execute("""INSERT INTO "auth_permission" (perm_id, id, group_id, name, table_name, record_id, access)
                          VALUES({perm_id},{id},{group_id},NULL,NULL,NULL,'{type}')"""
                        .format(perm_id=perm_id, id=my_id, group_id=group_id, type=type))

    def get_max_id_from_auth_permission(self):
      return self.db.execute("SELECT max(id) FROM auth_permission").fetchone()[0]

    def handle_authorizations(self, perm_id, permissions):
        #offsets = {'developer': 1, 'service': 2, 'level_4': 3, 'level_5': 4}
        if permissions:
            for key, value in permissions.iteritems():
                my_id = self.get_max_id_from_auth_permission()
                # check whether this group has already the permission:
                if self.has_authorization(self.group_id_map(key), perm_id):
                    if CONSOLE_DEBUG:
                        print "update authorization: " + key \
                                  + "; perm_id: " + str(perm_id) \
                                  + "; access: " + value \
                                  + "; id: " + str(my_id + 1)
                    syslog.syslog(syslog.LOG_INFO, "update authorization: " + key
                                  + "; perm_id: " + str(perm_id)
                                  + "; access: " + value
                                  + "; id: " + str(my_id + 1))
                    # if authorization is already available,
                    # we are still able to set the desired authorization ('r', 'w' (special case: 'd')):
                    self.update_authorization(self.group_id_map(key), perm_id, value)
                else:
                    if CONSOLE_DEBUG:
                        print "add authorization: " + key \
                                  + "; perm_id: " + str(perm_id) \
                                  + "; access: " + value \
                                  + "; id: " + str(my_id + 1)
                    syslog.syslog(syslog.LOG_INFO, "add authorization: " + key
                                  + "; perm_id: " + str(perm_id)
                                  + "; access: " + value
                                  + "; id: " + str(my_id + 1))
                    self.add_authorization(self.group_id_map(key), my_id + 1, perm_id, value)
        """else:
            my_id = self.db.execute("SELECT max(id) FROM auth_permission").fetchone()[0]
            self.add_authorization(self.DEVELOPER_ID, my_id + 1, perm_id, 'w')
            self.add_authorization(self.SERVICE_ID, my_id + 2, perm_id, 'w')
            if self.group_available_by_id(self.LEVEL_4):
                self.add_authorization(self.LEVEL_4, my_id + 3, perm_id, 'r')
            self.add_authorization(self.LEVEL_5, my_id + 4, perm_id, 'w')"""

    def group_available_by_id(self, myid):
        if self.db.execute("SELECT * from auth_group WHERE id = {myid}".format(myid=myid)).rowcount > 0:
            return True
        return False

    def sort_keys(self, auth_data):
        groups_order = ["developer", "service", "fcc", "level_4", "level_5"]
        auth_order = ["controller", "perm_id", "name", "permissions"]
        result = []
        for auth in auth_data:
            if auth.get('permissions'):
                auth["permissions"] = OrderedDict(
                    sorted(auth.get("permissions").iteritems(), key=lambda (k, v): groups_order.index(k)))
                auth = OrderedDict(sorted(auth.iteritems(), key=lambda (k, v): auth_order.index(k)))
            result.append(auth)
        return result

    def sort_root_level_keys(self, data):
        key_order = ['auth_version', 'auths', 'sqlscript']
        return OrderedDict(sorted(data.iteritems(), key=lambda (k, v): key_order.index(k)))

    def init_auth(self, data):
        try:
            auth_data = data.get("auths")
            try:
                content = data.get("sqlscript")
                for c in content:
                    try:
                        self.db.executescript(c)
                        if CONSOLE_DEBUG:
                            print "auth_update: sqlscript: {sqlline}".format(sqlline=c)
                        syslog.syslog(syslog.LOG_INFO, "auth_update: sqlscript: {sqlline}"
                                      .format(sqlline=c))
                    except:
                        exc_type, exc_value, exc_tb = sys.exc_info()
                        if CONSOLE_DEBUG:
                            print "init_auth could not execute sql statement: {error_text}".format(error_text=exc_value)
                            print "sql statement: {sqlline}".format(sqlline=c)
                        syslog.syslog(syslog.LOG_ERR, "init_auth could not execute sql statement: {error_text}"
                                      .format(error_text=exc_value))
                        syslog.syslog(syslog.LOG_ERR, "sql statement: {sqlline}".format(sqlline=c))

            except:
                exc_type, exc_value, exc_tb = sys.exc_info()
                if CONSOLE_DEBUG:
                    print "init_auth could not get sqlscript content: {error_text}".format(error_text=exc_value)
                syslog.syslog(syslog.LOG_ERR, "init_auth could not get sqlscript content: {error_text}"
                              .format(error_text=exc_value))
                # we do not propagate Exception, because we are trying to evaluate
                # all available sql statements no matter what ...
                #raise Exception("execute sql script failed, propagate exception")

            # schema changes are now committed

            # old permissions should _never_ be deleted to keep downwards compatibility
            result = self.sort_keys(auth_data)

            group_ids = self.get_admin_groups()

            for entry in result:
                if CONSOLE_DEBUG:
                    print "auth db trying to add controller: " + \
                              entry.get('controller') + "; " + \
                              entry.get('name') + "; " + \
                              str(entry.get('perm_id'))
                syslog.syslog(syslog.LOG_INFO, "auth db trying to add controller: " +
                              entry.get('controller') + "; " +
                              entry.get('name') + "; " +
                              str(entry.get('perm_id')))
                my_group_ids = []
                if 'groups' in entry:
                    groups = entry.get('groups')
                    for g in groups:
                        my_group_ids.append(self.group_id_map(g))
                if not self.has_permission(entry.get('perm_id')):
                    self.add_permission(entry.get('perm_id'), entry.get('name'), entry.get('controller'))
                    # we only add authorizations to new permissions:
                    #self.handle_authorizations(entry.get('perm_id'), entry.get('permissions'))
                    if len(my_group_ids) < 1:
                        my_group_ids = group_ids
                    for group_id in my_group_ids:
                        my_id = self.get_max_id_from_auth_permission()
                        self.add_authorization(
                            group_id=group_id,
                            my_id=my_id+1,
                            perm_id=entry.get('perm_id'),
                            type='w'
                        )

            self.db.commit()
            if CONSOLE_DEBUG:
                print "auth db added controller(s) committed"
            syslog.syslog(syslog.LOG_INFO, "auth db added controller(s) committed")

        except:
            exc_type, exc_value, exc_tb = sys.exc_info()
            #print traceback.format_exc()
            if CONSOLE_DEBUG:
                print "init_auth could not update auth db: {error_text}".format(error_text=exc_value)
            syslog.syslog(syslog.LOG_ERR, "init_auth could not update auth db: {error_text}"
                          .format(error_text=exc_value))
            #syslog.syslog(syslog.LOG_ERR, "init_auth could not update auth db: {error_text}".format(error_text=traceback.format_exc()))
        finally:
            self.db.rollback()


if __name__ == "__main__":
    if CONSOLE_DEBUG:
        print "STARTING init_auth"
    try:
        postUpdate = PostUpdate()
        if postUpdate.hasPostupdateFile():
            #postUpdate.set_backup_restore_to_off_if_was_off()
            postUpdate.copyLastAuth()
            postUpdate.set_security()
            postUpdate.remove_postupdate_file()
            if os.path.isfile(AUTH_UPDATE_JSON_FILE):
                data = json.load(open(AUTH_UPDATE_JSON_FILE))
                authUpdater = AuthUpdater()
                authUpdater.init_auth(data)
    except:
        a, b, c = sys.exc_info()
        if CONSOLE_DEBUG:
            print str(b)
        syslog.syslog(syslog.LOG_ERR, str(b))

