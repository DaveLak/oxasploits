# -*- coding: cp1252 -*-
'''
Created on 07.02.2012

@author: sth2mt
'''
import time
from struct import unpack

class Treiber(object):
    '''
    classdocs
    '''
    # Achtung dies ist Pseudo Singleton -> variablen werden statisch verwendet. Aufgeraumt wird erst wenn alle instanzen weg sindwird nur einmal instaniiert !!!!
    ObjCount = 0
    _Thread_name = "BedienTasten"
    stout = False
    fEventSwitch = None
    KEY_PRESSED = 2
    KEY_PRESS = 1
    KEY_RELEASED = 0
    EV_KEY = 1
    KEY_A = 30
    KEY_LEFT = 105
    KEY_RIGHT = 106      
    
    
    
    def __init__(self):
        '''
        Constructor
        '''
        Treiber.ObjCount += 1
        self.printf("%i.Construktor %s Anzahl" % (Treiber.ObjCount,Treiber._Thread_name))
        
        self.Open()
        
            
    def __del__(self):
        
        '''
        Destructor
        '''
        self.printf("%i Destruktor %s" % (Treiber.ObjCount,Treiber._Thread_name))
            
        if Treiber.ObjCount == 1:
            self.printf("Reste aufraumen")
            if not Treiber.fEventSwitch.closed:
                Treiber.fEventSwitch.close()
                Treiber.fEventSwitch = None

        if Treiber.ObjCount > 0:
            Treiber.ObjCount -= 1
            
        pass


    def Open(self):
        if (Treiber.fEventSwitch==None):
            Treiber.fEventSwitch = open("/dev/input/event0","rb",0);
        
        pass

    
    def ReadTasten(self):
        if Treiber.fEventSwitch.closed:
            self.printf("BedienTasten.ReadTasten() closed\n")
            self.Open()
            
        # einlesen
        try:
        # Lesen iAnzahl Byte
            iOffset=0
            iAnzahl = 16
            #self.fEventSwitch.seek(iOffset)
            s_string=Treiber.fEventSwitch.read(iAnzahl)
            
            self.printf("BedienTasten.ReadTasten()=\n")
            sAnzeige=""
            #for char in s_string:
            #    sAnzeige = sAnzeige + ",0x%X" % ord(char)
            #self.printf(sAnzeige)
                
                
            return s_string
        except IOError,e:
            print "BedienTasten.ReadTasten(iOffset=%i,Anzahl=%i) %s" %(iOffset,iAnzahl, e)
            return None
        pass   


    def GetTaste(self):
        taste = 0
        zustand = 0
        for i in range (0,3,1):
            Tastenscan=self.ReadTasten()
            sec,usec,typ,code,value = unpack("IIHHi",Tastenscan)
            self.printf("sec=%i,usec=%i,type=%i,code=%i,value=%i"%(sec,usec,typ,code,value))
            if typ == 0:
                break
            if typ == Treiber.EV_KEY:
                if (value == Treiber.KEY_PRESS) | (value == Treiber.KEY_PRESSED) | (value == Treiber.KEY_RELEASED):
                    if code == 30: # KEY_A
                        self.printf("KEY_A")
                        taste = code
                        zustand = value
                    elif code == 105: # KEY_LEFT
                        self.printf("KEY_LEFT")
                        zustand = value
                        taste = code
                    elif code == 106: # KEY_RIGHT
                        self.printf("KEY_RIGHT")
                        zustand = value
                        taste = code
                    else:
                        self.printf("?")
                         
        return taste,zustand        

    def Dummyfunction(self):
        return True
            
    def Wait(self, Tastencode, mode=None, function=None):
        if function == None:
            function = self.Dummyfunction()
        #print function
        #while ( (not function()) & (not self.GetZustand(sTastenAuswahl)) ):
        while 1:
            Taste,Zustand=self.GetTaste()
            if (Taste & Tastencode)==Taste:
                self.printf("Wait Ende Taste=%i, Zustand=%i"%(Taste,Zustand))
                if mode == None:
                    return Taste
                elif mode == Zustand :
                    return Taste
            self.printf("wait")
            #time.sleep(0.01)
        return False

    

    def printf(self,string):
        if Treiber.stout:
            print string
        pass
        