/*global Ext: false, TR: false, window: false, setTimeout: false, BS350: false */

Ext.define('BS350.controller.WlanCtrl', {
  extend: 'BS350.custom.ViewController',
  views: ['WlanView', 'BS350.custom.CertView'],
  stores: [ 'WlanSsidStore', 'WlanChannelStore' ],
  items: [
    { name: 'wlan', query: '#wlanviewId' },
    { name: 'wlanform', query: '#wlanform', actions: { dirtychange: 'updateButtons' } },
    { name: 'hardware', query: '#hardware' },
    { name: 'interface', query: '#interface' },
    { name: 'debug', query: '#debug' },
    { name: 'band', query: '#band', actions: { change: 'bandChanged', select: 'selChannel'} },
    { name: 'rdomain', query: '#rdomain', actions: { select: 'selChannel'} },
    //{ name: '802-11-h', query: '#802-11-h' },
    { name: 'sec_method', query: '#sec_method', actions: { change: 'updateSecMethod' } },
    { name: 'auth', query: '#auth', actions: { change: 'updateAuthMethod' } },
    //{ name: 'power-mode', query: '#power-mode', actions: { change: 'updatePowerMode' } },
    { name: 'ipMethod', query: '#method', actions: { change: 'updateIpMethod' } },
/*    { name: 'show_passphrase', query: '#show_passphrase', actions: { click: 'togglePassphrase' } },
    { name: 'passphrase_pw', query: '#passphrase_pw', actions: { change: 'passphrase_pwChanged' } },
    { name: 'passphrase', query: '#passphrase', actions: { change: 'passphraseChanged' } }, */
    //{ name: 'ssid', query: '#ssid', actions: { change: 'connectionChanged' } },
    { name: 'bssid', query: '#bssid' },
    { name: 'saveBtn', query: '#btnSave', actions: { click: 'save' } },
    { name: 'discardBtn', query: '#btnDiscard', actions: { click: 'discardData' } },
    { name: 'restartBtn', query: '#btnRestart', actions: { click: 'restart' } },
    { name: 'resetBtn', query: '#btnReset', actions: { click: 'resetToFactory' } },
    { name: 'ipadr', query: '#ipadr', actions: { blur: 'resetOnInvalid' } },
    { name: 'netmask', query: '#netmask', actions: { blur: 'resetOnInvalid' } },
    { name: 'gateway', query: '#gateway', actions: { blur: 'resetOnInvalid' } },
    { name: 'dns', query: '#dns', actions: { blur: 'resetOnInvalid' } },
    { name: 'uploadCaCertBtn', query: '#uploadCaCertBtn', actions: { click: 'uploadCaCert' } },
    { name: 'uploadClientCertBtn', query: '#uploadClientCertBtn', actions: { click: 'uploadClientCert' } },
    { name: 'uploadPrivateKeyBtn', query: '#uploadPrivateKeyBtn', actions: { click: 'uploadPrivateKey' } },
    { name: 'p12_cert_fid', query: '#p12_cert_fid', actions: {click: 'uploadP12Cert'} },
    { name: 'uploadP12CertAddBtn', query: '#uploadP12CertAddBtn', actions: {click: 'uploadP12CertAdd'} },
    { name: 'ca_cert', query: '#ca_cert' },
    { name: 'client_cert', query: '#client_cert' },
    { name: 'private_key', query: '#private_key' },
    { name: 'root_cert_cert', query: '#root_cert_cert' },
    { name: 'client_cert_cert', query: '#client_cert_cert' },
    { name: 'private_key_cert', query: '#private_key_cert' },
    { name: 'private_key_passwd', query: '#private_key_passwd' },
    { name: 'private_key_passwd_pw', query: '#private_key_passwd_pw' },
    { name: 'p12_cert', query: '#p12_cert' },
    { name: 'p12_cert_add', query: '#p12_cert_add' },
    { name: 'msg_lbl_bbar', query: '#msg_lbl_bbar' },
    { name: 'chconfig', query: '#chconfig' },
    { name: 'list_bg', query: '#list_bg' }, //, dirtychange: 'updateButtons' },
    { name: 'etsi_list_a', query: '#etsi_list_a'}, // dirtychange: 'updateButtons' },
    { name: 'fcc_list_a', query: '#fcc_list_a' }, //dirtychange: 'updateButtons' }
    { name: 'channellist', query: '#channellist' },
    { name: 'tkip', query: '#tkip' }

  ],

  channelFilter: {'ETSI': [149,153,157,161,165], 'FCC': [12,13,120,124,128], 'CAN': [12,13,120,124,128], 'BRA': [12,13,120,124,128],
                  'CHN': [100,104,108,112,116,120,124,128,132,136,140], 'IND': [100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165],
                  'AUS-NZL': [100,104,108,112,116,120,124,128,132,136,140], 'ZAF': [149,153,157,161,165], 'THA': [], 'KOR': [132,136,140], 'MYS': [], 'ARG': []},
  wifiStdRevert: {'802.11b/g': [36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165] ,'802.11a': [1,2,3,4,5,6,7,8,9,10,11,12,13], '802.11a/g':[]},


  initView: function () {
    var me = this;

    me.V.debug.setVisible(false);

    if (me.access === 'r') {
      Ext.each(Ext.ComponentQuery.query('textfield, combobox, checkbox, numberfield', this.view), function (e) { e.setReadOnly(true); });
      //me.V['ssid-list'].plugins[0].on('beforeedit', function () { return false; });
      //me.V['channel-list'].plugins[0].on('beforeedit', function () { return false; });
      Ext.each(Ext.ComponentQuery.query('toolbar', this.view), function (e) { e.hide(); });
    }
    if(me.access === 'd'){
      me.V.debug.setVisible(true);
    }
    me.view.getEl().mask(TR("Loading..."));

    me.updateData('initViewCompleted');
    me.initChannelCfg();

   /* me.V.wlanform.form.on('dirtychange', function () {
      me.updateButtons();
    });*/
    me.V.wlanform.form.on('validitychange', function () {
      me.updateButtons();
    });
  },

  initChannelCfg: function () {
    var me = this;
    me.V.list_bg.hide();
    me.V.etsi_list_a.hide();
    me.V.fcc_list_a.hide();
  },

  showAllChannels: function () {
    this.V.channellist.cascade(function(currBox){
         currBox.show();});
  },

  selChannel: function () {
    var me = this;
    var band = me.V.band.getValue();
    var rdomain = me.V.rdomain.getValue();
    me.showAllChannels();
    var i;
    for (i=0; i < me.channelFilter[rdomain].length; i++){
       me.V.channellist.getComponent(me.channelFilter[rdomain][i]).hide();
    }
    for (i= 0; i < me.wifiStdRevert[band].length;i++){
       me.V.channellist.getComponent(me.wifiStdRevert[band][i]).hide();
    }
    me.V.channellist.setFieldLabel(TR('Active roaming channels '+band));
    me.checkAll(me.V.channellist);
  },

  updateChannelVisibility: function () {
    var me = this;
    var band = me.V.band.getValue();
    var rdomain = me.V.rdomain.getValue();
    me.showAllChannels();
    var i;
    for (i=0; i < me.channelFilter[rdomain].length; i++){
       me.V.channellist.getComponent(me.channelFilter[rdomain][i]).hide();
    }
    for (i= 0; i < me.wifiStdRevert[band].length;i++){
       me.V.channellist.getComponent(me.wifiStdRevert[band][i]).hide();
    }
    me.V.channellist.setFieldLabel(TR('Active roaming channels '+band));
  },

  checkAll: function(checkGroup){
     checkGroup.cascade(function(currBox){
         if(currBox.isHidden() === false){
           currBox.setValue(true);
         }});
  },

  uncheckAll:function(checkGroup){
     checkGroup.cascade(function(currBox){
         currBox.setValue(false)});
  },

  updateCertDir: function (certFiles) {
    var i = 0;
    var me = this;
    Ext.Ajax.request({
      url: '/BS350/wlan/cleanDirReq',
      params: {cert: certFiles},

      success: function (res) {
          if (res.responseText !== "0") {
            me.V.msg_lbl_bbar.setText(TR("Failed to update cert directory"));
          }
        },
      failure: function (res) {
        me.V.msg_lbl_bbar.setText(TR("Failed to update cert directory"));
      }
    });
  },

  discardData: function (fire) {
    var me = this;
    me.view.getEl().mask(TR("Discarding..."));
    me.updateData(fire);
  },

  updateData: function (fire) {

    var me = this;

    Ext.Ajax.request({
      url: '/BS350/wlan/cfg',
      success: function (res) {
        var data = Ext.JSON.decode(res.responseText);
        me.data = data;
        data.sec_method = data.connections[0].security.method;
        delete data.connections[0].security.method;
        me.updateChannelConfig(data);
        me.V.wlanform.form.setValues(data);
        me.setChannelValues(data);
        me.updateChannelVisibility();
        me.V.wlanform.form.setValues(data.connections[0].ip);
        me.V.wlanform.form.setValues(data.connections[0].roaming);
        me.V.wlanform.form.setValues(data.connections[0].security);
        me.V.wlanform.form.setValues(data.connections[0].wlan);
        me.V.wlanform.form.setValues(data.connections[0].roaming.scan);
        me.V.wlanform.form.setValues({passphrase_pw: data.connections[0].security.passphrase});
        me.V.wlanform.form.setValues({passphrase: data.connections[0].security.passphrase});
        me.V.wlanform.form.setValues({password: data.connections[0].security.password});
        me.V.wlanform.form.setValues({password_pw: data.connections[0].security.password});
        me.V.wlanform.form.setValues({private_key_passwd: data.connections[0].security.private_key_passwd});
        me.V.wlanform.form.setValues({private_key_passwd_pw: data.connections[0].security.private_key_passwd});
        me.view.getEl().unmask();
        var c = data.connections[0];
        me.updateCertDir([c.security.ca_cert, c.security.client_cert, c.security.private_key]);
        if (fire === 'initViewCompleted') {
          me.fireEvent(fire);
        }
        me.V.wlanform.form.setValues(me.V.wlanform.form.getValues());
        //some actions above trigger dirty
        me.updateButtons();
      },
      failure: function(){

      }
    });
  },

    setChannelValues: function (data) {
        var values = [];

        if (data['band'] === "802.11a") {
            values = data.connections[0].roaming['channel-list-a'];
        }
        else if (data['band'] === "802.11b/g") {
            values = data.connections[0].roaming['channel-list-bg'];
        }
        else if (data['band'] === "802.11a/g") {
            values = values.concat(data.connections[0].roaming['channel-list-bg'],
                                   data.connections[0].roaming['channel-list-a']);
        }
        this.V.wlanform.form.setValues({ch_all: values});
    },

  setCheckBox: function(data, checkbox, name){
    //var me = this;
    var list = data.connections[0].roaming[name];
    if (list === undefined) {
      // should only be called if no previous setting available:
      checkbox.cascade(function(currBox){
        currBox.setValue(true);
      });
    } else {
      for(var i = 0; i < list.length; i++) {
          checkbox.cascade(function(currBox){
            if(currBox.boxLabel === list[i]) {
               currBox.setValue(true);

            }
          });
      }
    }
  },
  updateBoxDirty: function(){
    var me = this;

    /*for (var i = 0; i < me.V.channellist.items.items.length; i++) {
      if (me.V.list_bg.items.items[i].isDirty()) {
        me.V.list_bg.items.items[i].setValue(me.V.list_bg.items.items[i].getValue());
      }
    }*/
    me.V.channellist.setValue(me.V.channellist.getValue());

  },

  updateChannelConfig: function(data){
    var me = this;
    me.uncheckAll(me.V.channellist);
    if (data['band'] === "802.11a/g" || data['band'] === "802.11a") {
      me.setCheckBox(data, me.V.channellist, 'channel-list-a');
    }
    if (data['band'] === "802.11b/g" || data['band'] === "802.11a/g") {
      me.setCheckBox(data, me.V.channellist, 'channel-list-bg');
    }
    me.updateBoxDirty();
  },

  updateSecMethod: function (arg) {
    var me = this;
    var secVisibility = function (objArg) {
      if (objArg === undefined) {
        objArg = {};
        me.view.down('#tkip').setVisible (false);
      } else {
        me.view.down('#tkip').setVisible (true);
      }
      var stdPrps = {
        encryption: false,
        passphrase: false,
        auth: false,
        ca_cert: false,
        username: false,
        password: false,
        anonymous_identity: false,
        client_cert: false,
        private_key: false,
        private_key_passwd: false,
        p12_cert_fid: false
      };
      var attrname;
      for (attrname in objArg) {
        if (objArg.hasOwnProperty(attrname)) {
          stdPrps[attrname] = objArg[attrname];
        }
      }
      me.view.down('#encryption').setVisible(objArg.encryption);
      me.view.down('#passphrase_container').setVisible(objArg.passphrase);
      me.view.down('#auth').setVisible(objArg.auth);
      me.view.down('#root_cert_cert').setVisible(objArg.ca_cert);
      me.view.down('#username').setVisible(objArg.username);
      me.view.down('#password_container').setVisible(objArg.password);
      me.view.down('#anonymous_identity').setVisible(objArg.anonymous_identity);
      me.view.down('#client_cert_cert').setVisible(objArg.client_cert);
      me.view.down('#private_key_cert').setVisible(objArg.private_key);
      me.view.down('#private_key_passwd_container').setVisible(objArg.private_key_passwd);
      me.view.down('#p12_cert_fid_container').setVisible(objArg.p12_cert_fid);
    };
    switch (arg.getValue()) {
    case 'Open-Network':
      secVisibility();
      break;
    case 'WPA/WPA2-Personal':
      secVisibility({ passphrase: true });
      break;
    case 'WPA/WPA2-Enterprise':
      secVisibility({ auth: true, ca_cert: true, username: true, password: true, p12_cert_fid: true });
      break;
    /*case 'WPA2-Personal':
      secVisibility({ encryption: true, passphrase: true });
      break;*/
    }
    me.updateAuthMethod(me.V.auth);
  },
  updateAuthMethod: function (arg) {
    var me = this;
    var NONE = -1;
    var EAP_TLS = 13;
    var EAP_TTLS = 21;
    var PEAP = 25;
    var authVisibility = function (objArg) {
      if (objArg === undefined) { objArg = {}; }
      var stdPrps = {
        username: false,
        password: false,
        anonymous_identity: false,
        ca_cert: false,
        client_cert: false,
        private_key: false,
        private_key_passwd: false,
        p12_cert_fid: false
      };
      var attrname;
      for (attrname in objArg) {
        if (objArg.hasOwnProperty(attrname)) {
          stdPrps[attrname] = objArg[attrname];
        }
      }
      me.view.down('#username').setVisible(stdPrps.username);
      me.view.down('#password_container').setVisible(stdPrps.password);
      me.view.down('#anonymous_identity').setVisible(stdPrps.anonymous_identity);
      me.view.down('#root_cert_cert').setVisible(stdPrps.ca_cert);
      me.view.down('#client_cert_cert').setVisible(stdPrps.client_cert);
      me.view.down('#private_key_cert').setVisible(stdPrps.private_key);
      me.view.down('#private_key_passwd_container').setVisible(stdPrps.private_key_passwd);
      me.view.down('#p12_cert_fid_container').setVisible(stdPrps.p12_cert_fid);
    };
    if (me.view.down('#auth').isVisible()) {
      switch (arg.getValue()) {
      case NONE:
        authVisibility();
        break;
      case PEAP:
        authVisibility({ username: true, password: true, anonymous_identity: true, ca_cert: true });
        break;
      case EAP_TLS:
        authVisibility({ username: true, ca_cert: true, client_cert: true, private_key: true, private_key_passwd: true, p12_cert_fid: true });
        break;
      case EAP_TTLS:
        authVisibility({ username: true, password: true, anonymous_identity: true, ca_cert: true });
        break;
      }
    } else {
      authVisibility();
    }
  },
 /* updatePowerMode: function (arg) {
    var me = this;
    var pmVisibility = function (objArg) {
      if (objArg === undefined) { objArg = {}; }
      var stdPrps = { 'doze-mode': false, 'power-level': false, 'power-level-default': false };
      var attrname;
      for (attrname in objArg) {
        if (objArg.hasOwnProperty(attrname)) {
          stdPrps[attrname] = objArg[attrname];
        }
      }
      me.view.down('#doze-mode').setVisible(objArg['doze-mode']);
      me.view.down('#power-level').setVisible(objArg['power-level']);
      me.view.down('#power-level-default').setVisible(objArg['power-level-default']);
    };
    switch (arg.getValue()) {
    case 0:
      pmVisibility({ 'doze-mode': true, 'power-level': true, 'power-level-default': true });
      break;
    case 1:
      pmVisibility();
      break;
    case 2:
      pmVisibility({ 'power-level': true, 'power-level-default': true });
      break;
    case 3:
      pmVisibility({ 'power-level': true, 'power-level-default': true });
      break;
    }
  },*/

  updateIpMethod: function (arg) {
    var me = this;
    var ipVisibility = function (objArg) {
      if (objArg === undefined) { objArg = {}; }
      var stdPrps = { 'ipadr': false, 'subnet': false, 'gateway': false, 'dns': false, 'garp': false };
      var attrname;
      for (attrname in objArg) {
        if (objArg.hasOwnProperty(attrname)) {
          stdPrps[attrname] = objArg[attrname];
        }
      }
      me.view.down('#ipadr').setVisible(objArg.ipadr);
      me.view.down('#subnet').setVisible(objArg.subnet);
      me.view.down('#gateway').setVisible(objArg.gateway);
      me.view.down('#dns').setVisible(objArg.dns);
      me.view.down('#garp').setVisible(objArg.garp);
    };
    switch (arg.getValue()) {
    case 'dhcp':
      ipVisibility({ 'ipadr': false, 'subnet': false, 'gateway': false, 'dns': false, 'garp': true  });
      break;
    case 'man':
      ipVisibility({ 'ipadr': true, 'subnet': true, 'gateway': true, 'dns': true, 'garp': true });
      break;
    }
  },
  togglePassphrase: function () {
    var me = this;

    var vis = me.view.down('#passphrase_pw').isVisible();
    me.view.down('#passphrase').setVisible(vis);
    me.view.down('#passphrase_pw').setVisible(!vis);
    me.view.down('#show_passphrase').setText(vis ? TR('hide') : TR('show'));
  },
  updateButtons: function () {
    var me = this;
    var valid = this.V.wlanform.form.isValid();
    var dirty = this.V.wlanform.form.isDirty() || me.V.list_bg.isDirty() || me.V.etsi_list_a.isDirty() || me.V.fcc_list_a.isDirty();
    var active = me.data['interface'];

    var notSaveable = !dirty || !valid;
    this.V.saveBtn.setDisabled(notSaveable);
    //this.V.p12_cert_fid.setDisabled(!notSaveable);
    this.V.discardBtn.setDisabled(!dirty);
    this.V.restartBtn.setDisabled((dirty || !valid) || !active);
  },

    formatChannelData: function () {
        var me = this;
        var list_a = [],
            list_bg = [],
            channel = {};

        var arr = me.V.channellist.getChecked();
        var s=this.wifiStdRevert;

        /* inverse logic because wifiStdRevert lists contain excluded channels! */
        Ext.Array.forEach(arr, function (el) {
            var val = el.inputValue;

            if (Ext.Array.contains(s["802.11a"], val)) {
                list_bg.push(val);
            }else if (Ext.Array.contains(s["802.11b/g"], val)) {
                list_a.push(val);
            }
        });

        if (list_a.length) {
            channel["channel-list-a"] = list_a;
        }
        if (list_bg.length) {
            channel["channel-list-bg"] = list_bg;
        }

        return channel;
    },

  restart: function(button, event, eOpts) {

    var me = this;

    var headertoolbar = Ext.ComponentQuery.query("#headertoolbar")[0];
    headertoolbar.setDisabled(true);
    me.view.getEl().mask(TR("Restarting..."));

    Ext.Ajax.request({
      url: '/BS350/wlan/restartWlan',
      method: 'GET',
      //params: {data: Ext.JSON.encode(data), cert: certFiles},

      success: function (response) {
        if (response.responseText === "0") {
          if (eOpts.callback) { eOpts.callback(); } else {
            if (Ext.isIE && me.V['interface'].getValue()) {
              setTimeout(function () { me.updateData(); }, 2000);
            } else {
              me.updateData();
            }
          }
          me.V.msg_lbl_bbar.setText(TR("Successfully restarted Wlan"));
          var fadeOut = new Ext.util.DelayedTask(function () {
            me.V.msg_lbl_bbar.setText("");
          });
          fadeOut.delay(7000);
        } else {
          if (response.responseText === "1") {
            me.V.msg_lbl_bbar.setText(TR("Wlan restart already in progress. Can not start. Wait till ready."));
          } else {
            me.V.msg_lbl_bbar.setText(TR("Wlan restart exited with errorcode") + ": " + response.responseText);
          }
          // do not use the callback to close the panel, we need to show the error message:
          me.updateData();
        }
        me.getController('NavigationCtrl').updateActives();
        /* var fcctestmodeview = Ext.ComponentQuery.query('fcctestmodeview');
          if (fcctestmodeview.length > 0) {
            fcctestmodeview = fcctestmodeview[0];
            var fccTestModeForm = fcctestmodeview.down('#fccTestModeForm');
            fccTestModeForm.form.setValues({'fcc-test-mode': false });
          }*/
        headertoolbar.setDisabled(false);
        me.view.getEl().unmask();
        me.V.restartBtn.setDisabled(false);
      },
      failure: function (res) {
        headertoolbar.setDisabled(false);
        me.view.getEl().unmask(); // updateData sets loading to true again.
        me.V.msg_lbl_bbar.setText(TR("Wlan restart failed"));
        me.updateData();
        me.V.restartBtn.setDisabled(false);
      }
    });
    me.V.saveBtn.setDisabled(true);
    me.V.discardBtn.setDisabled(true);
    me.V.restartBtn.setDisabled(true);

  },

  save: function (button, event, eOpts) {
    var me = this;
    var i;

    var headertoolbar = Ext.ComponentQuery.query("#headertoolbar")[0];
    headertoolbar.setDisabled(true);
    me.view.getEl().mask(TR("Saving..."));

    var fdata = this.V.wlanform.form.getFieldValues();
    var channel = me.formatChannelData();
    for (var k in channel) {
      if (channel.hasOwnProperty(k)) {
        fdata[k] = channel[k];
      }
    }

    var root = this.data;
    var root_props = ['debug', 'power-level-default', 'power-level', 'power-mode', 'band', 'doze-mode', 'interface', 'regulatory-domain'];  // CR 11159 '802-11-h' removed
    var connections_ip = ['subnet', 'ipadr', 'method', 'dns', 'gateway', 'garp', 'hostname'];
    var connections_security = [ 'tkip', 'ca_cert', 'client_cert', 'private_key', "private_key_passwd", 'anonymous_identity', 'username', 'password', 'encryption', 'auth', 'passphrase', 'method'];
    var connections_wlan = ['ssid', 'bssid'];
    var connections_roaming = ['lowpass-filter', 'low-quality-for-backround-scan', 'normal-quality-for-backround-scan', 'active', 'low-snr-threshold',
      'quality-indicator', 'low-rssi-threshold', 'data-retry-threshold', 'num-expected-tbtt-for-bss-loss', 'tx-rate-threshold', 'channel-list-bg', 'channel-list-a'];
    //var connections_roaming_scan = ['rssi', 'snr'];
    for (i in root_props) {
      if (root_props.hasOwnProperty(i)) {
        root[root_props[i]] = fdata[root_props[i]];
      }
    }
    var connections = this.data.connections;
    connections[0] = {ip: {}, security: {}, wlan: {}, roaming: {} };
    var c = connections[0];

    for (i in connections_ip) {
      if (connections_ip.hasOwnProperty(i)) {
        c.ip[connections_ip[i]] = fdata[connections_ip[i]];
      }
    }
    for (i in connections_security) {
      if (connections_security.hasOwnProperty(i)) {
        c.security[connections_security[i]] = fdata[connections_security[i]];
      }
    }
    c.security.method = fdata.sec_method;
    for (i in connections_wlan) {
      if (connections_wlan.hasOwnProperty(i)) {
        c.wlan[connections_wlan[i]] = fdata[connections_wlan[i]];
      }
    }
    for (i in connections_roaming) {
      if (connections_roaming.hasOwnProperty(i)) {
        c.roaming[connections_roaming[i]] = fdata[connections_roaming[i]];
      }
    }
    var certFiles = [c.security.ca_cert, c.security.client_cert, c.security.private_key];
    var data = { connections: connections };
    var an;
    for (an in root) {
      if (root.hasOwnProperty(an)) {
        data[an] = root[an];
      }
    }
    delete data.sec_method;

    me.V.saveBtn.setDisabled(true);
    Ext.Ajax.request({
      url: '/BS350/wlan/cfg',
      method: 'POST',
      params: {data: Ext.JSON.encode(data), cert: certFiles},

      success: function (response) {
        if (response.responseText === "0") {
          if (eOpts.callback) { eOpts.callback(); } else {
            if (Ext.isIE && me.V['interface'].getValue()) {
              setTimeout(function () { me.updateData(); }, 2000);
            } else {
              me.updateData();
            }
          }
          me.V.msg_lbl_bbar.setText(TR("Successfully restarted Wlan"));
          var fadeOut = new Ext.util.DelayedTask(function () {
            me.V.msg_lbl_bbar.setText("");
          });
          fadeOut.delay(7000);
        } else {
          me.V.msg_lbl_bbar.setText(TR("Wlan restart exited with errorcode") + ": " + response.responseText);
          // do not use the callback to close the panel, we need to show the error message:
          me.updateData();
        }
        me.getController('NavigationCtrl').updateActives();
        /* var fcctestmodeview = Ext.ComponentQuery.query('fcctestmodeview');
          if (fcctestmodeview.length > 0) {
            fcctestmodeview = fcctestmodeview[0];
            var fccTestModeForm = fcctestmodeview.down('#fccTestModeForm');
            fccTestModeForm.form.setValues({'fcc-test-mode': false });
          }*/
        headertoolbar.setDisabled(false);
        me.view.getEl().unmask();
      },
      failure: function (res) {
        headertoolbar.setDisabled(false);
        me.view.getEl().unmask(); // updateData sets loading to true again.
        me.V.msg_lbl_bbar.setText(TR("Wlan restart failed"));
        me.updateData();
      }
    });
    me.V.saveBtn.setDisabled(true);
    me.V.discardBtn.setDisabled(true);
  },
  connectionChanged: function () {},
  resetToFactory: function () {
    var me = this;
    var reset = function () {
      me.view.getEl().mask(TR("Resetting..."));
      Ext.Ajax.request({
        url: '/BS350/wlan/resetToFactory',
        success: function (res) {
          me.updateData();
          me.getController('NavigationCtrl').updateActives();
        }
      });
    };
    me.V.saveBtn.setDisabled(true);
    me.V.discardBtn.setDisabled(true);

    var title = TR('Reset to factory');
    var msg = TR('Do you want to discard the current configuration and reset to factory? All relevant configuration files are to be overwritten.');
    BS350.custom.Utils.showResetToFactoryConfirmation(reset, title, msg);
  },
  resetOnInvalid: function (element, event, c) {
    if (!element.isValid()) {
      element.setValue(element.originalValue);
      element.sync();
    }
  },
  bandChanged: function (combo, value) {
    var me = this;
    var h_band_str = '802.11a';
    var h_band_visible = me.V.band.getValue().slice(0, h_band_str.length) === h_band_str;
    /*if (!h_band_visible) {
      me.V['802-11-h'].setValue(false);
    }
    me.V['802-11-h'].setVisible(h_band_visible);*/
    me.updateButtons();
  },

  initUploadWin: function (uploadFunction, cancelFunction, reg_exp, validation_msg) {
    if (reg_exp === undefined) {
      reg_exp = /(\.pem)|(\.der)$/g
    }
    if (validation_msg === undefined) {
      validation_msg = TR('File must be a .pem or .der');
    }
    // Add windows elements
    this.V.uploadForm = this.V.uploadWin.down('#uploadForm');
    this.V.uploadForm.addListener('beforeaction', this.startUploading, this);
    this.V.uploadForm.addListener('actioncomplete', this.finishUploading, this);

    this.V.uploadBtn = this.V.uploadWin.down('#uploadBtn');
    this.V.cancelBtn = this.V.uploadWin.down('#cancelBtn');
    this.V.cancelBtn.addListener('click', function () { this.V.uploadWin.close(); }, this);

    this.V.updateProgress = this.V.uploadWin.down('#updateProgress');
    this.V.progressLabel = this.V.uploadWin.down('#progressLbl');
    this.V.progressBar = this.V.uploadWin.down('#progressBar');

    //this.V.uploadBtn.addListener('click', this.uploadCaCertFile, this);
    this.V.uploadBtn.addListener('click', uploadFunction, this);
    this.V.cancelBtn.addListener('click', cancelFunction, this);
    this.V.uploadForm.down('filefield').validator = function (value) {
      if (value.match(reg_exp)) {
        return true;
      }
      return validation_msg;
    };
  },

  readVersion: function () {
    var me = this;
    Ext.Ajax.request({
      url: '/BS350/setting/version',
      success: function (res) {
        me.V.toolFirmwarePanel.update(res.responseText);
      }
    });
  },

  uploadCaCert: function () {
    var me = this;
    this.V.uploadWin = Ext.create('BS350.custom.UploadCertificateWindow', {
      title: TR('Upload Root Certificate')
    });
    this.initUploadWin(function () { this.uploadCertFile('/BS350/wlan/uploadCaCert', TR('Uploaded Root Certificate')); }, function () { this.V.ca_cert.setValue(""); me.updateButtons(); });
    this.V.uploadWin.show();
    this.V.uploadWin.addListener('close', function () {this.updateState = 'start'; }, this);
    this.updateState = 'upload';
  },

  uploadClientCert: function () {
    var me = this;
    this.V.uploadWin = Ext.create('BS350.custom.UploadCertificateWindow', {
      title: TR('Upload Client Certificate')
    });
    this.initUploadWin(function () { this.uploadCertFile('/BS350/wlan/uploadClientCert', TR('Uploaded Client Certificate')); }, function () { this.V.client_cert.setValue(""); me.updateButtons(); });
    this.V.uploadWin.show();
    this.V.uploadWin.addListener('close', function () {this.updateState = 'start'; }, this);
    this.updateState = 'upload';
  },

  uploadPrivateKey: function () {
    var me = this;
    this.V.uploadWin = Ext.create('BS350.custom.UploadCertificateWindow', {
      title: TR('Upload Private Key')
    });
    this.initUploadWin(function () { this.uploadCertFile('/BS350/wlan/uploadPrivateKey', TR('Uploaded Private Key')); }, function () { this.V.private_key.setValue(""); me.updateButtons(); });
    this.V.uploadWin.show();
    this.V.uploadWin.addListener('close', function () {this.updateState = 'start'; }, this);
    this.updateState = 'upload';
  },

  uploadP12Cert: function () {
    var me = this;
    this.V.uploadWin = Ext.create('BS350.custom.UploadCertificateWithPasswordWindow', {
      title: TR('Upload P12 Certificate')
    });
    reg_exp = /(\.p12)$/g
    validation_msg = TR('File must be a .p12');
    this.initUploadWin(
      function () { this.uploadCertFile('/BS350/wlan/uploadP12Cert', TR('Uploaded P12 Certificate')); },
      function () { me.updateButtons(); },
      reg_exp,
      validation_msg
    );
    this.V.uploadWin.show();
    this.V.uploadWin.addListener('close', function () {this.updateState = 'start'; }, this);
    this.updateState = 'upload';
  },

  uploadP12CertAdd: function () {
    var me = this;
    this.V.uploadWin = Ext.create('BS350.custom.UploadCertificateWindow', {
      title: TR('Upload additional P12 Certificate')
    });
    reg_exp = /(\.p12)$/g
    validation_msg = TR('File must be a .p12');
    this.initUploadWin(
      function () { this.uploadCertFile('/BS350/wlan/uploadP12CertAdd', TR('Uploaded additional P12 Certificate')); },
      function () { me.updateButtons(); },
      reg_exp,
      validation_msg
    );
    this.V.uploadWin.show();
    this.V.uploadWin.addListener('close', function () {this.updateState = 'start'; }, this);
    this.updateState = 'upload';
  },

  uploadCertFile: function (url, title) {
    var me = this;
    var form = this.V.uploadForm.getForm();
    var valid = form.getFields().getAt(0).validate();
    if (valid) {
      me.V.uploadForm.setVisible(false);
      //this.V.updateProgress.setVisible(false);
      form.submit({
        url: url,
        success: function (form, action) {
          if (action.result.ca_cert) {
            me.V.ca_cert.setValue(action.result.ca_cert);
          } else if (action.result.client_cert) {
            me.V.client_cert.setValue(action.result.client_cert);
          } else if (action.result.private_key) {
            me.V.private_key.setValue(action.result.private_key);
          }
          me.updateButtons();
          me.V.uploadForm.down('filefield')
          me.V.uploadWin.close();
          if (action.result.p12_cert) {
            Ext.MessageBox.confirm(
              TR("Additional P12 Certificate"),
              TR("P12 file '{0}' is uploaded. Do you want to upload an additional P12 certificate?").format(action.result.p12_cert),
              function (input, a, b) {
                if (input === "yes") {
                  me.V.private_key_passwd.setRawValue(action.result.certs.private_key_passwd);
                  me.V.private_key_passwd_pw.setRawValue(action.result.certs.private_key_passwd);
                  this.uploadP12CertAdd();
                }
                if (input === "no") {
                  me.V.ca_cert.setRawValue(action.result.certs.ca_cert);
                  me.V.client_cert.setRawValue(action.result.certs.client_cert);
                  me.V.private_key.setRawValue(action.result.certs.private_key);
                  me.V.private_key_passwd.setRawValue(action.result.certs.private_key_passwd);
                  me.V.private_key_passwd_pw.setRawValue(action.result.certs.private_key_passwd);
                }
              },
              me
            );
          }
          if (action.result.p12_cert_add) {
            me.V.ca_cert.setRawValue(action.result.certs.ca_cert);
            me.V.client_cert.setRawValue(action.result.certs.client_cert);
            me.V.private_key.setRawValue(action.result.certs.private_key);
          }

          me.useFakeTask = true;
          me.numRetry = 0;
          me.updateState = 'restart';
        },
        failure: function (form, action) {
          // IE can not handle this. Use only for debugging purposes.
          me.V.uploadWin.close();
          Ext.TaskManager.stop(me.updateProgress);
          switch (action.failureType) {
          case Ext.form.action.Action.CLIENT_INVALID:
            Ext.Msg.alert(TR('Failure'), TR('Form fields may not be submitted with invalid values'));
            break;
          case Ext.form.action.Action.CONNECT_FAILURE:
            Ext.Msg.alert(TR('Failure', TR('Ajax communication failed')));
            break;
          case Ext.form.action.Action.SERVER_INVALID:
            Ext.Msg.alert(TR('Failure'), TR(action.result.msg));
            break;
          default:
            Ext.Msg.alert(TR('Failure'), TR(action.result.msg));
            break;
          }
          me.updateState = 'start';
        }
      });
    }
  },

  updateProgress: {
    run: function () {
//      Ext.Ajax.request({
//        url: '/BS350/upload/upload/progress',
//        success: function (res) {
//          me.V.progressLabel.setText(TR('Uploading firmware'));
//          var prog = parseFloat(res.responseText);
//          me.V.progressBar.updateProgress(prog, Math.floor(prog * 100) + '%');
//        }
//      });
    },
    interval: 1000
  },

  checkStatus: function (status) {
    if (this.view && this.active) {
      if (this.updateState === 'start') {
        this.V.messageToolLbl.setVisible(status.battery < 50);
        this.V.messagePowerLbl.setVisible(status.battery < 50);
        this.V.updateToolBtn.setDisabled(status.battery < 50);
        this.V.updatePowerBtn.setDisabled(status.battery < 50);
      } else if (this.updateState === 'restart') {
        if (status.connected) {
          if (this.numRetry > 10) {
            this.V.uploadWin.close();
            Ext.Msg.alert(TR('Success'), TR('Firmware upgraded'));
            window.location = './logout';
          } else if (this.useFakeTask) {
            this.V.progressLabel.setText(TR('Rebooting...'));
          }
        } else if (this.useFakeTask) {
          if (this.numRetry === 5) {
            this.V.progressLabel.setText(TR(this.fakeTasks[0]));
          }
          if (this.numRetry === 15) {
            this.V.progressLabel.setText(TR(this.fakeTasks[1]));
          }
          if (this.numRetry === 25) {
            this.V.progressLabel.setText(TR(this.fakeTasks[2]));
          }
          if (this.numRetry === 60) {
            this.V.progressLabel.setText(TR(this.fakeTasks[3]));
          }
          if (this.numRetry === 70) {
            this.V.progressLabel.setText(TR(this.fakeTasks[4]));
          }
        }
        this.numRetry++;
      }
    }
  },

  startUploading: function () {
    this.V.progressLabel.setText(TR('Uploading firmware'));
    this.V.progressBar.updateProgress(0, '0%');

    Ext.TaskManager.start(this.updateProgress);
  },

  finishUploading: function () {
    Ext.TaskManager.stop(this.updateProgress);
  },


  askclose: function (panel) {
    var me = this;
    var dirty = this.V.wlanform.form.isDirty() || me.V.list_bg.isDirty() || me.V.etsi_list_a.isDirty() || me.V.fcc_list_a.isDirty();
    me.V.wlanform.form.setValues(me.V.wlanform.form.getValues());
    if (dirty && !me.forceClose) {
      Ext.Msg.show({
        title: TR('Save changes?'),
        msg: TR('Do you want to save the changes?'),
        buttons: Ext.Msg.YESNOCANCEL,
        fn: function (btn) {
          if (btn === 'yes') { me.forceClose = true; me.save(null, null, {callback: function () { panel.close(); me.forceClose = false; }}); }
          if (btn === 'no') { me.forceClose = true; panel.close(); me.forceClose = false; }
        },
        icon: Ext.Msg.QUESTION
      });
      return false;
    }
    return true;
  }
});
