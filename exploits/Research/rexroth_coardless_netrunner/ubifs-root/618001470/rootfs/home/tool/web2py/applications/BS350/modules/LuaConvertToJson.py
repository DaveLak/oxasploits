#!/usr/bin/env python2.7

import luaModule
from pprint import pprint
import re
import syslog
from MasterjobData import MasterJobSelectionStep, MasterJobStartStep, MasterJob, MasterJobScanStep, MasterJobEndStep, Conversion
import fsio
import os
from collections import OrderedDict

Types = {
  1: 'TypeDevice',
  2: 'TypeDeviceGrp',
  3: 'TypeAction',
  4: 'TypeTriggerIn',
  5: 'TypeTriggerInGrp',
  6: 'TypeTriggerOut',
  7: 'TypeTriggerOutGrp',
  8: 'TypeEndNode',
  9: 'TypeStartNode',
  10: 'TypeIdleEndNode',
  11: 'TypeIdleStartNode',
  12: 'TypeConfig',
  13: 'TypeInfo'
}

ReversedTypes = {
  'TypeAction': 3,
  'TypeDevice': 1,
  'TypeDeviceGrp': 2,
  'TypeEndNode': 8,
  'TypeIdleEndNode': 10,
  'TypeIdleStartNode': 11,
  'TypeStartNode': 9,
  'TypeTriggerIn': 4,
  'TypeTriggerInGrp': 5,
  'TypeTriggerOut': 6,
  'TypeTriggerOutGrp': 7,
  'TypeConfig': 12,
  'TypeInfo': 13
}


def reverseKeyValues(my_dict):
  return {v: k for k, v in my_dict.items()}

InModes = {
  1: 'TriggerInModeJobAppIn',
  2: 'TriggerInModeIdCode',
  3: 'TriggerInModeJobResult',
  4: 'TriggerInModeTighteningResult',
  5: 'TriggerInModeEnableJob',
  6: 'TriggerInModeStepInc',
  7: 'TriggerInModeStepDec',
  8: 'TriggerInModeJobNr',
  9: 'TriggerInModeCwJob',
  10: 'TriggerInModeRefreshDone',
  11: 'TriggerInModeBms',
  12: 'TriggerInModeError',
  13: 'TriggerInModeOkNokResult',
  14: 'TriggerInModeCyCmpInternal',
  15: 'TriggerInModeInCyInternal',
  16: 'TriggerInModePrgNrAck',
  17: 'TriggerInModeTimeDelay',
  18: 'TriggerInModeTimeoutAtom',
  19: 'TriggerInModeTimeoutAction',
  20: 'TriggerInModeTimeoutJob',
  21: 'TriggerInModeDummy1',
  22: 'TriggerInModeDummy2',
  23: 'TriggerInModeILAck',
  24: 'TriggerInModeScanInitAck',
  25: 'TriggerInModeScanTrigger',
  26: 'TriggerInModeScanResult',
  27: 'TriggerInModeBmsIn',
  28: 'TriggerInModeBmsOut',
  29: 'TriggerInModeStopJob'

}

ReversedInModes = {
  'TriggerInModeJobAppIn': 1,
  'TriggerInModeIdCode': 2,
  'TriggerInModeJobResult': 3,
  'TriggerInModeTighteningResult': 4,
  'TriggerInModeEnableJob': 5,
  'TriggerInModeStepInc': 6,
  'TriggerInModeStepDec': 7,
  'TriggerInModeJobNr': 8,
  'TriggerInModeCwJob': 9,
  'TriggerInModeRefreshDone': 10,
  'TriggerInModeBms': 11,
  'TriggerInModeError': 12,
  'TriggerInModeOkNokResult': 13,
  'TriggerInModeCyCmpInternal': 14,
  'TriggerInModeInCyInternal': 15,
  'TriggerInModePrgNrAck': 16,
  'TriggerInModeTimeDelay': 17,
  'TriggerInModeTimeoutAtom': 18,
  'TriggerInModeTimeoutAction': 19,
  'TriggerInModeTimeoutJob': 20,
  'TriggerInModeDummy1': 21,
  'TriggerInModeDummy2': 22,
  'TriggerInModeILAck': 23,
  'TriggerInModeScanInitAck': 24,
  'TriggerInModeScanTrigger': 25,
  'TriggerInModeScanResult': 26,
  'TriggerInModeBmsIn': 27,
  'TriggerInModeBmsOut': 28,
  'TriggerInModeStopJob': 29
}

OutModes = {
  1: 'TriggerOutModeNone',
  2: 'TriggerOutModeBms',
  3: 'TriggerOutModeHmi',
  4: 'TriggerOutModeJobResult',
  5: 'TriggerOutModeRefresh',
  6: 'TriggerOutModeSetOkNok',
  7: 'TriggerOutModeDelOkNok',
  8: 'TriggerOutTimeoutAtom',
  9: 'TriggerOutTimeoutJob',
  10: 'TriggerOutModeAutoRun',
  11: 'TriggerOutModeJobAppOut',
  12: 'TriggerOutModeTimeDelay',
  13: 'TriggerOutModeStepInit',
  14: 'TriggerOutModeStepFinal',
  15: 'TriggerOutModeILBridge',
  16: 'TriggerOutModeScanInit',
  17: 'TriggerOutModeDoScan',
  18: 'TriggerOutIdCodeSrc',
  19: 'TriggerOutIDCodeParts',
  20: 'TriggerOutModeScanFinal',
  21: 'TriggerOutModeBmsIn',
  22: 'TriggerOutModeBmsOut',
  23: 'TriggerOutModeIdCodeInit',
  24: 'TriggerOutModeResetOkNok'
}

ReversedOutModes = {
  'TriggerOutIdCodeSrc': 18,
  'TriggerOutModeAutoRun': 10,
  'TriggerOutModeBms': 2,
  'TriggerOutModeDelOkNok': 7,
  'TriggerOutModeDoScan': 17,
  'TriggerOutModeHmi': 3,
  'TriggerOutModeILBridge': 15,
  'TriggerOutModeJobAppOut': 11,
  'TriggerOutModeJobResult': 4,
  'TriggerOutModeNone': 1,
  'TriggerOutModeRefresh': 5,
  'TriggerOutModeScanInit': 16,
  'TriggerOutModeSetOkNok': 6,
  'TriggerOutModeStepFinal': 14,
  'TriggerOutModeStepInit': 13,
  'TriggerOutModeTimeDelay': 12,
  'TriggerOutTimeoutAtom': 8,
  'TriggerOutTimeoutJob': 9,
  'TriggerOutIDCodeParts': 19,
  'TriggerOutModeScanFinal': 20,
  'TriggerOutModeBmsIn': 21,
  'TriggerOutModeBmsOut': 22,
  'TriggerOutModeIdCodeInit': 23,
  'TriggerOutModeResetOkNok': 24
}

idsrc = {
  0: 'noidcode',
  1: 'cyclecounter',
  2: 'openprotocol',
  3: 'scanner',
  4: 'job',
  5: 'vxwml'
}


reverseIdsrc = {
  'noidcode': 0,
  'cyclecounter': 1,
  'openprotocol': 2,
  'scanner': 3,
  'job': 4,
  'vwxml': 5
}

scanCodes = {
  0: 'Code128',
  1: 'Code39',
  2: 'Code93',
  3: 'Code11',
  4: 'Interleaved2of5',
  5: 'Codabar',
  6: 'Msi',
  7: 'UccEan128'
}

reverseScanCodes = {
  'Code128': 0,
  'Code39': 1,
  'Code93': 2,
  'Code11': 3,
  'Interleaved2of5': 4,
  'Codabar': 5,
  'Msi': 6,
  'UccEan128': 7
}

operation_mode_trigger = {
    0: "HMI",
    1: "Open Protocol",
    2: "IdCode",
    3: "BMS Signal ManOp"
}


def getAtomTypeMode(type, mode):
  if type == 6:
    return Types[type], OutModes[mode]
  elif type == 4:
    return Types[type], InModes[mode]
  else:
    raise Exception('Type {0} not found'.format(str(type)))


atom_index_with_suffix = re.compile("^([0-9]*)(.*)$")

def getIndices(k):
    #print "getIndices", k
    n, i = k.split("$")
    i_step, i_atom = i.split("A")
    i_step = int(i_step)
    ma = atom_index_with_suffix.match(i_atom).groups()
    i_atom = int(ma[0])
    return i_step, i_atom, ma[1]

class Job:
  def __init__(self, slot=0, initNode=None):
    self.data = {
      "Slot": slot,
      "Comment": initNode.get('jobComment'),
      "Name": initNode['jobName'],
      "Version": "",
      "User": initNode.get('jobUser'),
      "Date": initNode.get('jobDate'),
      "id": slot,
      "steps": []
    }

  def addStep(self, step):
    self.data["steps"].append(step)

  def getData(self):
    steps = self.data.pop("steps", None)
    self.data["steps"] = []
    for step in steps:
      self.data["steps"].append(step.getData())

    return self.data


class StepTemplate:
  def __init__(self):
    self.START_STEP = 0
    self.PROGRAM_STEP = 1
    self.END_STEP = 2
    self.IDCODE_STEP = 5
    self.WAIT_STEP = 6
    self.templates = {}

  def getStepTmpl(self, stepType, params={}):
    if stepType == "Start":
      return StartStep(**params)
    elif stepType == "Single Program":
      return ProgramStep(**params)
    elif stepType == "Wait":
      return WaitStep(**params)
    elif stepType == "End":
      return EndStep(**params)
    elif stepType == "ID Input" or stepType == "ID Code":
      return ScanStep(**params)
    else:
      raise Exception("Step Type '" + stepType + "' not found")

  def getStepIndex(self, stepType):
    if stepType == "Start":
      return self.START_STEP
    elif stepType == "Single Program":
      return self.PROGRAM_STEP
    elif stepType == "Wait":
      return self.WAIT_STEP
    elif stepType == "End":
      return self.END_STEP
    elif stepType == "ID Input" or stepType == "ID Code":
      return self.IDCODE_STEP
    else:
      raise Exception("Step Type '" + stepType + "' not found")

  def getStepName(self, stepIndex):
    if self.START_STEP == stepIndex:
      return "Start"
    elif self.PROGRAM_STEP == stepIndex:
      return "Single Program"
    elif self.WAIT_STEP == stepIndex:
      return "Wait"
    elif self.END_STEP == stepIndex:
      return "End"
    elif self.IDCODE_STEP == stepIndex:
      return "ID Input"
    else:
      raise Exception("Step Index " + stepIndex + " not found")


class Guiable:
  def getData(self):
    #print("GET_DATA")

    if (len(self.data) == 3):
      self.data[1]
      target = self._transform(self.data[2])

      return (self.data[1], target)
    else:
      raise Exception("Wrong length found")

  def _transform(self, local_data):

    targetList = []
    for ld in local_data:
      target = {}
      targetList.append(target)
      if len(ld) > 1:
        target['myText'] = ld[0].keys()[0]
        if ld[0][target['myText']] != None:
          target['myValue'] = ld[0][target['myText']]
        target.update(ld[1])

      if len(ld) == 3:
        target['children'] = self._transform(ld[2])

    return targetList


class EndStep(Guiable):
  def __init__(self, displayName='End', comment="", enable="false"):
    self.data = [None,
                 {
                   u"Type": 2,
                   u"execPy": "BeginStep('END')",
                   },
                 [[{u'General': None},
                   {u'expanded': True, u'leaf': False },
                   [[{u'Name': str(displayName)},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '40',
                      u'stepname': u'End',
                      u"execPy": u"step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}],
                    [{u'Comment': comment},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '40',
                      u"execPy": u"step['comment'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}]]],
                  [{u'Options': None},
                   {u'expanded': True, u'leaf': False},
                   [[{u'Enable tool': enable},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['actions'][1] = 'ToolDisable()';FinalizeStep()",
                      u'type': u'CHECKBOX'}]]]]]

  @staticmethod
  def extractParams(step, comment, stepParams):
    name = step[0][step[0].keys()[0]].get('step').get('name')
    result_step = None
    display_name = step[0][step[0].keys()[0]].get('step').get('display_name')
    if display_name == None:
        display_name = 'End'

    for i in step.keys():
      atom = step[i][step[i].keys()[0]]['atom']
      if atom.get('mode') == 14 and atom['type'] == 6:

        params = {
          'displayName': display_name,
          'comment': comment
        }

        stepParams['params'] = params
        result_step = Step(**stepParams)

    return result_step


class StartStep(Guiable):
  def __init__(self,
               displayName='Start',
               comment="",
               timeout=0.3,
               display_time = 1,
               selectsCw=False,
               selectsEn=False,
               displayJobSteps=True,
               stopOnNok=False,
               clearIDCode="",
               stopOnTimeout=False,
               clear_jobapp_out_signals=False
  ):
    self.data = [None,
                 {
                   u"Type": 0,
                   u"execPy": u"BeginStep('START');step['actions'][1]='ToolDisable()';step['actions'][2]='ResetOkNokCounter()'"
                 },
                 [[{u'General': None},
                   {u'expanded': True, u'leaf': False},
                   [[{u'Name': str(displayName)},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '40',
                      u'stepname':u'Start',
                      u"execPy": u"step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}],
                    [{u'Comment': comment},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '40',
                      u"execPy": u"step['comment'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}]]],
                  [{u'Options': None},
                   {u'expanded': True, u'leaf': False},
                   [[{u'Timeout (sec)': str(timeout)},
                     {u'invisible': True,
                      u'leaf': True,
                      u"execPy": u"StartStep['timeout'] = float(firstLevel.get('myValue')) * 1000",
                      u'type': u'EDITBOX'}],
                    [{u'Channel Cw set by Job': str(selectsCw).lower()},
                     {u'invisible': True,
                      u'leaf': True,
                      u'readonly': False,
                      u"execPy": u"StartStep['selectsCw'] = Get1or0(firstLevel.get('myValue'))",
                      u'type': u'CHECKBOX'}],
                    [{u'Channel En set by Job': str(selectsEn).lower()},
                     {u'invisible': True,
                      u'leaf': True,
                      u'readonly': False,
                      u"execPy": u"StartStep['selectsEn'] = Get1or0(firstLevel.get('myValue'))",
                      u'type': u'CHECKBOX'}],
                    [{u'Show job step info in display': str(displayJobSteps).lower()},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u"execPy": u"StartStep['displayJobSteps'] = Get1or0(firstLevel.get('myValue'))",
                      u'type': u'CHECKBOX'}],
                    [{u'Job step info display time': str(display_time).lower()},
                     {u'invisible': False,
                      u'leaf': True,
                      u'min': 0.1, u'max': 10, u'step': 0.1, u'default': 1,
                      u'readonly': False,
                      u"execPy": u"StartStep['displayTime'] = firstLevel.get('myValue')",
                      u'type': u'NUMBERFIELD_U'}],
                    [{u'Job abort when NOK result in job step': str(stopOnNok).lower()},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u"execPy": u"StartStep['stopOnNok'] = firstLevel.get('myValue')",
                      u'type': u'CHECKBOX'}],
                    [{u'Clear ID code at end of job': str(clearIDCode).lower()},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u"execPy": u"StartStep['ClearIDCode'] = Get1or0(firstLevel.get('myValue'))",
                      u'type': u'CHECKBOX'}],
                    [{u'Job abort when Timeout': str(stopOnTimeout).lower()},
                     {u'invisible': True,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"StartStep['stopOnTimeout'] = firstLevel.get('myValue')",
                      u'type': u'CHECKBOX'}],
                    [{u'Clear JobApp Out Signals': str(clear_jobapp_out_signals).lower()},
                     {u'invisible': True,
                      u'leaf': True,
                      u'readonly': False,
                      u"execPy": u"step['ClearJobAppOut'] = firstLevel.get('myValue');step['actions'][3]='ClearJobAppOut()';FinalizeStep()",
                      u'type': u'CHECKBOX'}]]]]]

  @staticmethod
  def extractParams(step, initNode, config, comment, stepParams):
    display_name = step[0][step[0].keys()[0]].get('step').get('display_name')
    if display_name == None:
      display_name = 'Start'

    params = {'displayName': display_name,
              'displayJobSteps': bool(initNode['displayJobSteps']),
              'display_time': initNode.get('displayTime') or 1,
              'clearIDCode': bool(initNode['clearIDCode']),
              'selectsCw': bool(initNode['selectsCw']),
              'selectsEn': bool(initNode['selectsEn']),
              'stopOnNok': config['stopOnNok'],
              'stopOnTimeout': config['stopOnTimeout'],
              'comment': comment}

    methodParams = {}
    methodParams.update(stepParams)
    methodParams['params'] = params
    #---- STEP: 1/0 'Start' ATOM: name: 'step init$01A00' atom type: TypeTriggerOut mode: TriggerOutModeStepInit state: 0
    #---- STEP: 1/1 'Start' ATOM: name: 'Tool disable$01A01' atom type: TypeTriggerOut mode: TriggerOutModeBms state: 0
    #---- STEP: 1/2 'Start' ATOM: name: 'del OkNok No $01A02' atom type: TypeTriggerOut mode: TriggerOutModeDelOkNok state: 7
    #---- STEP: 1/3 'Start' ATOM: name: 'set JobOut signals$01A03' atom type: TypeTriggerOut mode: TriggerOutModeJobAppOut state: 0
    #---- STEP: 1/4 'Start' ATOM: name: 'step final$01A04' atom type: TypeTriggerOut mode: TriggerOutModeStepFinal state: 0
    for i in sorted(step.keys()):
        atom = step[i][step[i].keys()[0]]['atom']
        if ReversedTypes['TypeTriggerOut'] == atom['type'] \
              and ReversedOutModes['TriggerOutModeJobAppOut'] == atom.get('mode'):
            params['clear_jobapp_out_signals'] = True

    if len(step.keys()) > 0:
        step = Step(**methodParams)
        return step

    return None


class WaitStep(Guiable):
    def __init__(self, comment="", display_text="", delay=10, tool_enable=False):
        self.data = [None,
                 {
                   u"Type": 6,
                   u"execPy": u"BeginStep('WAIT_STEP')",
                   },
                 [[{u'General': None},
                   {u'expanded': True, u'leaf': False},
                   [[{u'Name': u'Wait'},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '40',
                      u'stepname':u'Wait',
                      u"execPy": u"step['name'] = firstLevel.get('stepname')",
                      u'type': u'EDITBOX'}],
                    [{u'Comment': comment},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '40',
                      u"execPy": u"step['comment'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}]]],
                  [{u'Waiting': None},
                   {u'expanded': True, u'leaf': False},
                   [[{u'Display Text': display_text},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '80',
                      u"execPy": u"AddText(firstLevel.get('myValue'))",
                      u'type': u'EDITBOX'}],
                    [{u'Delay (sec)': str(delay)},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u"execPy": u"step['timeout'] = float(firstLevel.get('myValue')) * 1000",
                      u'type': u'EDITBOX',
                      u'validation': u'TIME'}],
                    [{u'Tool Enable': str(tool_enable).lower()},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['actions'][1]='SetWaitStep()';FinalizeStep()",
                      u'type': u'CHECKBOX'}]]]]]

    @staticmethod
    def extractParams(step, comment, stepParams):
        result_step = None
        for i in step.keys():
            atom = step[i][step[i].keys()[0]]['atom']
            if atom.get('mode') == 12 and atom['type'] == 6:
                params = {
                  'comment': comment
                }
                stepParams['params'] = params
                result_step = Step(**stepParams)

        return result_step


class ProgramStep(Guiable):
  def __init__(self,
               displayName = "Single Program",
               comment="",
               display="",
               all_configured_counters_must_be_completed=False,
               select_program_automatically='Socket tray number (BoxNutSelX)',
               set_socket_tray_signals=False,
               let_socket_tray_signals_blink=False,
               program_no=0,
               max_ok=1,
               max_nok=0,
               mixIdCode = False,
               prefix="",
               part1="$Mode",
               part2="",
               part3="",
               part4="",
               part5="",
               part6="",
               part7="",
               part8="",
               part9="",
               part10="",
               postfix="",
               #procedure_if_number_of_ok_nok_is_reached_or_for_abort=None,
               block_nutrunner=False,
               enable_loosening_program_no_99=False,
               decOkCounter = False,
               block_loosening_program_after_tightening_ok=False,
               timeout=600,
               timeout_text='timeout',
               block_loosening_program_after_tightening_nok=False):
    self.data = [None,
                 {
                   u"Type": 1,
                   u"execPy": u"BeginStep('SINGLE_STEP')"
                 },
                 [[{u'General': None},
                   {u'expanded': True, u'leaf': False},
                   [[{u'Name': str(displayName)},
                     {u'invisible': False,
                      u'leaf': True,
                      u'stepname':u'Single Program',
                      u'readonly': False,
                      u'maxLength': '40',
                      u"execPy": u"step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}],
                    [{u'Comment': comment},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '40',
                      u"execPy": u"step['comment'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}]]],

                   [{u'ID Code': str(True).lower()},
                    {u'expanded': False,
                     u'leaf': False,
                     u'invisible': False,
                     u'readonly': False,
                     u"execPy": u"",
                     u'myValue': str(False).lower(),
                     u'type': u'DONOTSHOWVALUE'
                     },

                    [[{u'Combine multiple ID Inputs to one ID Code': None},
                     {u'invisible': False,
                       u'leaf': False,
                       u'expanded': mixIdCode,
                       u'expandable': True,
                       u'readonly': False,
                       u"execPy": u"step['mixIDCode'] = firstLevel.get('myValue')",
                       #u'icon': "/static/ext-4.2/resources/themes/images/nexo/shared/icon-error.gif",
                       u'iconCls': "ico16-leaf",
                       u'type': u'COMBINEIDCODE',
                       u'myValue': str(mixIdCode).lower()
                     },
                      [
                      [{u'Prefix': str(prefix)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart0'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 1': str(part1)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart1'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 2': str(part2)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart2'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 3': str(part3)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart3'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 4': str(part4)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart4'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 5': str(part5)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart5'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 6': str(part6)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart6'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 7': str(part7)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart7'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 8': str(part8)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart8'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 9': str(part9)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart9'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Part 10': str(part10)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart10'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}],
                      [{u'Postfix': str(postfix)},
                        {u'invisible': False,
                         u'leaf': True,
                         u'readonly': False,
                         u"execPy": u"step['IDpart11'] = secondLevel.get('myValue')",
                         u'validation': u'TEXT',
                         u'choice':[u'$Mode', u'Userdefined Text'],
                         u'type': u'COMBOBOXID'}]
                      ]
                    ]]
                  ],

                  [{u'Tightening': None},
                   {u'expanded': True, u'leaf': False},
                   [[{u'Display Text': display},
                     {u'invisible': False,
                      u'leaf': True,
                      u'maxLength': '80',
                      u'readonly': False,
                      u"execPy": u"AddText(firstLevel.get('myValue'))",
                      u'type': u'EDITBOX'}],
                    [{u'All configured counters must be completed': str(all_configured_counters_must_be_completed).lower()},
                     {u'invisible': True,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['CompleteAllConfiuredCounters'] = firstLevel.get('myValue')",
                      u'type': u'CHECKBOX'}],
                    [{u'Tool Enable': u'true'},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['ToolEnable'] = firstLevel.get('myValue')",
                      u'type': u'CHECKBOX'}],
                    [{u'Select Program Automatically': select_program_automatically},
                     {u'datalist': u'Socket tray number (BoxNutSelX);PLC interface (ProgX);',
                      u'invisible': True,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['AutoselectProg'] = firstLevel.get('myValue')",
                      u'type': u'COMBOBOX'}],
                    [{u'Count Of Sockets': u'1'},
                     {u'datalist': u'1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;',
                      u'invisible': True,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['CountOfSockets'] = firstLevel.get('myValue')",
                      u'relation': u'Program',
                      u'type': u'COMBOBOX'}],
                    [{u'Set socket tray signals': str(set_socket_tray_signals).lower()},
                     {u'invisible': True,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['SetSignals'] = firstLevel.get('myValue')",
                      u'type': u'CHECKBOX'}],
                    [{u'Let socket tray signals blink': str(let_socket_tray_signals_blink).lower()},
                     {u'invisible': True,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['BlinkSignals'] = firstLevel.get('myValue')",
                      u'type': u'CHECKBOX'}],
                    [{u'Program': None},
                     {u'expanded': True},
                     [[{u'Socket Tray No': u' '},
                       {u'datalist': u' ;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32',
                        u'invisible': True,
                        u'leaf': True,
                        u'readonly': True,
                        u"execPy": u"AddOkNokCounter();SetOkNokSocket(secondLevel.get('myValue'))",
                        u'type': u'COMBOBOX'}],
                      [{u'Program No': str(program_no)},
                       {u'invisible': False,
                        u'leaf': True,
                        u'readonly': False,
                        u"execPy": u"SetOkNokProgram(secondLevel.get('myValue'))",
                        u'type': u'COMBOBOXPRG'}],
                      [{u'Max OK': str(max_ok)},
                       {u'invisible': False,
                        u'leaf': True,
                        u'readonly': False,
                        u"execPy": u"SetOkNokMaxOk(secondLevel.get('myValue'))",
                        u'type': u'EDITBOX',
                        u'validation': u'NUMBERMAXOK'}],
                      [{u'Max NOK': str(max_nok)},
                       {u'invisible': False,
                        u'leaf': True,
                        u'readonly': False,
                        u"execPy": u"SetOkNokMaxNok(secondLevel.get('myValue'))",
                        u'type': u'EDITBOX',
                        u'validation': u'NUMBERMAXOK'}]]],
                    [{u'Procedure if number of OK/NOK is reached or for abort': None},
                     {u'expanded': True,
                      u'invisible': True},
                     [[{u'Block nutrunner': u'true'}, #str(block_nutrunner).lower()},
                       {u'invisible': True,
                        u'leaf': True,
                        u'readonly': False,
                        u"execPy": u"step['blockNutrunner'] = secondLevel.get('myValue')",
                        u'type': u'CHECKBOX'}],
                      [{u'Enable loosening program no. 99': u'false'}, #str(enable_loosening_program_no_99).lower()},
                       {u'invisible': True,
                        u'leaf': True,
                        u'readonly': False,
                        u"execPy": u"step['LooseProgram99'] = secondLevel.get('myValue')",
                        u'type': u'CHECKBOX'}]]],
                    [{u'Conditional blocking of loosening program': None},
                     {u'expanded': True},
                     [[{u'Block loosening program after tightening OK': str(block_loosening_program_after_tightening_ok).lower() },
                       {u'invisible': False,
                        u'leaf': True,
                        u'readonly': False,
                        u"execPy": u"step['blockLooseningProgAfterOK'] = secondLevel.get('myValue')",
                        u'type': u'CHECKBOX'}],
                      [{u'Block loosening program after tightening NOK': str(block_loosening_program_after_tightening_nok).lower()},
                       {u'invisible': False,
                        u'leaf': True,
                        u'readonly': False,
                        u"execPy": u"step['blockLooseningProgAfterNOK'] = secondLevel.get('myValue')",
                        u'type': u'CHECKBOX'}]]],
                    [{u'Special functions': None},
                     {u'expanded': True,
                      u'invisible': True },
                     [[{u'Decrement the OK counter after loosening': str(decOkCounter).lower()},
                       {u'invisible': True,
                        u'leaf': True,
                        u'readonly': False,
                        u"execPy": u"step['DecOkCounter'] = secondLevel.get('myValue')",
                        u'type': u'CHECKBOX'}]]]
                   ]],

                    [{u'Timeout Options': None},
                    {u'expanded': True, u'leaf': False},
                    [[{u'Timeout': str(timeout)},
                     {u'default': 600,
                      u'invisible': False,
                      u'leaf': True,
                      u'max': 1000,
                      u'min': 1,
                      u'readonly': False,
                      u'step': 1,
                      u"execPy": u"step['PrgTimeout'] = firstLevel.get('myValue')",
                      u'type': u'NUMBERFIELD_U'}],
                    [{u'Error Message after Timeout': str(timeout_text)},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '80',
                      u"execPy": u"step['PrgErrMsg'] = firstLevel.get('myValue');step['actions'][1]='SetOkNokCounter(True)';FinalizeStep()",
                      u'type': u'EDITBOX'}]]]
                 ]
    ]


  @staticmethod
  def idcodeToID_Input(mystr):
      if mystr.startswith("$idcode"):
          myid = mystr[7:]
          return "$ID Input" + myid
      return mystr


  @staticmethod
  def extractParams(step, comment, stepParams):
    methodParams = {}
    methodParams.update(stepParams)
    params = {}

    display_name = step[0][step[0].keys()[0]].get('step').get('display_name')
    if display_name == None:
      display_name = 'Single Program'

    result_step = None
    for i in step.keys():
      atom = step[i][step[i].keys()[0]]['atom']

      if atom.get('mode') == 6 and atom.get('type') == 6 and atom.get('state') == 7:
        params['displayName'] = display_name
        params['comment'] = comment
        params['all_configured_counters_must_be_completed'] = atom['valueList']['CountOverAllCounters']
        #select_program_automatically=atom['valueList'][''],
        #'set_socket_tray_signals': atom['valueList']['SetSocketTrayAckSignals'],
        #'let_socket_tray_signals_blink': atom['valueList']['ToggleSocketTrayAckSignals'],
        params['program_no'] = atom['valueList']['Counters'][0]['Nr']
        params['max_ok'] = atom['valueList']['Counters'][0]['Ok']
        params['max_nok'] = atom['valueList']['Counters'][0]['Nok']
        params['block_nutrunner'] = atom['valueList']['LockCtrl']
        params['decOkCounter'] = atom['valueList']['DecrementOkCounter']
        params['enable_loosening_program_no_99'] = atom['valueList']['EnablePrg99']
        params['block_loosening_program_after_tightening_ok'] = atom['valueList']['BlockPrg99AfterOk']
        params['block_loosening_program_after_tightening_nok'] = atom['valueList']['BlockPrg99AfterNok']

      if atom.get('mode') == 15 and atom['type'] == 4 and atom.get('name').startswith('Wait for Incycle') and atom['text'] != '':
        params['display'] = atom['text']

      if atom.get('name').startswith('OkNokResultTimeout$'):
        params['timeout'] = atom['timeout']

      if atom.get('name').startswith('DisplayPrgStepTimeDelay$'):
        params['timeout_text'] = atom['text']

      if atom.get('mode') == 19 and atom['type'] == 6:
        params['mixIdCode'] = True
        params['prefix'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('1'))
        params['part1'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('2'))
        params['part2'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('3'))
        params['part3'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('4'))
        params['part4'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('5'))
        params['part5'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('6'))
        params['part6'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('7'))
        params['part7'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('8'))
        params['part8'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('9'))
        params['part9'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('10'))
        params['part10'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('11'))
        params['postfix'] = ProgramStep.idcodeToID_Input(atom['valueList'].get('12'))

    methodParams['params'] = params
    result_step = Step(**methodParams)

    return result_step

class ScanStep(Guiable):
  def __init__(self,
               displayName="ID Input",
               comment="",
               ScanTrigger=2,
               ScanTarget=1,
               display="",
               attempts=2,
               range="1-256",
               scanstepid="ID Input",
               c128_filter="true",
               uc128_filter="true",
               c39_filter="true",
               c93_filter="true",
               c11_filter="true",
               i2o5_filter="true",
               codabar_filter="true",
               msi_filter="true",
               timeout=600,
               laserOnTime = 3,
               error_message_after_timeout="",
               idCodeDevice=0,
               play_sound=False
  ):
    self.data = [None,
                 {
                   u"Type": 5,
                   u"execPy": u"BeginStep('IDCODE_STEP')"
                 },
                 [[{u'General': None},
                   {u'expanded': True, u'leaf': False},
                   [[{u'Identifier': str(scanstepid)},
                     {u'leaf': True,
                      u'type': u'EDITBOX',
                      u'readonly': True,
                      u"execPy": u"step['scanID'] = firstLevel.get('myValue')"
                     }],
                     [{u'Name': str(displayName)},
                     {u'leaf': True,
                      u'maxLength': '40',
                      u'type': u'EDITBOX',
                      u'stepname':u'ID Input',
                      u"execPy": u"step['name'] = firstLevel.get('stepname');step['displayName'] = firstLevel.get('myValue')"
                     }],
                    [{u'Comment': str(comment)},
                     {u'leaf': True,
                      u'maxLength': '40',
                        u"execPy": u"step['comment'] = firstLevel.get('myValue')",
                        u'type': u'EDITBOX'
                     }]]],
                  [{u'ID Input Options': u''},
                   {u'expanded': True, u'leaf': False},
                   [
                    [{u'Source Selection': str(idCodeDevice)},
                      {u'choice':[
                        [0, "Scanner"],
                        [1, "Open Protocol"]
                      ],
                      u'type': u'COMBOBOX',
                      u'invisible': False,
                      u'readonly': False,
                      u"execPy": u"step['IDSource'] = firstLevel.get('myValue')",
                      u'leaf': True}],

                    [{u'Choose target for ID Input': str(ScanTarget)},
                     {u'choice': [
                        [0, u"Undefined"],
                        [1, u"ID Code"]
                     ],
                      u'expanded': False,
                      u'leaf': True,
                      u'readonly': True,
                      u"execPy": u"step['ScanTarget'] = firstLevel.get('myValue')",
                      u'type': u'COMBOBOX'}],

                    [{u'Masking': str(range)},
                     {u'expanded': False,
                      u'leaf': True,
                      u"readonly": False,
                      u"execPy": u"step['ScanMasking'] = firstLevel.get('myValue')",
                      u"type": u"EDITBOX"}],

                 #   [{u'Attempts': str(attempts)},
                 #    {u'expanded': False,
                 #     u'leaf': True,
                 #     u"readonly": False,
                 #     u"validation": u"ATTEMPTNUMBER",
                 #     u"execPy": u"step['ScanAttempts'] = firstLevel.get('myValue')",
                 #     u"type": u"EDITBOX"}],

                   [{u'Display Text': str(display)},
                     {u'invisible': False,
                      u'leaf': True,
                      u'readonly': False,
                      u'maxLength': '80',
                      u"execPy": u"step['displayText'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}]]

                  ],


                  [{u'Timeout Options': None},
                    {u'expanded': True, u'leaf': False},
                   [[{u'Timeout': str(timeout)},
                     {u'default': 600,
                      u'invisible': False,
                      u'leaf': True,
                      u'max': 1000,
                      u'min': 1,
                      u'readonly': False,
                      u'step': 1,
                      u"execPy": u"step['ScanTimeout'] = firstLevel.get('myValue')",
                      u'type': u'NUMBERFIELD_U'}],
                    [{u'Error Message after Timeout': str(error_message_after_timeout)},
                     {u'invisible': False,
                      u'leaf': True,
                      u'maxLength': '80',
                      u'readonly': False,
                      u"execPy": u"step['ScanErrMsg'] = firstLevel.get('myValue')",
                      u'type': u'EDITBOX'}]]],

                  [{u'Scan Options': None},
                   {u'expanded': True, u'leaf': False},
                   [
                     [{u'Choose triggermode for scanner': str(ScanTrigger)},
                     {u'choice': [
                       [0, u"Trigger with Startbutton"],
                       [1, u"Menubutton"],
                       [2, u"Button Left"],
                       [3, u"Button Right"],
                       [4, u"BMS"]
                     ],
                      u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"step['ScanTrigger'] = firstLevel.get('myValue')",
                      u'type': u'COMBOBOX'}],

                     [{u'Laser on time': str(laserOnTime)},
                       {u'expanded': False,
                        u'leaf': True, u'min': 1, u'max': 25, u'step': 0.5,
                        u"execPy": u"step['ScanLaserOnTime'] = firstLevel.get('myValue')",
                        u'type': u'NUMBERFIELD_U'}
                      ],

                     [{u'Play decode signal tone': str(play_sound).lower()},
                       {u'expanded': False,
                        u'leaf': True,
                        u"execPy": u"step['PlayScanSound'] = firstLevel.get('myValue')",
                        u'type': u'CHECKBOX'}
                      ]
                       ]],
                  [{u'Barcodes': None},
                   {u'expanded': True, u'leaf': False},
                   [
                     [{u'Code 128': str(c128_filter).lower()},
                     {u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"if 'true' in firstLevel.get('myValue'): step['ScanCodes'].append(firstLevel.get('myText'))",
                      u'type': u'CHECKBOX'}
                     #[]
                    ],
                    [{u'UCC/EAN-128': str(uc128_filter).lower()},
                     {u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"if 'true' in firstLevel.get('myValue'): step['ScanCodes'].append(firstLevel.get('myText'))",
                      u'type': u'CHECKBOX'}
                     #[]
                    ],
                    [{u'Code 39': str(c39_filter).lower()},
                     {u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"if 'true' in firstLevel.get('myValue'): step['ScanCodes'].append(firstLevel.get('myText'))",
                      u'type': u'CHECKBOX'}
                     #self.add_length_filter()
                    ],
                    [{u'Code 93': str(c93_filter).lower()},
                     {u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"if 'true' in firstLevel.get('myValue'): step['ScanCodes'].append(firstLevel.get('myText'))",
                      u'type': u'CHECKBOX'}
                     #self.add_length_filter()
                    ],
                    [{u'Code 11': str(c11_filter).lower()},
                     {u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"if 'true' in firstLevel.get('myValue'): step['ScanCodes'].append(firstLevel.get('myText'))",
                      u'type': u'CHECKBOX'}
                     #self.add_length_filter()
                    ],
                    [{u'Interleaved 2 of 5': str(i2o5_filter).lower()},
                     {u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"if 'true' in firstLevel.get('myValue'): step['ScanCodes'].append(firstLevel.get('myText'))",
                      u'type': u'CHECKBOX'}
                     #self.add_length_filter()
                    ],
                    [{u'Codabar': str(codabar_filter).lower()},
                     {u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"if 'true' in firstLevel.get('myValue'): step['ScanCodes'].append(firstLevel.get('myText'))",
                      u'type': u'CHECKBOX'}
                     #self.add_length_filter()
                    ],
                    [{u'MSI': str(msi_filter).lower()},
                     {u'expanded': False,
                      u'leaf': True,
                      u"execPy": u"if 'true' in firstLevel.get('myValue'): step['ScanCodes'].append(firstLevel.get('myText'));step['actions'][1]='SetScanStep()';FinalizeStep()",
                      u'type': u'CHECKBOX'}
                     #self.add_length_filter()
                    ]]]
                  ]]

  def add_length_filter(self, filter="", length_1="", length_2=""):
    return [[{u'Additional Length Filtering': filter}, {u'leaf':True,
                                                        u'readonly':False,
                                                        u"execPy": u"step['LengthMode'] = secondLevel.get('myValue')",
                                                        u'type':u'EDITBOX',
                                                        u'valLength':True}],
            [{u'Length 1': length_1},
             {u'invisible':True,
              u'readonly':True,
              u"execPy": u"step['Length1'] = secondLevel.get('myValue')",
              u'type':u'EDITBOX'}],
            [{u'Length 2': length_2},
             {u'invisible':True,
              u'readonly':True,
              u"execPy": u"step['Length2'] = secondLevel.get('myValue')",
              u'type':u'EDITBOX'}]]

  @staticmethod
  def deserializeScanRange(valueListRange):
    def remSecIfEq(a):
      a = a.split("-")
      if a[0] == a[1]:
        del a[1]
      return a

    if not valueListRange:
      myrange = ""
    else:
      myrange = map(remSecIfEq, valueListRange)
      for arr in myrange:
        for i in range(len(arr)):
          arr[i] = int(arr[i])
          arr[i] += 1
          arr[i] = str(arr[i])
      myrange = "; ".join(map(lambda a: "-".join(a), myrange))

    #print("deserializeScanRange", myrange)
    return myrange

  @staticmethod
  def extractParams(step, comment, stepParams):

    result_step = None
    params = {}
    display_name = step[0][step[0].keys()[0]].get('step').get('display_name')

    if display_name == None:
      display_name = "ID Input"

    for i in step.keys():
      atom = step[i][step[i].keys()[0]]['atom']


      if atom.get('mode') == 23 and atom.get('name').startswith('IdCodeInit$'):

        params = {
            'displayName': str(display_name),
            'comment': '',
            'timeout': 600,
            'laserOnTime': 3,
            'error_message_after_timeout': 'ID input failed',
            'ScanTrigger': 0,
            'ScanTarget': 0,
            'idCodeDevice': 0,
            'range': '',
            'play_sound': False,
            'attempts': '',
            'display': ''
        }

        if atom['valueList'].get('src') == 3:
            params['idCodeDevice'] = 0
        elif atom['valueList'].get('src') == 2:
            params['idCodeDevice'] = 1
        elif atom['valueList'].get('src') == 5:
            params['idCodeDevice'] = 5


        params['ScanTarget'] = int(atom['valueList']['target'])
        valueListRange = atom['valueList'].get('range')
        params['range'] = ScanStep.deserializeScanRange(valueListRange)


      if atom.get('mode') == 16 and atom.get('type') == 6:
          #print("ID Code STEP --- ", atom['mode'], atom['type'], atom['state'], "VALUE_LIST", atom['valueList'])
          #print("ID Code STEP --- ", atom['mode'], atom['type'], atom['state'])

          scan_codes = {
            'Code128': { 'code': 0, 'key': 'c128_filter'},
            'Code39': {'code': 1, 'key': 'c39_filter'},
            'Code93': {'code': 2, 'key': 'c93_filter'},
            'Code11': {'code': 3, 'key': 'c11_filter'},
            'Interleaved': { 'code': 4, 'key': 'i2o5_filter'},
            'Codabar': {'code': 5, 'key': 'codabar_filter'},
            'Msi': {'code': 6, 'key': 'msi_filter'},
            'UccEan128': {'code': 7, 'key': 'uc128_filter'}
          }

          params['comment'] = comment
          params['ScanTrigger'] = int(atom['valueList']['trigger'])
          params['laserOnTime'] = float(atom['valueList']['laserontime'])
          params['play_sound'] = bool(atom['valueList'].get('play_sound'))

          for code in scan_codes.keys():
            if scan_codes[code]['code'] in atom['valueList']['codes']:
              params[scan_codes[code]['key']] = True
            else:
              params[scan_codes[code]['key']] = False


      #if atom.get('type') == 5:
      #  params['attempts'] = atom.get('attempts')
#

      if atom.get('mode') == 25 and atom['type'] == 4 and atom['state'] == 1 and atom['text'] != '' and atom['name'].startswith('WaitScanStartTrigger'):
        if params['idCodeDevice'] == 0:
            params['display'] = atom['text']

      if atom.get('mode') == 18 and atom['type'] == 4 and atom['name'].startswith('WaitIdCodeTimeout'):
        params['timeout'] = atom['timeout']
        if params['idCodeDevice'] == 1 or params['idCodeDevice'] == 5:
            params['display'] = atom['text']


      if atom['name'].startswith('ScanTimeoutDelay$'):
        params['error_message_after_timeout'] = atom['text']

    stepParams['params'] = params
    result_step = Step(**stepParams)

    return result_step



class Step:
  def __init__(self, name="", column=0, io_next=0, nio_next=0, type=0, id=0, row=0, tmpl=StepTemplate(), params={}):
    step = tmpl.getStepTmpl(name, params)
    type = tmpl.getStepIndex(name)
    self.BRANCH_STEP = 3
    self.TIGHTB_STEP = 4
    self.CORNER_STEP = -1
    self.CONN_STEP = -2
    self.NOK_STEP = -3
    self.NOK_CONN_STEP = -4
    self.data = {
      "Name": name,
      "Column": column,
      "IO_Next": io_next,
      "NIO_Next": nio_next,
      "Type": type,
      "id": id,
      "Row": row,
      "children": []
    }

    self.data["children"] = step.getData()[1] # ["children"]
    self.data.update(step.getData()[0])

  def getData(self):
    return self.data



def getJob(filename):
    job_filename = filename
    import re
    pattern = re.compile(".*job(.*).lua$")
    jobnumber = int(pattern.match(job_filename).groups()[0])

    lua_path="/home/tool/web2py/applications/BS350/config/lua2json/?.lua;" \
    "/home/tool/config/jobs/?.lua;" \
    "/home/tool/config/plctab/?.lua;" \
    "/home/tool/config/jobs/constants.lua;"

    job = luaModule.loadLuaJob(job_filename, lua_path)

    my_dict = {}
    initNode = job['initNode']
    job.pop('initNode', None)
    config = job.pop('config', None)
    atoms_data = job.pop('atoms', None)

    atoms = {}
    for k in atoms_data.keys():
        i_step, i_atom, i_suffix = getIndices(k)
        atoms_data[k]['name'] = k
        if i_step in atoms.keys():
            if i_suffix == "":
                atoms[i_step][i_atom] = {'atom': atoms_data[k]}
            else:
                atoms[i_step][str(i_atom) + i_suffix] = {k: atoms_data[k]}
        else:
            if i_suffix == "":
                atoms[i_step] ={i_atom: {'atom': atoms_data[k]}}
            else:
                atoms[i_step] ={str(i_atom) + i_suffix: {'atom': atoms_data[k]}}

    for k in job.keys():
        i_step, i_atom, i_suffix = getIndices(k)
        #typeStr, modeStr = getAtomTypeMode(job[k]['atom']['type'], job[k]['atom']['mode'])
        #print("job", k, i_step, i_atom, i_suffix, typeStr, modeStr)
        job[k]['atom'] = atoms[i_step][i_atom]['atom']
        if i_step in my_dict.keys():
            my_dict[i_step][i_atom] = {k: job[k]}
        else:
            my_dict[i_step] = {i_atom: {k: job[k]}}



    for k in job.keys():
      n, i = k.split("$")
      i_step, i_atom = i.split("A")
      i_step = int(i_step)
      i_atom = int(i_atom)
      if i_step in my_dict.keys():
        my_dict[i_step][i_atom] = {k: job[k]}
      else:
        my_dict[i_step] = {i_atom: {k: job[k]}}

    tmpl = StepTemplate()
    step_keys = sorted(my_dict.keys())
    res = Job(slot=jobnumber, initNode=initNode)
    step_id = 0
    # get all steps of a job
    resultSteps = []
    for step_e in step_keys:
        step_id += 1
        # get the step name
        stepTypeSrc = my_dict[step_e][0][my_dict[step_e][0].keys()[0]]['step']['name']
        row = my_dict[step_e][0][my_dict[step_e][0].keys()[0]]['step']['row']-1
        column = my_dict[step_e][0][my_dict[step_e][0].keys()[0]]['step']['column']-1
        io_next = my_dict[step_e][0][my_dict[step_e][0].keys()[0]]['step']['io_next']
        nio_next = my_dict[step_e][0][my_dict[step_e][0].keys()[0]]['step']['nio_next']
        comment = my_dict[step_e][0][my_dict[step_e][0].keys()[0]]['step']['comment']

        # get all atoms of a step
        #print("KEYS FOR STEP:", sorted(d[step_e].keys()))
        currentStep = {}
        resultSteps.append(currentStep)
        stepParams = {
            'tmpl': tmpl,
            'type': stepTypeSrc,
            'id': step_id,
            'io_next': io_next,
            'nio_next': nio_next,
            'name': stepTypeSrc,
            'column': column,
            'row': row
        }
        if stepTypeSrc == "Start":
            step = StartStep.extractParams(my_dict[step_e], initNode, config, comment, stepParams)
            if step:
                res.addStep(step)
        elif stepTypeSrc == "Single Program":
            step = ProgramStep.extractParams(my_dict[step_e], comment, stepParams)
            if step:
                res.addStep(step)
        elif stepTypeSrc == "Wait":
            step = WaitStep.extractParams(my_dict[step_e], comment, stepParams)
            if step:
                res.addStep(step)
        elif stepTypeSrc == "ID Input" or stepTypeSrc == "ID Code":
            step = ScanStep.extractParams(my_dict[step_e], comment, stepParams)
            if step:
                res.addStep(step)
        elif stepTypeSrc == "End":
            step = EndStep.extractParams(my_dict[step_e], comment, stepParams)
            if step:
                res.addStep(step)

      # DEBUG print loop
      # for i in sorted(d[step_e].keys()):
      #   atom = d[step_e][i][d[step_e][i].keys()[0]]['atom']
      #   typeStr, modeStr = getAtomTypeMode(atom['type'], atom['mode'])
      #   print("---- STEP: " + str(step_e) + "/" + str(i) + " '" + stepTypeSrc + "' ATOM: name: '" + atom['name']
      #         + "' atom type: " + typeStr + " (" + str(atom['type']) + ") mode: " + modeStr + " (" + str(atom['mode'])
      #         + ") state: " + str(atom['state']))

    data = res.getData()
    return data


def resolve_refs(job):
  initNode = job['initNode']
  job.pop('initNode', None)
  config = job.pop('config', None)
  atoms_data = job.pop('atoms', None)
  atoms_dict = {}
  for k in atoms_data.keys():
    #print k, atoms_data[k]
    #print atoms_data[k]['atom_reference_pointer']
    atoms_data[k]['key'] = k
    atoms_dict[atoms_data[k]['atom_reference_pointer']] = atoms_data[k]
  for k in sorted(job.keys()):
    #print k, job[k]['atom']['atom_reference_pointer']
    job[k]['atom']['data'] = atoms_dict[job[k]['atom']['atom_reference_pointer']]
  return atoms_data, config, initNode


def getMasterJob():

    lua_path = "/home/tool/web2py/applications/BS350/config/lua2json/?.lua;" \
        "/home/tool/config/jobs/?.lua;" \
        "/home/tool/config/plctab/?.lua;" \
        "/home/tool/config/jobs/constants.lua;"

    root_path = '/home/tool/config/jobs/'
    column = 0
    step_id = 1

    conversion = Conversion()

    init = luaModule.loadLuaJob(os.path.join(root_path, 'init.lua'), lua_path)
    atoms_data, config, initNode = conversion.resolve_refs(init)
    master = MasterJob(initNode)

    # Declare Opmodes
    opmodes = luaModule.loadLuaOpModes(os.path.join(root_path, 'opmodes_declare.lua'), lua_path)
    atoms_data = opmodes.get('atoms')

    # map active column to runmode currently col 0 = automatic -- col 1 = manual
    active_col = 1 if opmodes.get('runmode') == 2 else 0
    sel_step = MasterJobSelectionStep(active_col)
    master.appendStep(sel_step)

    automatic_mode = atoms_data.get("$DeclareOperationMode0")
    #currently not used
    #select_mode = atoms_data.get("$DeclareOperationMode1")
    manual_mode = atoms_data.get("$DeclareOperationMode2")

    found_dirs = [d[0] for d in os.walk(root_path) if os.listdir(d[0])]

    lua_files = set(['init.lua', 'idle_en.lua', 'idle_cw.lua'])

    for current_dir in found_dirs:

        if not lua_files.issubset(set(os.listdir(current_dir))):
            continue

        row = 2
        init = luaModule.loadLuaJob(os.path.join(current_dir, 'init.lua'), lua_path)
        atoms_data, config, initNode = conversion.resolve_refs(init)

        trig = {"HMI": "false", "Open Protocol": "false", "BMS Signal ManOp": "false"}

        displayTime = initNode.get('displayTime', "1")
        startStep = MasterJobStartStep(idcodesrc=-1, delIdcode=-1, trigger_src=trig)
        for k in sorted(init.keys()):
            mytype = init[k]['atom']['data']['type']
            mode = init[k]['atom']['data']['mode']
            dest = init[k]['atom']['data']['dest']
            state = init[k]['atom']['data'].get('state')

            if Types[mytype] == 'TypeTriggerOut' and OutModes[mode] == 'TriggerOutIdCodeSrc':
                opmode =  manual_mode if column == 1 else automatic_mode
                prg = str(opmode.get('valueList').get('prgselect')).lower()
                job = str(opmode.get('valueList').get('jobselect')).lower()
                op = '0' if column == 0 else '2'

                if column > 0:
                    for trigger in opmode.get('valueList').get('triggers'):
                        if trigger.get('active'):
                            trig[operation_mode_trigger.get(trigger.get('id'))] = "true"

                startStep = MasterJobStartStep(id=step_id, row=row, column=column, idcodesrc=dest, delIdcode=state, display_time=displayTime, op_mode=op, trigger_src=trig, prg_sel=prg, job_sel=job)

        master.appendStep(step=startStep)
        step_id += 1
        row += 1

        timeout1 = initNode.get('idcode_timeout1', 600)
        timeout2 = initNode.get('idcode_timeout2', 600)
        display_text1 = initNode.get('display_text1', "")
        display_text2 = initNode.get('display_text2', "")

        timeout = [timeout1, timeout2]
        display_text = [display_text1, display_text2]

        if column == 0 and initNode.get('useIdleEn') == 1:
            idle_cw = luaModule.loadLuaJob(os.path.join(current_dir, 'idle_en.lua'), lua_path)
        else:
            idle_cw = luaModule.loadLuaJob(os.path.join(current_dir, 'idle_cw.lua'), lua_path)

        atoms_data, config, initNode = conversion.resolve_refs(idle_cw)

        scanstepcount = 0
        attempts = 3
        errortext = "ID input failed"
        noIdCodeRange = False
        idcode = ['0-255']
        id_src = 0
        valueList_Scanner = {}
        valueList_IDCode = {}
        name1 = initNode.get('id_input_name1', "")
        name2 = initNode.get('id_input_name2', "")
        comment1 = initNode.get('id_input_comment1', "")
        comment2 = initNode.get('id_input_comment2', "")

        general = []
        general.append({"name": name1, "comment": comment1})
        general.append({"name": name2, "comment": comment2})

        sort_order = ['StartWithEnable', 'SetEnableStart', 'StartWithoutEnable', 'InitIDCode', 'InitScanner', 'DisplayNoScanner', 'DisplayScannerNotActive',
                      'WaitForScanInitAck', 'WaitForScanStartTrigger', 'Scanning', 'ScanTimeoutDelay', 'WaitIdCodeResult', 'RepeatTimeout', 'RepeatTimeoutDelay', 'RepeatCodeNotSupported',
                      'RepeatCodeNotSupportedDelay', 'RepeatCodeNotActive', 'RepeatCodeNotActiveDelay', 'RepeatCodeNoAssignment', 'RepeatCodeNoAssignmentDelay',
                      'SetNewJobNr', 'UnsetEnableJob',
                      'DisplayNewJobNr', 'DisplayNewJobNrDelay', 'JobNrFinalOK', 'SetNewPrgNr', 'ResetBatchCounter', 'SetEnablePrg', 'DisplayNewPrgNr', 'DisplayNewPrgNrDelay',
                      'DisplayNewIDCode', 'DisplayNewIDCodeDelay', 'ScanFinalOK',
                      'InitIDCode1', 'InitScanner1', 'DisplayNoScanner1', 'DisplayScannerNotActive1', 'ScanTimeoutDelay1',
                      'WaitForScanInitAck1', 'WaitForScanStartTrigger1', 'Scanning1', 'WaitIdCodeResult1', 'RepeatTimeout1', 'RepeatTimeoutDelay1', 'RepeatCodeNotSupported1',
                      'RepeatCodeNotSupportedDelay1', 'RepeatCodeNotActive1', 'RepeatCodeNotActiveDelay1', 'RepeatCodeNoAssignment1', 'RepeatCodeNoAssignmentDelay1',  'DisplayNewIDCode', 'DisplayScannerNotActive1',
                      'DisplayNewIDCodeDelay', 'ScanFinalOK', 'InitIDCode2', 'InitScanner2', 'DisplayNoScanner2', 'DisplayScannerNotActive2','ScanTimeoutDelay2',
                      'WaitForScanInitAck2', 'WaitForScanStartTrigger2', 'Scanning2', 'WaitIdCodeResult2', 'RepeatTimeout2', 'RepeatTimeoutDelay2', 'RepeatCodeNotSupported2',
                      'RepeatCodeNotSupportedDelay2', 'RepeatCodeNotActive2', 'RepeatCodeNotActiveDelay2', 'RepeatCodeNoAssignment2', 'RepeatCodeNoAssignmentDelay2', 'SetNewJobNr', 'UnsetEnableJob',
                      'DisplayNewJobNr', 'DisplayNewJobNrDelay', 'JobNrFinalOK', 'SetNewPrgNr', 'ResetBatchCounter', 'SetEnablePrg', 'DisplayNewPrgNr', 'DisplayNewPrgNrDelay', 'DoNokResult']

        ordered = OrderedDict()

        try:
            for k in sort_order:
                if idle_cw.get(k) != None:
                    ordered[k] = idle_cw.get(k)
        except KeyError: pass

        myScanCodes = {}
        for k in (ordered.keys()):
            if ordered[k].get('atom'):
                mytype = ordered[k]['atom']['data']['type']
                mode = -1

                if ordered[k]['atom']['data'].get('mode'):
                    mode = ordered[k]['atom']['data']['mode']

                scanStep = None

                if ordered[k]['atom']['data'].get('key').startswith('$ScanTimeoutDelay'):
                    errortext = ordered[k]['atom']['data']['text']

                if Types[mytype] == 'TypeTriggerOut' and OutModes[mode] == 'TriggerOutModeIdCodeInit' and ordered[k]['atom']['data'].get('key').startswith('$IdCodeInit'):
                    valueList_IDCode = ordered[k]['atom']['data']['valueList']


                    #-------------------------------------------------------------------------------------------------------
                    # SOURCE SELECTION
                    # 0 == SCANNER           (scanner)
                    # 1 == OPEN PROTOCOL     (openprotocol)
                    # 5 == VW XML            (vwxml)
                    #-------------------------------------------------------------------------------------------------------

                    if valueList_IDCode.get('src') == 2:
                        id_src = 1
                    elif valueList_IDCode.get('src') == 3:
                        id_src = 0
                    elif valueList_IDCode.get('src') == 5:
                        id_src = 5


                if Types[mytype] == 'TypeTriggerOut' and OutModes[mode] == 'TriggerOutModeScanInit':
                    scanstepcount += 1
                    valueList_Scanner = ordered[k]['atom']['data']['valueList']
                    #text = idle_cw[k]['atom']['data']['text']

                    myScanCodes = {k: False for k in reverseScanCodes.keys()}
                    for i in valueList_Scanner['codes']:
                        if i in scanCodes:
                            myScanCodes[scanCodes[i]] = True

                    myScanCodes = {k: str(v).lower() for k, v in myScanCodes.items()}

                    if valueList_IDCode.get('range') is None:
                        valueList_IDCode['range'] = (1, 256)
                    if valueList_IDCode.get('idcode_range') is None:
                        idcode = ['0-255']
                        noIdCodeRange = True


                if ordered[k]['atom']['data'].get('key').startswith('$TriggerInGrp'):

                    if valueList_IDCode.get('extjobctrl') is not None:
                        extjobctrl = bool(valueList_IDCode.get('extjobctrl'))
                    else:
                        extjobctrl = False

                    if valueList_IDCode['target'] == 4 and not noIdCodeRange:
                        target = 5
                        range = valueList_IDCode.get('range')
                        idcode_range = valueList_IDCode.get('idcode_range')
                    elif valueList_IDCode.get('target') == 1:
                        target = valueList_IDCode.get('target')
                        range = idcode
                        idcode_range = valueList_IDCode.get('range')
                    else:
                        target = valueList_IDCode.get('target')
                        range = valueList_IDCode.get('range')
                        idcode_range = idcode

                    scanStep = MasterJobScanStep(name=general[scanstepcount-1]['name'],
                                                 comment=general[scanstepcount-1]['comment'],
                                                 target=target,
                                                 trigger=valueList_Scanner.get('trigger', 2),
                                                 source=id_src,
                                                 text=errortext,
                                                 play_sound=bool(valueList_Scanner.get('play_sound', False)),
                                                 timeout=timeout[scanstepcount-1],
                                                 scanCodes=myScanCodes,
                                                 range=ScanStep.deserializeScanRange(range),
                                                 id=step_id,
                                                 row=row,
                                                 column=column,
                                                 attempts=attempts,
                                                 display_text=display_text[scanstepcount-1],
                                                 laserOnTime=valueList_Scanner.get('laserontime',3),
                                                 id_range=ScanStep.deserializeScanRange(idcode_range),
                                                 extjobctrl=extjobctrl)

                if scanStep:
                    master.appendStep(scanStep)
                    step_id += 1
                    row += 1

        master.appendStep(MasterJobEndStep(id=step_id, row=row, column=column))
        step_id += 1
        column += 1

    return master.data


