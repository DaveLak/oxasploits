# -*- coding: cp1252 -*-
'''
Created on 20.07.2012

@author: sth2mt
'''
from ctypes import *
import pickle as pickle
#CDLL, c_char_p, c_ubyte, c_ushort, pointer
from fcntl import ioctl
import struct as struct
#import copy as copy
import FertigungsTest.Hardware.Typschild as Typschild


def ioshift(_direction,_type,_nr,_size):

    wert = (_direction<<30) + (_size<<16) + (_type<<8) + _nr
    #print("_direction<<30 = 0x%x + _size<<16=0x%x + _type<<8=0x%x + nr=0x%x = 0x%x"%(_direction<<30,_size<<16,_type<<8,_nr,wert))
    #print("wert=0x%x id typ=%i id=%i"%(wert,_type,id(_type)))
    
    return wert
    
def IO(type,nr):

    return ioshift(0,type,nr,0)
    

def IOR(type,nr,size):
    
    return ioshift(2,type,nr,size)
    
_KALIB_TAB_SIZE = 4096

class st_CalibTab(Structure):
    _fields_ = [("Crc", c_ushort),
                ("Nennmoment", c_int),
                ("KalTab", c_double *  _KALIB_TAB_SIZE)]



###Ãƒâ€žÃƒâ€žÃƒâ€ž
class Treiber(object):
    '''
    classdocs
    '''
    # Achtung dies ist Pseudo Singleton -> variablen werden statisch verwendet. Aufgeraumt wird erst wenn alle instanzen weg sindwird nur einmal instaniiert !!!!
    ObjCount = 0
    _Thread_name = "MesswerteInterface"
    stout = False
    fMWG = None
    uchar = 5
    ''' MWG DEFINES fuer iocntrl '''
    MWG_IOC_MAGIC = ord('G')
    MWG_IOCTSETWM = IO( MWG_IOC_MAGIC, 1)
    MWG_IOCTRESETWM = IO(MWG_IOC_MAGIC, 2)
    
    MWG_IOCTSETCAL = IO( MWG_IOC_MAGIC, 3)
    MWG_IOCTRESETCAL = IO(MWG_IOC_MAGIC, 4)
    MWG_IOCTRESETMWG = IO(MWG_IOC_MAGIC, 5)
    MWG_IOCGETSTATUS = IOR(MWG_IOC_MAGIC, 6, 1)
    MWG_IOCTSETMODE = IO(MWG_IOC_MAGIC, 7)
    MWG_IOCTRESETMODE = IO(MWG_IOC_MAGIC, 8)
    MWG_IOCTSETWRST = IO(MWG_IOC_MAGIC, 9)
    MWG_IOCTRESETWRST= IO(MWG_IOC_MAGIC, 10)
    MWG_IOCTRUNTIMER = IO(MWG_IOC_MAGIC, 11)
    MWG_IOCTSTOPTIMER = IO(MWG_IOC_MAGIC, 12)
    MESSWERT_CLOCK_RATE_HZ = 1000
    MESSWERT_CLOCK_RATE = 1000000 #in ns
    MESSWERT_CLOCK_RATE_S  =  1.0 / MESSWERT_CLOCK_RATE_HZ
    MESSWERT_CLOCK_RATE_MS = 1.0 / MESSWERT_CLOCK_RATE_HZ * 1000
    MESSWERT_CLOCK_RATE_US = 1.0 / MESSWERT_CLOCK_RATE_HZ * 1000000
    
    WINKEL_UEBERLAUF_VAL = 65536

    sDevMWG = "/dev/mwm"
    CALIB_TAB_FILE = "/home/tool/config/CalibTabTst.inf"
    CALIB_TAB_OFFSET_FILE = "/home/tool/config/CalibTabOffsetTst.inf"
    KALIB_TAB_SIZE = _KALIB_TAB_SIZE
    o_CalibTab = st_CalibTab()
    POS_MOMENT = 0

    O_Typschild = None
    b_IsCalibtabOffsetSet = False

    # Schrauber Parameter
    AnzahlWinkelPulse = 24
    Gebernennmoment = None
    Abtriebuntersetzung = None
    Abtriebwirkungsgrad = None
    NennmomentSpindel = None
    Getriebeuntersetzung = None
    bReady = False
    b_InitTimeBase = False
    LastTimeStamp = 0
    StartTimeStamp = 0
    NrSamplesToSkip = 0
    b_InitTimeBase = False
    b_Init = False
    WinkelAlt = 0
    WinkelSumme = 0
    WinkelDelta = 0
    CalibTabOffset = 0
    Spin = 1
    b_SrbMode = False
    
    




    def __init__(self):
        '''
        Constructor
        '''
        Treiber.ObjCount += 1
        self.printf("%i.Construktor %s Anzahl" % (Treiber.ObjCount,Treiber._Thread_name))
        try:
            if Treiber.ObjCount < 2: 
                
                if Treiber.O_Typschild == None:
                    Treiber.O_Typschild = Typschild.Treiber()
                
                # Dev mwm oeffnen
                self.f_openMWG()        
                
                self.printf ("%s.__init__ )" % (Treiber._Thread_name))   
                # IO_ Reset Messwertgeber
                val=(Treiber.MWG_IOCTRESETMWG)
                self.printf ("%s.__init__ Treiber.fMWG.fileno()=0x%x" % (Treiber._Thread_name,Treiber.fMWG.fileno()))
                ioctl(Treiber.fMWG.fileno(), val )
                self.printf ("%s.__init__ fcntl.ioctl(Treiber.fMWG.fileno()"%Treiber._Thread_name )

                Treiber.b_IsCalibtabOffsetSet = True
            
                Treiber.bReady = True
                Treiber.LastTimeStamp = 0
                Treiber.StartTimeStamp = 0
                Treiber.NrSamplesToSkip = 1
                Treiber.b_InitTimeBase = False
                Treiber.b_Init = False
                #Treiber.CALIB_TAB_FILE = "/home/tool/config/CalibTab%s.inf"%Treiber.O_Typschild.O_WLAN.f_GetMACString()
                #Treiber.CALIB_TAB_OFFSET_FILE = "/home/tool/config/CalibTabOffset%s.inf"%Treiber.O_Typschild.O_WLAN.f_GetMACString()
                
                # Wenn keine Clibriertabelle vorhanden für Endpruefung eine separate Anlegen
                #if not self.f_ReadCalibTab():
                #    self.f_GenerateCalibTab()
                # Kalibriertabelle immer anlegen
                self.f_GenerateCalibTab()

                # Wenn keine Offset-Datei vorhanden für Endpruefung eine separate Anlegen
                #if not self.f_ReadCalibTabOffset():
                #    self.f_GenerateCalibTabOffset()
                #Offset-Datei immer anlegen
                self.f_GenerateCalibTabOffset()
               

        except Exception,e:
            self.printf("%s.__init__() Error open %s %s"%(Treiber._Thread_name,Treiber.sDevMWG, e))
            
        pass
        
            
    def __del__(self):
        
        '''
        Destructor
        '''
        self.printf("%i Destruktor %s" % (Treiber.ObjCount,Treiber._Thread_name))
            
        if Treiber.ObjCount == 1:
            del(Treiber.O_Typschild)
            Treiber.O_Typschild=None
            self.printf("Reste aufraumen")
            self.f_SetSrbMod(False)
            if Treiber.fMWG != None:
                if not Treiber.fMWG.closed:
                    Treiber.fMWG.close()
                Treiber.fMWG = None    
                Treiber.bReady = False
                Treiber.b_InitTimeBase = False
                
        if Treiber.ObjCount > 0:
            Treiber.ObjCount -= 1
            
        pass


    def f_GetMesswerte(self):
        Winkel = 0
        Moment = 0
        TimeDelta = 0

        if Treiber.Abtriebuntersetzung==None:
            self.readSpindleParams()

        (status,tmpMoment,tmpWinkel,timestamp) = self.f_readMWG()
        if status!=0:
            return False,Moment,Winkel,TimeDelta
            
        
        if Treiber.NrSamplesToSkip>0 :
            self.printf ("NrSamplesToSkip=%i>0\n"%Treiber.NrSamplesToSkip)
            Treiber.NrSamplesToSkip=-1
            return False,Moment,Winkel,TimeDelta
        
        #self.printf("Epld_CL M: %d, W: %d, T: %d\n"% (tmpMoment,tmpWinkel,timestamp));


        if Treiber.b_InitTimeBase==False:
            Treiber.LastTimeStamp = timestamp
            Treiber.StartTimeStamp = timestamp
            SampleTime = 0
            Treiber.b_InitTimeBase = True
        
        else :
            #Werte sind initialisiert
            TimeDelta = timestamp-Treiber.LastTimeStamp
            #if TimeDelta >= 500/Treiber.MESSWERT_CLOCK_RATE_MS:
            if TimeDelta >= 500/Treiber.MESSWERT_CLOCK_RATE_MS: # 500ms sehr gross da in Pruefsoftware nicht echzeitfaehig
                #Delata alt neu zu groß wir haben geschlafen und das muss bestraft werden
                self.printf("%s::f_GetMesswerte->lost Sample: t(new): %ld, t(old): %ld, delta: %ld\n"%(Treiber._Thread_name,timestamp,self.LastTimeStamp,TimeDelta))
                Treiber.b_InitTimeBase = False
                SampleTime = 0
                return False,Moment,Winkel,TimeDelta
            else:
                #self.printf("TimeDelta=%i"%TimeDelta)
                SampleTime = timestamp-Treiber.StartTimeStamp
                Treiber.LastTimeStamp = timestamp
            
        #Moment aus Tabelle
        Moment = Treiber.o_CalibTab.KalTab[tmpMoment+self.CalibTabOffset]*Treiber.Abtriebuntersetzung*Treiber.Abtriebwirkungsgrad
        
        #Winkel behandeln
        if Treiber.b_Init:
            Treiber.b_Init=False
            Treiber.WinkelAlt = tmpWinkel
            Treiber.WinkelSumme = 0
        
        EpldWinkel = tmpWinkel
        WinkelDelta = EpldWinkel-Treiber.WinkelAlt

        #self.printf("Winkel_Delta: %d\n"%WinkelDelta)
        if WinkelDelta>0:
            #zunehmende Winkelwerte
            if Treiber.Spin == -1:
                #positives Delta bei negativer Drehrichtung Zahlenüberlauf checken?
                if WinkelDelta>60000:
                    #Zahlenüberlauf
                    self.printf("%s::f_GetMesswerte->Zahlenueberlauf+ WinkelDelta: %ld\n"%(Treiber._Thread_name,WinkelDelta))
                    WinkelDelta = WinkelDelta-0xFFFF;
                    self.printf("%s::f_GetMesswerte->Zahlenueberlauf+ WinkelDelta: %ld\n"%(Treiber._Thread_name,WinkelDelta))
                
                else:
                    #Drehrichtungsumkehr
                    Treiber.Spin = 1
                
            
            else:
                Treiber.Spin = 1
            
            #printf("i_Spin: %d\n",i_Spin);
        
        elif (WinkelDelta<0):
            #abnehmende Winkelwerte
            if Treiber.Spin == 1:
                if WinkelDelta<(-60000):
                    #Zahlenüberlauf
                    self.printf("%s::f_GetMesswerte->Zahlenueberlauf- WinkelDelta: %ld\n"%(Treiber._Thread_name,WinkelDelta))
                    WinkelDelta = 0xFFFF + WinkelDelta
                    self.printf("%s::f_GetMesswerte->Zahlenueberlauf- WinkelDelta: %ld\n"%(Treiber._Thread_name,WinkelDelta))
                
                else:
                    #Dann doch Drehrichtungsumkehr
                    Treiber.Spin=-1
                
            
            else:
                Treiber.Spin = -1
            
        
        if Treiber.Spin==1:
            #positive Drehrichtung
            if WinkelDelta>=0:
                Treiber.WinkelSumme+=WinkelDelta
            
            else:
                Treiber.WinkelSumme+=(Treiber.WINKEL_UEBERLAUF_VAL+WinkelDelta)
            
        
        else:
            #negative Drehrichtung
            if WinkelDelta<=0:
                Treiber.WinkelSumme-=WinkelDelta
            
            else:
                Treiber.WinkelSumme+=(Treiber.WINKEL_UEBERLAUF_VAL-WinkelDelta)
            
        
        #if abs(WinkelDelta)!=0:
            #self.printf("alt: %x, neu: %x, delta: %d, Summe: %ld\n"%( Treiber.WinkelAlt,EpldWinkel,WinkelDelta,Treiber.WinkelSumme));
        
        Winkel = (((Treiber.WinkelSumme * 360.0) / Treiber.AnzahlWinkelPulse) / Treiber.Abtriebuntersetzung) / Treiber.Getriebeuntersetzung
        Treiber.WinkelAlt = EpldWinkel
        
        #self.printf("f_GetMesswerte( Moment=%i, Winkel=%i):\n"%( Moment,Winkel))
        
        return True,Moment,Winkel,TimeDelta
        
        pass
 
    def readSpindleParams(self):
        ''' Spindelwerte bestimmen'''
        s_Brc_Typschild = Treiber.O_Typschild.ReadBrcStatParFromEeprom()
        Treiber.Getriebeuntersetzung = Treiber.O_Typschild.getStatValue(s_Brc_Typschild,"Getriebeuntersetzung")
        Treiber.Abtriebuntersetzung = Treiber.O_Typschild.getStatValue(s_Brc_Typschild,"Abtriebuntersetzung")
        Treiber.Abtriebwirkungsgrad = Treiber.O_Typschild.getStatValue(s_Brc_Typschild,"Abtriebwirkungsgrad")
        Treiber.Gebernennmoment = Treiber.O_Typschild.getStatValue(s_Brc_Typschild,"Gebernennmoment")
        Treiber.NennmomentSpindel = Treiber.O_Typschild.getStatValue(s_Brc_Typschild,"Nennmoment") 
        self.printf("%s.__init__ Getriebeuntersetzung=%3.2f Abtriebuntersetzung=%3.2f Abtriebwirkungsgrad=%1.3f Gebernennmoment=%2.1f NennmomentSpindel=%2.1f " % (Treiber._Thread_name,Treiber.Getriebeuntersetzung,Treiber.Abtriebuntersetzung,Treiber.Abtriebwirkungsgrad,Treiber.Gebernennmoment,Treiber.NennmomentSpindel))
        return True            

    def f_ResetWinkel(self):
        Treiber.b_Init = True
        return True

    def f_ResetNullpunkt(self):
        Treiber.b_Init = True
        self.NrSamplesToSkip = 1
        return True
    
    def f_getSpindelNennmoment(self):
        if Treiber.NennmomentSpindel==None:
            self.readSpindleParams()
        return Treiber.NennmomentSpindel        
    
        
    def f_SetSrbMod(self,b_Smod):
        try:
            Treiber.b_InitTimeBase = False
            if b_Smod:
                mode = Treiber.MWG_IOCTRUNTIMER
                self.f_ResetWinkel()
            else:
                mode = Treiber.MWG_IOCTSTOPTIMER
            
            if self.f_openMWG()==False:
                return False
            
            ioctl(Treiber.fMWG,mode,Treiber.MESSWERT_CLOCK_RATE_HZ)
            Treiber.b_SrbMode = b_Smod
            return True
        except Exception,e:
            self.printf("%s.f_SetSrbMod() Error ioctl %s %s"%(Treiber._Thread_name,Treiber.sDevMWG, e))
            return False


    def f_GenerateCalibTab(self):
        self.printf("f_GenerateCalibTab()")
        #2048 = 0
        d_AD_NennMoment = 1500.0
        if Treiber.Gebernennmoment==None:
            self.readSpindleParams()

        d_Faktor = Treiber.Gebernennmoment/d_AD_NennMoment;

        self.printf("f_GenerateCalibTab()->d_NennMoment: %f, d_AD_NennMoment: %f d_Faktor=%f\n"%(Treiber.Gebernennmoment,d_AD_NennMoment,d_Faktor))

        Treiber.o_CalibTab.NennMoment = Treiber.Gebernennmoment

        for index in range (0, Treiber.KALIB_TAB_SIZE , 1):
            Treiber.o_CalibTab.KalTab[index]= (index-(Treiber.KALIB_TAB_SIZE/2-1))*d_Faktor
            if (Treiber.o_CalibTab.KalTab[index]==0) \
            or(Treiber.o_CalibTab.KalTab[index]==Treiber.o_CalibTab.NennMoment) \
            or(Treiber.o_CalibTab.KalTab[index]==(-Treiber.o_CalibTab.NennMoment) \
            or(index==0) \
            or(index==4090)):
                self.printf("[%04i]=%f"%(index,Treiber.o_CalibTab.KalTab[index]))
            #/*if(this->z_o_CalibTab->a_d_Tab[ui16_Index]==0||
            #   this->z_o_CalibTab->a_d_Tab[ui16_Index]==d_NennMomentWelle*d_Faktor||
            #   this->z_o_CalibTab->a_d_Tab[ui16_Index]==d_NennMomentWelle*-1.0*d_Faktor){
            #    printf("Index: %d, d/A VAl: %d Val: %f\n",ui16_Index,(ui16_Index-(KALIB_TAB_SIZE/2-1)),this->z_o_CalibTab->a_d_Tab[ui16_Index]);
            #}*/
        
        Treiber.o_CalibTab.Crc = 0
        self.f_SaveCalibTab(Treiber.o_CalibTab)
        
        return True
    
    def f_ReadCalibTab(self):
        try:

            returnwert = True
            self.printf("f_ReadCalibTab(%s) sizeof(st_CalibTab()%i"%(Treiber.CALIB_TAB_FILE,sizeof(st_CalibTab)))

            File = open(Treiber.CALIB_TAB_FILE, "rb")
            Treiber.o_CalibTab=pickle.loads(File.read())

            #st_CalibTab=pickle.load(File)
            #st_CalibTab().Crc=File.read(4)
            #st_CalibTab().Crc=File.read(sizeof(st_CalibTab().Crc))
            #st_CalibTab().Crc=File.Nennmoment(sizeof(st_CalibTab().Nennmoment))
            for index in range(0,4096,1):
                if (Treiber.o_CalibTab.KalTab[index]==0) \
                or(Treiber.o_CalibTab.KalTab[index]==Treiber.o_CalibTab.NennMoment) \
                or(Treiber.o_CalibTab.KalTab[index]==(-Treiber.o_CalibTab.NennMoment) \
                or(index==0) \
                or(index==4095)):
                    self.printf("[%04i]=%f"%(index,Treiber.o_CalibTab.KalTab[index]))
            #File.write("%i"%st_CalibTab().Crc)
            #for i in st_CalibTab().KalTab:
            #    File.write("%f"%i)
        
            File.close()
            self.printf("f_ReadCalibTab() Ende")

            return returnwert
        except Exception,e:
            self.printf("%s.f_ReadCalibTab() Error ->%s %s"%(Treiber._Thread_name,Treiber.CALIB_TAB_FILE, e))
            return False
        
        return False

    def f_SaveCalibTab(self,st_CalibTab):
        try:

            returnwert = True

            self.printf("f_SaveCalibTab(%s)"%(Treiber.CALIB_TAB_FILE))

            File = open(Treiber.CALIB_TAB_FILE, "wb")
            File.write(pickle.dumps(st_CalibTab))
            #File.write("%i;"%st_CalibTab().Crc)
            #File.write("%i;"%st_CalibTab().Nennmoment)
            #for i in st_CalibTab().KalTab:
            #    File.write("%f;"%i)
        
            File.close()
            self.printf("f_SaveCalibTab() Ende")

            return returnwert
        except Exception,e:
            self.printf("%s.f_SaveCalibTab() Error ->%s %s"%(Treiber._Thread_name,Treiber.CALIB_TAB_FILE, e))
            return False

    
    def f_GenerateCalibTabOffset(self):
        self.f_SetSrbMod(True)
        i_MaxTrys= 10
        Moment=2048
        Winkel = 0
        Timestamp=0
        status=0
        Summe=0
        Count=0
        while Count<100:
            
            
            (status,Moment,Winkel,Timestamp) = self.f_readMWG()
            if status:
                i_MaxTrys-=1
                if i_MaxTrys == 0 :
                    self.printf("%s.f_CalcCalibtabOffset() bad epld status %i, n=%d"%(Treiber._Thread_name,status,Count))
                    self.f_SetSrbMod(False)
                    return False
            else :
                #self.printf("%s.f_CalcCalibtabOffset M: %d\n"%(Treiber._Thread_name,Moment))
                #self.printf("Abs: %d\n",abs(Treiber.KALIB_TAB_SIZE/2 -a_i16_Messwerte[Treiber.POS_MOMENT]))
                Summe+=Moment
                #printf("M:  %d W: %d T: %ld, summe: %ld\n", o_Messwerte.i16_Moment, o_Messwerte.i16_Winkel,o_Messwerte.ul_TimeStamp,ui32_Summe);
                Count+=1
        
        self.f_SetSrbMod(False)
        self.printf("%s.f_CalcCalibtabOffset() Mittel: %ld"%(Treiber._Thread_name,Summe/(Count)))
        Treiber.CalibTabOffset = Treiber.KALIB_TAB_SIZE/2-Summe/(Count)
        self.printf("%s.f_CalcCalibtabOffset()->Offset: %d"% (Treiber._Thread_name,Treiber.CalibTabOffset))
        self.f_SaveCalibTabOffset()   
        return True
    
    def f_SaveCalibTabOffset(self,CalibTabOffset=None):
        try:
            Bytes=0
            returnwert = True
            if CalibTabOffset!=None:
                Treiber.CalibTabOffset=CalibTabOffset
            
            
            a_c_Buf= "%d"%Treiber.CalibTabOffset

            self.printf("f_SaveCalibTabOffset()->%s\n"%a_c_Buf)

            File = open(Treiber.CALIB_TAB_OFFSET_FILE, "w")
            File.write(a_c_Buf)
            Bytes= File.tell()
            if  Bytes !=len(a_c_Buf):
                self.printf("%s.f_SaveCalibTabOffset() Error write->%s Bytes(%d)!=len(ac_buf)(%i)"%(Treiber._Thread_name,Treiber.CALIB_TAB_OFFSET_FILE,Bytes,len(a_c_Buf)))
                File.close()
                returnwert = False
        
            File.close()
            return returnwert
        except Exception,e:
            self.printf("%s.f_SaveCalibTabOffset() Error open->%s %s"%(Treiber._Thread_name,Treiber.CALIB_TAB_OFFSET_FILE, e))
            return False

    def f_ReadCalibTabOffset(self):
        try:
            returnwert = True
            
            
            self.printf("f_ReadCalibTabOffset()")

            File = open(Treiber.CALIB_TAB_OFFSET_FILE, "r")
            a_c_Buf = File.read()

            Treiber.CalibTabOffset=int(a_c_Buf)
            self.printf("%d"%Treiber.CalibTabOffset)
        
            File.close()
            return returnwert
        except Exception,e:
            self.printf("%s.f_ReadCalibTabOffset() Error open->%s %s"%(Treiber._Thread_name,Treiber.CALIB_TAB_OFFSET_FILE, e))
            return False



    def f_openMWG(self):
        try:
            if Treiber.fMWG == None:
                self.printf("fMWG == None")
                self.printf("%s.f_openMWG() open %s"%(Treiber._Thread_name,Treiber.sDevMWG))

                Treiber.fMWG = open(Treiber.sDevMWG,"rb")
        
                if ioctl(Treiber.fMWG,Treiber.MWG_IOCTRESETWM)==-1:
                    self.printf("%s.f_openMWG() Error: MWG_IOCTRESETWM\n"%Treiber._Thread_name)
                    return False

                if ioctl(Treiber.fMWG,Treiber.MWG_IOCTSETWM)==-1:
                    self.printf("%s.f_openMWG() Error: MWG_IOCTSETWM\n"%Treiber._Thread_name)
                    return False
        
                if ioctl(Treiber.fMWG,Treiber.MWG_IOCTRESETMWG)==-1:
                    self.printf("%s.f_openMWG() Error: MWG_IOCTRESETWM\n"%Treiber._Thread_name)
                    return False
                

                ''' short int (16Bit), short int (16Bit), unsigned char (8Bit), unsigned long (32Bit)) '''
                return True
                
        except Exception,e:
            self.printf("%s.f_openMWG() Error open %s %s"%(Treiber._Thread_name,Treiber.sDevMWG, e))
            return False
        
    def f_readMWG(self):
        
        o_Messwerte = struct.pack('hhBL',1,1,1,1)
        length = struct.calcsize('hhBL')
        Moment = 2048
        Winkel = 0
        Timestamp=0
        status=0
        
        if Treiber.b_SrbMode==False:
            self.f_SetSrbMod(True)
        try:
            o_Messwerte = Treiber.fMWG.read(length)
        except Exception,e:
            self.printf("%s.f_readMWG() Error read %s %s"%(Treiber._Thread_name,Treiber.sDevMWG, e))
            self.printf("f_readMWG()->bad copy")
            status = 3
            return status,Moment,Winkel,Timestamp
            
        if len(o_Messwerte) != length :
            self.printf("%s.f_readMWG() len(o_Messwerte)=%i length=%i readTimeout"%(Treiber._Thread_name,len(o_Messwerte),length))
            status = 4
            return status,Moment,Winkel,Timestamp
            #Fehlerzweig:
            
        (Moment,Winkel,status,Timestamp) = struct.unpack('hhBL',o_Messwerte)

        if status:
            self.printf ("%s.f_readMWG() bad epld status %d\n"%(Treiber._Thread_name,status))
            #epld status fehler
        
        return status,Moment,Winkel,Timestamp
        
        
        pass
        

    def f_IsOffsetSet(self):
        return True
    
 
    def printf(self,string):
        if Treiber.stout:
            print string
        pass
        