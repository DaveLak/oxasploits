# -*- coding: cp1252 -*-
'''
Created on 18.07.2014

@author: sth2mt
'''
import time
import threading
import thread
from ctypes import pythonapi, py_object
import FertigungsTest.GUI.Display as Display
import FertigungsTest.Hardware.StartSchalter as StartSchalter
import FertigungsTest.Hardware.Sound as Sound
import FertigungsTest.Hardware.BedienTasten as Key_Evn
import FertigungsTest.Hardware.ScanEngine as ScanEngine
import FertigungsTest.Hardware.Typschild as Typschild

# <Command>ScnTst</Command>
# <Command>exit</Command>

def kill(thread,iStopTimeout,tid):
    if thread:
        thread.printf ("kill iStopTimeout=%d"%iStopTimeout)
        time.sleep(iStopTimeout)
        #nach 30s hart beenden
        if thread.isAlive():
            
            res = pythonapi.PyThreadState_SetAsyncExc(tid,py_object(SystemExit))
            if res == 0:
                raise ValueError("nonexistent thread id (%s)" % thread._Thread_name)
            elif res > 1:
                pythonapi.PyThreadState_SetAsyncExc(tid,0)
                raise SystemError("PyThreadState_SetAsyncExc failed")
            else :
                thread.printf ("kill Thread %s" % thread._Thread_name)
                thread.errorcode=1200
                thread.isTimeout=True
                thread.__del__()
        else:
            thread.printf ( "kill %s not allive" % thread._Thread_name)
    else:
        print "kill: no handle"
   
        

class Prueffunktionen(threading.Thread):
    '''
    classdocs
    '''
    def __init__(self, O_Parser,O_Serializer,param=None):
        '''
        Constructor
        '''
        self._Thread_name = "ScnTst"
        self.stout = False
        self.printf( "Constructor %s" % self._Thread_name)
        time.sleep(1)
        threading.Thread.__init__(self)
        super(Prueffunktionen,self).__init__()
        self._EventStop = threading.Event()
        self.iStopTimeout = 3 # Stop Timeout bis zum Kill
        self.iTimeout = 60 # Timeout bis Abbruch
        self.errorcode=1200 # Fehlercode vorbelegen, Wenn Ok wird zurueckgesetzt
        self.isTimeout=False
        self.iWiederholungen=2 # Max 2 Versuche
        self.WeiterOhneBestaetigung=0
        
        self.O_XmlParser = O_Parser
        self.O_XML_Cmd = O_Serializer
        self.O_Display = Display.Treiber()
        self.O_Startschalter = StartSchalter.Treiber()
        self.O_Key_Evn = Key_Evn.Treiber()
        self.O_Scanner = ScanEngine.Treiber()
        self.O_Typschild = Typschild.Treiber()
        self.O_Display.setHeadlines("diagnosis tools","barcode scanner")
        self.O_Display.paintDisplay()
        
        pass
    
    def __del__(self):

        '''
        Destructor
        '''
        if self.errorcode==0:
            sAbruchGrund="OK"
        else:
            sAbruchGrund="NOK"
        self.printf( "Destructor %s" % self._Thread_name)
        # Belegung der Prueffunktion im Parseer objekt loeschen -> Freigabe
        self.printf( "Timeout %i, self._EventStop.isSet() %i"%(self.isTimeout,self._EventStop.isSet()))

        # Display bedienen
        if (self.isTimeout | self._EventStop.isSet()):
            #Abbruch der Funktion -> Fehler anzeigen
            if self._EventStop.isSet():
                sAbruchGrund="Abort"
                self.O_Display.setAction(sAbruchGrund,"","")
            else:
                #Timeout der Funktion -> Fehler anzeigen
                sAbruchGrund="Timeout"
                self.O_Display.setAction(sAbruchGrund,"","")
            self.O_Display.setOKNOK(0)
            self.O_Display.clrSelect()

        print "%s"%self.O_XML_Cmd.BuildRueckgabewert(self._Thread_name,"%s |%s| %s"%(self._Thread_name,self.O_Scanner.sInhalt,sAbruchGrund),None,self.errorcode,None)

        self.O_Display.paintDisplay()

        del(self.O_Typschild)
        del(self.O_Scanner)
        del(self.O_Key_Evn)
        del(self.O_Startschalter)
        del(self.O_Display)


        self.O_XmlParser.AktivePrueffunktion=None
        pass

        
    
    def stop(self):
        # Thread normal beenden
        self.printf("stop")
        if self.isAlive():
            self._EventStop.set()
            # Kill-thread falls dieser thread sich nicht nach 30s beendet
            for tid, tobj in threading._active.items():
                if tobj is self:
                    thread.start_new_thread(kill,(self,self.iStopTimeout,tid))
        #print "stop Ende"
        pass
    
    def run(self):
        # Ablauf starten
        self.printf("Ablauf starten")
        print "%s"%self.O_XML_Cmd.BuildTimeout(self.iTimeout,self._Thread_name)
        print "%s"%self.O_XML_Cmd.BuildPrintMainText("1D Scanner pruefen")
        
        # Watchdogtimer anstarten -> beendet Thread anch timeout
        for tid, tobj in threading._active.items():
            if tobj is self:
                thread.start_new_thread(kill,(self,self.iTimeout-self.iStopTimeout-1,tid))
                
        while self.iWiederholungen:
            self.Ablauf()
        self.printf("Nach Ablauf")
        self.__del__()
        pass
    
    def stopped(self):
        return self._EventStop.isSet()


    def Ablauf(self):
        self.printf("Scanner Test")
        self.O_Display.ResetLastError()
        
        self.O_Display.setFortschritt(1)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(1)

        s_Brc_Typschild = self.O_Typschild.ReadBrcStatParFromEeprom()
        Komponententyp=self.O_Typschild.getStatValue(s_Brc_Typschild,"Komponententyp") # Komponententyp einlesen
        self.printf("Komponententyp Schrauber 0x%i"%Komponententyp)

        # Pruefen ob Typschild ohne BarcodeScanner
        if ((Komponententyp&0x02)!=0x02):
            self.iWiederholungen=0
            self.printf("Nexo Variante ohne Scanner !")
            #pruefen ob doch Scanner verbaut
            self.O_Display.setActionLP("Searching_for barcode- scanner....")
            #self.O_Display.setAction("Suche", "Scan-Engine","....")
            # Scan Vorgang starten
            self.errorcode=self.O_Scanner.Start()
            # Rueckantwort prüfen
            if ((self.errorcode==0) | (self.errorcode==253)):
                self.errorcode=1201
                self.O_Display.setHeadlines("diagnosis tools","Barcode-scanner found_!")
                self.printf("Nexo Variante ohne Scanner jedoch Scanner verbaut -> NOK !")
            else:
                self.errorcode=0
                self.O_Display.setHeadlines("diagnosis tools","Without barcode- scanner_!")
                self.printf("Nexo Variante ohne Scanner, kein Scanner verbaut -> OK !")
                self.WeiterOhneBestaetigung=1
                
        else:
            self.O_Display.setActionLP("Please start_scan procedure_!")
            #self.O_Display.setAction("Bitte", "Scannvorgang","starten !")
       
            self.O_Display.setSelectMiddle("start")
            # Wiederholungzaehler herunterzaehlen
            self.iWiederholungen = self.iWiederholungen - 1

            # Warten auf Betaetigung Button "Start der Pruefung
            self.O_Key_Evn.Wait(self.O_Key_Evn.KEY_A, self.O_Key_Evn.KEY_RELEASED)
            self.O_Display.clrSelect()

            # Scanner Typschild auf Plausibilität pruefen
            Komponententyp=self.O_Typschild.getStatValue(s_Brc_Typschild,"Komponententyp") # Komponententyp einlesen
            self.printf("Komponententyp Schrauber 0x%i"%Komponententyp)

            self.O_Display.setActionLP("Starting scan process....")
            #self.O_Display.setAction("", "Starte", "Scan-Vorgang")
        
            # Scan Vorgang starten -> Laser ein
            self.errorcode=self.O_Scanner.Start()
            # 3s Warten auf Scanncode
            self.printf("O_Scanner.Start() = %i"%self.errorcode)
        
            # Scancode prüfen
            if self.errorcode==0:
                if ((Komponententyp&0x02)!=0x02):
                    self.errorcode=1201
                    self.printf("Nexo Variante ohne Scanner jedoch Scanner verbaut -> NOK !")
                else:
                    self.printf("Nexo mit Scanner Barcode %s -> OK !"%self.O_Scanner.sInhalt)
                    self.O_Display.setAction("barcode:", "%s"%self.O_Scanner.sInhalt,"")
                    time.sleep(3)
            else:
                if ((Komponententyp&0x02)==0x02):
                    if self.errorcode==253:
                        self.printf("Nexo Variante mit Scanner, Scanner gefunden, kein Barcode erkannt -> NOK !")
                        self.errorcode=1203
                    else:
                        self.printf("Nexo Variante mit Scanner, kein Scanner gefunden -> NOK !")
                        self.errorcode=1215
                else:
                    # Typschild ohne Scanner, Scanner nicht vorhanden -> OK Variante ohne Scanner
                    self.errorcode=0
                    self.printf("Nexo Variante ohne Scanner, kein Scanner gefunden -> OK !")
                
                
        self.O_Display.clrSelect()
        if self.errorcode==0: # Scanner OK
            self.O_Display.setOKNOK(1)
        else:
            self.O_Display.setOKNOK(0)

        self.O_Display.setFortschritt(90)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(90)
        if ((self.errorcode==0)&(self.WeiterOhneBestaetigung==0)): # Startschalter OK
            self.O_Display.setSelectLP("Confirm with_to ol_switch")
            #self.O_Display.setSelectLeft("Weiter ")
            #self.O_Display.setSelectMiddle("mit Start")
            #self.O_Display.setSelectRight("schalter")
            # Keine Wiederholung mehr notwendig -> auf 0 setzen
            self.iWiederholungen=0
            
            #Ergebnis bestaetigen
            self.O_Startschalter.Wait(True,self.stopped)
            # Bildschirm zuruecksetzen auf Default
            self.O_Display.BuildDefaultScreen()
        else:
            if self.iWiederholungen:
                self.O_Display.setSelectLeft("NOK",self.O_Display.sColorWhite,self.O_Display.sColorBlack)
                self.O_Display.setSelectMiddle(" ")
                self.O_Display.setSelectRight("again",self.O_Display.sColorWhite,self.O_Display.sColorBlack)
                #Ergebnis bestaetigen
                Taste=self.O_Key_Evn.Wait(self.O_Key_Evn.KEY_LEFT|self.O_Key_Evn.KEY_RIGHT, self.O_Key_Evn.KEY_PRESS)
                if Taste == self.O_Key_Evn.KEY_LEFT:
                    # Abbruch mit NOK
                    self.iWiederholungen=0
                    self.O_Display.setSelectLeft(" ",self.O_Display.sColorWhite,self.O_Display.sColorBlack)
                    self.O_Display.setSelectMiddle(" ",self.O_Display.sColorWhite,self.O_Display.sColorBlack)
                    self.O_Display.setSelectRight(" ",self.O_Display.sColorWhite,self.O_Display.sColorBlack)
                else :
                    # Bildschirm zuruecksetzen auf Default
                    self.O_Display.BuildDefaultScreen()
            else:
                # Keine Wiederholung mehr notwendig -> auf 0 setzen
                self.iWiederholungen=0
                if (self.WeiterOhneBestaetigung==0): # Startschalter OK
                    self.O_Display.setSelectLP("Confirm with_to ol_switch")
                    #self.O_Display.setSelectLeft("Weiter ")
                    #self.O_Display.setSelectMiddle("mit Start")
                    #self.O_Display.setSelectRight("schalter")
            
                    #Ergebnis bestaetigen
                    self.O_Startschalter.Wait(True,self.stopped)


        self.O_Display.setFortschritt(100)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(100)
        
        
        self.printf("Scanner P\xc3\xbcfung -> Ende")

        pass

 

    
    def printf(self,string):
        if self.stout:
            print string
        pass


            
    
    def TestMenue(self,O_Paint):
        if O_Paint:
            O_Paint.SetTestText(["Startschalter bet\xc3\xa4tigen"])
            O_Paint.Update()
            Input = ' '
            while Input!= "z":
                Input=O_Paint.TestfunktionsEingabe()
                O_Paint.Update()
            
                O_Paint.Update()
                O_Paint.ClearTestText()
                return Input

        pass

    
    pass


        