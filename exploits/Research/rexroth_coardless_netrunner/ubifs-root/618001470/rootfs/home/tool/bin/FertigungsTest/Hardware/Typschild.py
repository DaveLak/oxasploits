        # -*- coding: cp1252 -*-
'''
Created on 07.02.2012

@author: sth2mt
'''
#import time
import os as os
import subprocess
import FertigungsTest.Hardware.M24LR64R as M24LR64R
import FertigungsTest.Hardware.WLAN as WLAN


# <Command>TypPltRd</Command>


class Treiber(object):
    '''
    classdocs
    '''
    # Achtung dies ist Pseudo Singleton -> variablen werden statisch verwendet. Aufgeraumt wird erst wenn alle instanzen weg sindwird nur einmal instaniiert !!!!
    ObjCount = 0
    _Thread_name = "Typschild"
    stout = False
    konvertTypschild = False
    O_M24LR64R = None
    O_WLAN = None
    fTypschild = file
    TypschildExt = 'typ'
    crcTab = [    0x0, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
            0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
            0x1231, 0x210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
            0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
            0x2462, 0x3443, 0x420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
            0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
            0x3653, 0x2672, 0x1611, 0x630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
            0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
            0x48c4, 0x58e5, 0x6886, 0x78a7, 0x840, 0x1861, 0x2802, 0x3823,
            0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
            0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0xa50, 0x3a33, 0x2a12,
            0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
            0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0xc60, 0x1c41,
            0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
            0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0xe70,
            0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
            0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
            0x1080, 0xa1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
            0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
            0x2b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
            0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
            0x34e2, 0x24c3, 0x14a0, 0x481, 0x7466, 0x6447, 0x5424, 0x4405,
            0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
            0x26d3, 0x36f2, 0x691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
            0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
            0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x8e1, 0x3882, 0x28a3,
            0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
            0x4a75, 0x5a54, 0x6a37, 0x7a16, 0xaf1, 0x1ad0, 0x2ab3, 0x3a92,
            0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
            0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0xcc1,
            0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
            0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0xed1, 0x1ef0]
    
    sStatKeyList = ["MNR","Werkskennung","Fertigungsdatum","Seriennummer","Lieferantenkennung","Komponententyp","Gebernennmoment","Motornennmoment","Motornenndrehzahl","Getriebeuntersetzung","Getriebewirkungsgrad","Abtriebuntersetzung","Abtriebwirkungsgrad","Nennmoment","DrehzahlAbweichung","MomentLeerlaufMax"]
    sDynKeyList = ["TIX","ZyklusNr","Wartungsintervall","Lastintegral","StartLastZyklus"]
    sENStatKeyList = ["MNR","Werkskennung","Fertigungsdatum","Seriennummer","Lieferantenkennung","Komponententyp","Gebernennmoment","Motornennmoment","Motornenndrehzahl","Getriebeuntersetzung","Getriebewirkungsgrad","Abtriebuntersetzung","Abtriebwirkungsgrad","Nennmoment","DrehzahlAbweichung","MomentLeerlaufMax"]
    sENDynKeyList = ["TIX","ZyklusNr","Wartungsintervall"]
    
    
    def __init__(self):
        '''
        Constructor
        '''
        Treiber.ObjCount += 1
        self.printf("%i.Construktor %s Anzahl" % (Treiber.ObjCount,Treiber._Thread_name))
        if Treiber.O_M24LR64R == None:
            Treiber.O_M24LR64R= M24LR64R.Treiber()
        if Treiber.O_WLAN == None:
            Treiber.O_WLAN= WLAN.Treiber()
        pass
        
            
    def __del__(self):
        
        '''
        Destructor
        '''
        self.printf("%i Destruktor %s" % (Treiber.ObjCount,Treiber._Thread_name))

        if not Treiber.fTypschild.closed:
            Treiber.fTypschild.close()
            
        if Treiber.ObjCount == 1:
            self.printf("Reste aufraumen")
            del(Treiber.O_WLAN)
            Treiber.O_WLAN = None
            del(Treiber.O_M24LR64R)
            Treiber.O_M24LR64R = None

        if Treiber.ObjCount > 0:
            Treiber.ObjCount -= 1
        
        pass
    def CreateKeyValueList(self,sParams,sKeyList):
        self.printf("Typschild.CreateKeyValueList()")
        sString = ""
        length = len(sParams)
        if length > len(sKeyList):
            length = len(sKeyList)
        for i in range (0 , length, 1):
            if sKeyList[i] == "Motornennmoment"or sKeyList[i] == "Getriebeuntersetzung" or sKeyList[i] == "Abtriebuntersetzung" or sKeyList[i] == "Getriebewirkungsgrad" or sKeyList[i] == "Abtriebwirkungsgrad":
                sString += sKeyList[i]+":" + "%0.3f"%(float(sParams[i].rsplit('.')[0])/1000) +'\r'+'\n'
            elif sKeyList[i] == "Gebernennmoment" or sKeyList[i] == "Nennmoment" or sKeyList[i] == "DrehzahlAbweichung" or sKeyList[i] == "MomentLeerlaufMax":
                sString += sKeyList[i]+":" + "%0.1f"%(float(sParams[i].rsplit('.')[0])/10) +'\r'+'\n'
            elif sKeyList[i] == "Wartungsintervall" :
                sString += sKeyList[i]+":" + "00000000" +'\r'+'\n'
            else:
                sString += sKeyList[i]+":" + sParams[i] +'\r'+'\n' 
            self.printf("%s:%s" % (sKeyList[i],sParams[i]))
            
        self.printf(sString)
        return sString
        pass
    
    def CpyBrcTypFileToEeprom(self):
        try:
            self.printf("Typschild.CpyBrcTypFileToEeprom()")
            return self.WriteBrcTypeplateToEeprom(self.ReadTypFile())
        except EnvironmentError,e:
            print "Typschild.CpyBrcTypFileToEeprom()", e
            return False
    
    def WriteBrcTypeplateToEeprom(self,sBrcTypeplate):
        breturn = True
        try:
            self.printf("Typschild.WriteBrcTypeplateToEeprom()")
            if sBrcTypeplate == None:
                return False

            # sBrcTypeplate aufteilen in statisches und dynamische Typschild
            sStatParam = self.SplitStatParamString(sBrcTypeplate)
            if sStatParam == None:
                return False
            sDynParam = self.SplitDynParamString(sBrcTypeplate)
            if sDynParam == None:
                return False
            
            if self.konvertTypschild == True:
                # Inhalt als Zuordnung mit "key:param\n\r" zusammenbauen. wird eventuel später von Goeppel so schon fertig übergeben  
                sStatParam=self.CreateKeyValueList(sStatParam, Treiber.sStatKeyList)
                sDynParam=self.CreateKeyValueList(sDynParam, Treiber.sDynKeyList)

            sStatParam += self.getStringCalcCRC(sStatParam)

            # Schreibschutz aufheben
            if self.DisableWriteProtect()!=True:
                self.printf("Typschild.WriteBrcTypeplateToEeprom().DisableWriteProtect() Error")
                return False
            else:
                self.printf("Typschild.WriteBrcTypeplateToEeprom().DisableWriteProtect() OK")

            if ((self.WriteBrcStatParToEeprom(sStatParam)&(self.WriteBrcDynParToEeprom(sDynParam)))!=True):
                    self.printf("Typschild.WriteBrcParToEeprom() ERROR")
                    breturn = False

            # Schreibschutz wieder setzen
            if self.SetWriteProtect()!=True:
                self.printf("Typschild.WriteBrcTypeplateToEeprom().SetWriteProtect() Error")
                return False
            else:
                self.printf("Typschild.WriteBrcTypeplateToEeprom().SetWriteProtect() OK")
                
            # Alle Spuren des Zyklenzaehlers auf dem Nexo beseitigen
            if self.RemoveCycleInfoFiles()!=True:
                self.printf("Typschild.WriteBrcTypeplateToEeprom().RemoveCycleInfoFiles() Error")
            else:
                self.printf("Typschild.WriteBrcTypeplateToEeprom().RemoveCycleInfoFiles() OK")
        
        except EnvironmentError,e:
            print "Typschild.WriteBrcTypeplateToEeprom()", e
            return False

        return breturn
    
    
    
    def RemoveCycleInfoFiles(self):
        #Zu guter Letzt noch die Datei /mnt/data/log/cycle.log, /var/run/diag/cycle, /var/run/diag/torque_load loeschen, sonst war alles fuer die Katzt, da
        # sonts Zyklenzähler durch Systemserver wieder mit alten Wert ueberschrieben wird
        
        breturn = True
        #Ausgabe in logDatei umbiegen
        output = open ("remove_cycle.log","w")
        
        # Data attach mit ubiattach
        if subprocess.call(["ubiattach","/dev/ubi_ctrl","-m","7","-d","1"],stderr=output,stdout=output,shell=False)!=0:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() error ubiattach /dev/ubi_ctrl -m 7 -d 1")
            breturn = False
        else:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() ubiattach /dev/ubi_ctrl -m 7 -d 1 OK")
        
 
        # Data mkvolume mit ubimkvol
        #if subprocess.call(["ubimkvol","/dev/ubi2","-N","data","-m"],shell=False)!=0:
        #    self.printf( "Typschild.WriteBrcTypeplateToEeprom() error ubimkvol /dev/ubi2 -N data -m")
        #    breturn = False
        #else:
        #    self.printf( "Typschild.WriteBrcTypeplateToEeprom() ubimkvol /dev/ubi2 -N data -m OK")
        
        # create /mnt/data_flash
        if subprocess.call(["mkdir","/mnt/data_flash"],stderr=output,stdout=output,shell=False)!=0:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() error mkdir /mnt/data_flash")
            breturn = False
        else:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() mkdir /mnt/data_flash OK")

        
        # Data mount data_flash
        if subprocess.call(["mount","-t","ubifs","ubi1:data","/mnt/data_flash"],stderr=output,stdout=output,shell=False)!=0:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() error mount -t ubifs ubi1:data /mnt/data_flash")
            breturn = False
        else:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() mount -t ubifs ubi1:data /mnt/data_flash OK")
            
        # sync
        if subprocess.call(["sync"],stderr=output,stdout=output,shell=False)!=0:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() error sync")
            breturn = False
        else:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() sync OK")
        
        
        # loeschen /mnt/data_flash/log/
        try:
            s_Path = "/mnt/data_flash/log/"
            sPathFile = s_Path + "cycle.log"
            if (os.path.isfile(sPathFile)):
                os.remove(sPathFile)
                self.printf("Typschild.WriteBrcTypeplateToEeprom():remove(%s) OK"%sPathFile)
        except EnvironmentError,e:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() remove %s (%s)"%(sPathFile, e))
            breturn = False
            
        
        
        # data_flash unmount
        if subprocess.call(["umount","/mnt/data_flash"],stderr=output,stdout=output,shell=False)!=0:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() error unmount /mnt/data_flash")
            breturn = False
        else:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() unmount /mnt/data_flash OK")
         
        #Data detach
        if subprocess.call(["ubidetach","/dev/ubi_ctrl","-m","7"],stderr=output,stdout=output,shell=False)!=0:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() error ubidetach /dev/ubi_ctrl -m 7")
            breturn = False
        else:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() ubidetach /dev/ubi_ctrl -m 7 OK")
    
        # remove /mnt/data_flash
        if subprocess.call(["rm","/mnt/data_flash","-r"],stderr=output,stdout=output,shell=False)!=0:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() error rm /mnt/data_flash")
            breturn = False
        else:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() rm /mnt/data_flash OK")

        output.close()
            
        try:        
            s_Path = "/var/run/diag/"
            sPathFile = s_Path + "cycle"
            if (os.path.isfile(sPathFile)):
                os.remove(sPathFile)
                self.printf("Typschild.WriteBrcTypeplateToEeprom():remove(%s) OK"%sPathFile)
        except EnvironmentError,e:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() remove %s (%s)"%(sPathFile, e))
            breturn = False
            
        try:        
            sPathFile = s_Path + "torque_load"
            if (os.path.isfile(sPathFile)):
                os.remove(sPathFile)
                self.printf("Typschild.WriteBrcTypeplateToEeprom():remove(%s) OK"%sPathFile)
        except EnvironmentError,e:
            self.printf( "Typschild.WriteBrcTypeplateToEeprom() remove %s (%s)"%(sPathFile, e))
            breturn = False
            
        return breturn

            

    def ReadTypFile(self):
        try:
            self.printf("Typschild.ReadTypFile()")
            # TypschildDatei schon geoffnet
            # Schrauber Verzeichnis mit MAC vorhanden ?
            # Liste mit Verzeichnisinhalt laden
            s_Path = "/tmp/%s"%Treiber.O_WLAN.f_GetMACString()
            sListe = os.listdir(s_Path)
            self.printf("ReadTypFile() in path %s open sListe: %s"%(s_Path,sListe))
            if sListe == []:
                self.printf("ReadTypFile():*.typ Nix gefunden")
                return None
                
            # Typschilddatei suchen
            for File in sListe:
                sPathFile = s_Path + "/" + File
                self.printf(sPathFile)
                if (os.path.isfile(sPathFile))&(os.path.splitext(sPathFile)[1]==".typ"):
                    Treiber.fTypschild = open(sPathFile,'r')
                    self.printf("ReadTypFile():open(%s)"%sPathFile)
                    sTypschildInhalt = Treiber.fTypschild.read()
                    Treiber.fTypschild.close()
                    self.printf("ReadTypFile(): %s"% sTypschildInhalt)
                    return sTypschildInhalt
                else: 
                    self.printf("ReadTypFile():*.typ Nix gefunden")
                    #return None
                    # Nix gefunden
            
            return None
                    
        
                    
        except EnvironmentError,e:
            print "Typschild.Open()", e
            return None
 
            
        pass


    def WriteBrcStatParToEeprom(self,sStatParam):
        if len( sStatParam)>(0x6FF):
            self.printf("Typschild.WriteBrcStatParToEeprom(): len(%i)>0x6FF",len(sStatParam))
            return False
        #loeschen
        self.DeleteParInEeprom(0x0,0x6FF)
        #schreiben
        self.printf("Typschild.WriteBrcStatParToEeprom(): len(%i)\n%s"% (len(sStatParam),sStatParam))
        return Treiber.O_M24LR64R.write(0x0,sStatParam)
    
    def ReadBrcStatParFromEeprom(self):
        #lesen
        self.printf("Typschild.ReadBrcStatParFromEeprom()")
        sStatParam = self.ReadStatParFromEeprom(0x0,0x700)
        #self.printf("Typschild.ReadBrcStatParFromEeprom()len(%i) \n%s"%(len(sStatParam),sStatParam))
        return sStatParam
        pass
    
    def ReadEnStatParFromEeprom(self):
        #lesen
        self.printf("Typschild.ReadEnStatParFromEeprom()")
        sStatParam = self.ReadStatParFromEeprom(0x800,0x500)
        #self.printf("Typschild.ReadEnStatParFromEeprom()len(%i) \n%s"%(len(sStatParam),sStatParam))
        if ord(sStatParam[0]) == 0xff:
            if ord(sStatParam[1]) == 0xff:
                if ord(sStatParam[2]) == 0xff:
                    sStatParam = "empty\n###      ***"
        return sStatParam
        pass

    def ReadStatParFromEeprom(self,i_FlashOffsetAdress,i_Laenge):
        #lesen
        self.printf("Typschild.ReadStatParFromEeprom()")
        sStatParam = Treiber.O_M24LR64R.read(i_FlashOffsetAdress,i_Laenge)
        if Treiber.stout:
            for Zeichen in range (0,len(sStatParam)-1,1):
                print("0x%x"% ord(sStatParam[Zeichen])),
            print("0x%x\n"% ord(sStatParam[len(sStatParam)-1]))
        #self.printf("Typschild.ReadStatParFromEeprom()Komplett len(%i) \n%s"%(len(sStatParam),sStatParam))
        #Ende rausfiltern
        sStatParam = sStatParam.rsplit("***",1)[0]
        #Trennzeichen wieder anhaengen
        sStatParam = sStatParam + '***'
        if ord(sStatParam[0]) == 0xff:
            if ord(sStatParam[1]) == 0xff:
                if ord(sStatParam[2]) == 0xff:
                    sStatParam = "empty\n###      ***"

        self.printf("Typschild.ReadStatParFromEeprom()len(%i) \n%s"%(len(sStatParam),sStatParam))
        return sStatParam
        pass


    def DeleteParInEeprom(self,ioffset,ilength):
        #loeschen
        self.printf("Typschild.DeleteParInEeprom(): start (0x%x) len(%i)\n"% (ioffset,ilength))
        iStartsector=ioffset/128
        iEndSector=ilength/128 + iStartsector + 1
        self.printf("Typschild.DeleteParInEeprom(): iStartsector (0x%x) iEndSector (0x%x)"% (ioffset,ilength))
        string =chr(255)*128
        self.printf("DeleteParInEeprom offset 0x%x length 128"%(iStartsector*128))
        Treiber.O_M24LR64R.write(iStartsector*128,string)
        for i in range(iStartsector,iEndSector,1):
            self.printf("DeleteParInEeprom offset 0x%x length 128"%(i*128))
            Treiber.O_M24LR64R.write(i*128,string)
            
        
        return True

    def ReadEnDynParFromEeprom(self):
        #lesen
        self.printf("Typschild.ReadEnDynParFromEeprom()")
        # Dnamische Parameter in sector 26-27 lesen (16-27 für En reserviert)
        sDynParam = self.ReadDynParFromEeprom((26*0x80),0x2FF)
        #self.printf("Typschild.ReadEnDynParFromEeprom()len(%i) \n%s"%(len(sDynParam),sDynParam))
 
        #Ende rausfiltern
        sDynParam = sDynParam.rsplit("***",1)[0]
        if ord(sDynParam[0]) == 0xff:
            if ord(sDynParam[1]) == 0xff:
                if ord(sDynParam[2]) == 0xff:
                    sDynParam = "empty\r\n"
        #Trennzeichen wieder anhaengen
        sDynParam = sDynParam + '***'
        self.printf("Typschild.ReadEnDynParFromEeprom()len(%i) \n%s"%(len(sDynParam),sDynParam))
        return sDynParam
        pass
    def ReadBrcDynParFromEeprom(self):
        #lesen
        self.printf("Typschild.ReadBrcDynParFromEeprom()")
        # Dnamische Parameter in sector 14-15 lesen (1-16 für BRC reserviert)
        sDynParam = self.ReadDynParFromEeprom((14*0x80),0x100)
        if ord(sDynParam[0]) == 0xff:
            if ord(sDynParam[1]) == 0xff:
                if ord(sDynParam[2]) == 0xff:
                    sDynParam = "empty\r\n"


        #Ende rausfiltern
        sDynParam = sDynParam.rsplit("\r\n",1)[0]
        self.printf("Typschild.ReadBrcDynParFromEeprom()len(%i) \n%s"%(len(sDynParam),sDynParam))
        return sDynParam
        pass
    def ReadDynParFromEeprom(self,i_FlashOffsetAdress,i_Laenge):
        #lesen
        self.printf("Typschild.ReadDynParFromEeprom()")
        # Dnamische Parameter in sector lesen
        sDynParam = Treiber.O_M24LR64R.read(i_FlashOffsetAdress,i_Laenge)
        #self.printf("Typschild.ReadDynParFromEeprom()Komplett len(%i) \n%s"%(len(sDynParam),sDynParam))
        if Treiber.stout:
            for Zeichen in range (0,len(sDynParam)-1,1):
                print("0x%x,"% ord(sDynParam[Zeichen])),
            print("0x%x\n"% ord(sDynParam[len(sDynParam)-1]))
        return sDynParam
        pass

    def WriteBrcDynParToEeprom(self,sDynParam):
        if len( sDynParam)>(0x100):
            self.printf("Typschild.WriteBrcDynParToEeprom(): len( sDynParam)>0x100")
            return False
        #loeschen
        self.DeleteParInEeprom(0x700,0xFF)
        # Dnamische Parameter in sector 14-15 schreiben (1-16 für BRC reserviert)
        self.printf("Typschild.WriteBrcDynParToEeprom(): len(%i)\n%s"% (len(sDynParam),sDynParam))

        return Treiber.O_M24LR64R.write((14*0x80),sDynParam)

        pass
    
    
    def DeleteBrcDynPar(self):
        self.printf("Typschild.DeleteBrcDynPar()\n")
        #loeschen
        return self.DeleteParInEeprom(0x700,0xFF)
        pass
    
    def DeleteBrcStatPar(self):
        self.printf("Typschild.DeleteBrcStatPar()\n")
        #loeschen
        return self.DeleteParInEeprom(0x0,0x6FF)

        pass

    def DeleteBrcPar(self):
        # Schreibschutz aufheben
        if self.DisableWriteProtect()!=True:
            self.printf("Typschild.DeleteBrcPar().DisableWriteProtect() Error")
            return False
        else:
            self.printf("Typschild.DeleteBrcPar().DisableWriteProtect() OK")

        if ((self.DeleteBrcDynPar())&(self.DeleteBrcStatPar())!=True):
            self.printf("Typschild.DeleteBrcPar() ERROR")
            return False

        # Schreibschutz wieder setzen
        if self.SetWriteProtect()!=True:
            self.printf("Typschild.DeleteBrcPar().SetWriteProtect() Error")
            return False
        else:
            self.printf("Typschild.DeleteBrcPar().SetWriteProtect() OK")
       
        
        pass
    
    
    def SplitStatParamString(self,sInhalt):
        try:
            #Ende rausfiltern
            if self.konvertTypschild==True:
                sStatParam = sInhalt.rsplit(";###",1)[0]
            else:
                sStatParam = sInhalt.rsplit("\r\n###",1)[0] + "\r\n"
            #self.printf(sStatParam)
            if self.konvertTypschild==True:
                sStatParam = sStatParam.split(";")
            self.printf("Typschild.SplitStatParamString() = %s" % sStatParam)
            return sStatParam
        except Exception,e:
            self.printf( "Typschild.SplitStatParamString() %s" % e)
            return None
        
        pass
    
    def SplitDynParamString(self,sInhalt):
        try:
            if self.konvertTypschild==True:
                sDynParam = sInhalt.rsplit("***;",1)[1] #nehme Inhalt nach CRC Code
            else:
                sDynParam = sInhalt.rsplit("***\r\n",1)[1] #nehme Inhalt nach CRC Code
            #self.printf(sDynParam)
            if self.konvertTypschild==True:
                sDynParam = sDynParam.rsplit(";",1)[0] #entferne alles ab dem letzen ;
            else:
                sDynParam = sDynParam.rsplit("\r\n",1)[0] + "\r\n" #entferne alles ab dem letzen \n\r
            #self.printf(sDynParam)
            if self.konvertTypschild==True:
                sDynParam = sDynParam.split(";")

            # Zerlegen in Key:Value
            DynParam = sDynParam.rsplit("\r\n")
            sDynParam = ""
            # String wieder mit "\r\n" als Abschluss von Key:Value versehen
            for KeyValue in DynParam:
                # StartLastZyklus fest auf "0000000000" setzen
                index=KeyValue.find(self.sDynKeyList[4])
                if index>(-1):
                    KeyValue = KeyValue.rsplit(":",1)[0]+":0000000000"
                sDynParam += (KeyValue + "\r\n")


            self.printf( "Typschild.SplitDynParamString() =%s" % sDynParam)
        except Exception,e:
            self.printf( "Typschild.SplitDynParamString() %s" % e)
            return None

        return sDynParam
        pass
    
    def SplitCRC(self,sInhalt):
        try:
            stemp=sInhalt.split("###")
            self.printf(stemp)
        
            stemp1=stemp[1].split("***")[0]
            self.printf("Typschild.SplitCRC() = %s" % stemp1)
            return stemp1
        except Exception,e:
            self.printf( "Typschild.SplitCRC() %s" % e)
            return None
            pass
        
        pass

    def CalcCRC(self,string):
        self.printf("Typschild.CalcCRC()")
        crc = 0xffff
        for i in range (0, len(string),1):
            polynom = Treiber.crcTab[ord(chr(((crc>>8)^ord(string[i]))&0xff))]
            #self.printf("string[%i]=0x%02X polynom[%i] = 0x%04X crcalt=0x%04X" %(i,ord(string[i]),ord(chr(((crc>>8)^ord(string[i]))&0xff)),polynom,crc))
            crc = (((crc<<8)&0xFFFF)^polynom)
        self.printf( "crcneu=0x%04X" %(crc))
        return crc

    def getStringCalcCRC(self,string):
        self.printf("Typschild.getStringCalcCRC()")
        return ( "###0x%04X***\r\n" %self.CalcCRC(string))

    def getStringStatValue(self,sInhalt,sName):
        
        sStatPar = sInhalt.split(sName+":")
        
        return sStatPar[1].split("\r\n")[0]
        
    def getStatValue(self,sInhalt,sName):
        
        sValue=self.getStringStatValue(sInhalt,sName)
        
        self.printf("getStatValue(%s)=sValue=%s"%(sName,sValue))
        if "." in sValue:
            self.printf("float")
            return float(sValue)
        elif "x" in sValue or "X" in sValue:
            self.printf("hex")
            return int(sValue,16)
        elif  sValue.isdigit():
            self.printf("int")
            return int(sValue)
        else:
            self.printf("str")
            return sValue
        
    
    def checkCRC(self,sInhalt):
        s_CrcInhalt = (self.SplitCRC(sInhalt)).upper()
        s_ParamString = self.SplitStatParamString(sInhalt)
        s_CrcCalc = "0X%04X" %self.CalcCRC(s_ParamString)
        if s_CrcCalc == s_CrcInhalt:
            self.printf("checkCRC()-> OK")
            return True
        else:
            self.printf("checkCRC() NOK -> s_CrcInhalt=%s s_CrcCalc=%s"%(s_CrcInhalt,s_CrcCalc))
            return False

    def DisableWriteProtect(self):
        # Passwort eingeben
        self.O_M24LR64R.LogOnI2C()
        
        return True
    
    def SetWriteProtect(self):
        # Passwort eingeben
        self.O_M24LR64R.LogOnI2C()
        # Sectoren I2C Schreibschutz setzen
        # Byte 0 Sector 00-07 Schreibschutz -> \xff
        # Byte 1 Sector 08-13 Schreibschutz -> \x3f
        # Byte 2 Sector 16-19 Schreibschutz -> \x0f
        # Byte 3 Sector 24-31 beschreibbar  -> \x00
        # Byte 4 Sector 32-39 beschreibbar  -> \x00
        # Byte 5 Sector 40-47 beschreibbar  -> \x00
        # Byte 6 Sector 48-55 beschreibbar  -> \x00
        # Byte 7 Sector 56-63 beschreibbar  -> \x00
        
        self.O_M24LR64R.WriteI2CWriteLock(b'\xff\x3f\x0f\x00\x00\x00\x00\x00')
        
        # Ausloggen und schreibschutz aktivieren
        self.O_M24LR64R.LogOffI2C()

        #
        
        return True

    def ReadBrcTypschild(self):

        #Kompletes BRC Typschild auslesen TypBrcStat + TypBrcDyn
        sStatParams=self.ReadBrcStatParFromEeprom()
        sDynParams=self.ReadBrcDynParFromEeprom()
        self.printf("Typschild.ReadBrcTypschild(): lenStat(%i)lenDyn(%i)"% (len(sStatParams),len(sDynParams)))
        return (sStatParams+"\r\n"+sDynParams)


    def printf(self,string):
        if Treiber.stout:
            print string
        pass
