# -*- coding: cp1252 -*-
'''
Created on 10.10.2011

@author: sth2mt
'''

import time
import threading
import thread
from ctypes import pythonapi, py_object, c_char
import FertigungsTest.GUI.Display as Display
import FertigungsTest.Hardware.StartSchalter as StartSchalter

# <Command>ToolSwitchTst</Command>
# <Command>exit</Command>

def kill(thread,iStopTimeout,tid):
    if thread:
        thread.printf ("kill iStopTimeout=%d"%iStopTimeout)
        time.sleep(iStopTimeout)
        #nach 30s hart beenden
        if thread.isAlive():
            
            res = pythonapi.PyThreadState_SetAsyncExc(tid,py_object(SystemExit))
            if res == 0:
                raise ValueError("nonexistent thread id (%s)" % thread._Thread_name)
            elif res > 1:
                pythonapi.PyThreadState_SetAsyncExc(tid,0)
                raise SystemError("PyThreadState_SetAsyncExc failed")
            else :
                thread.printf ("kill Thread %s" % thread._Thread_name)
                thread.errorcode=500
                thread.isTimeout=True
                thread.__del__()
        else:
            thread.printf ( "kill %s not allive" % thread._Thread_name)
    else:
        print "kill: no handle"
   
        

class Prueffunktionen(threading.Thread):
    '''
    classdocs
    '''
    def __init__(self, O_Parser,O_Serializer,param=None):
        '''
        Constructor
        '''
        self._Thread_name = "ToolSwitchTst"
        self.stout = False
        self.GoeppelBremse = True
        self.printf( "Constructor %s" % self._Thread_name)
        threading.Thread.__init__(self)
        super(Prueffunktionen,self).__init__()
        self._EventStop = threading.Event()
        self.iStopTimeout = 3 # Stop Timeout bis zum Kill
        self.iTimeout = 60 # Timeout bis Abbruch
        self.errorcode=500 # Fehlercode vorbelegen, Wenn Ok wird zurueckgesetzt
        self.isTimeout=False
        self.iFiltertiefe = 3
        self.PotiStufen = 13
        
        
        self.O_XmlParser = O_Parser
        self.O_XML_Cmd = O_Serializer
        self.O_Display = Display.Treiber()
        self.O_Startschalter = StartSchalter.Treiber()
        self.O_Display.setHeadlines("diagnosis tools","tool switch")
        self.O_Display.setAction("","","")
        self.O_Display.paintDisplay()
        
        pass
    
    def __del__(self):
        
        '''
        Destructor* 1.0
        '''
        if self.errorcode==0:
            sAbruchGrund="OK"
        else:
            sAbruchGrund="NOK"
        self.printf( "Destructor %s" % self._Thread_name)
        # Belegung der Prueffunktion im Parseer objekt loeschen -> Freigabe
        self.printf( "Timeout %i, self._EventStop.isSet() %i"%(self.isTimeout,self._EventStop.isSet()))

        # Display bedienen
        if (self.isTimeout | self._EventStop.isSet()):
            #Abbruch der Funktion -> Fehler anzeigen
            if self._EventStop.isSet():
                sAbruchGrund="Abort"
                self.O_Display.setAction(sAbruchGrund,"","")
            else:
                #Timeout der Funktion -> Fehler anzeigen
                sAbruchGrund="Timeout"
                self.O_Display.setAction(sAbruchGrund,"","")
            self.O_Display.setOKNOK(0)
            self.O_Display.clrSelect()

        print "%s"%self.O_XML_Cmd.BuildRueckgabewert(self._Thread_name,"%s %s"%(self._Thread_name,sAbruchGrund),None,self.errorcode,None)

        self.O_Display.paintDisplay()

        del(self.O_Display)
        del(self.O_Startschalter)

        self.O_XmlParser.AktivePrueffunktion=None
        pass

        
    
    def stop(self):
        # Thread normal beenden
        self.printf("stop")
        if self.isAlive():
            self._EventStop.set()
            # Kill-thread falls dieser thread sich nicht nach 30s beendet
            for tid, tobj in threading._active.items():
                if tobj is self:
                    thread.start_new_thread(kill,(self,self.iStopTimeout,tid))
        #print "stop Ende"
        pass
    
    def run(self):
        # Ablauf starten
        self.printf("Ablauf starten")
        print "%s"%self.O_XML_Cmd.BuildTimeout(self.iTimeout,self._Thread_name)
        print "%s"%self.O_XML_Cmd.BuildPrintMainText("Startschalter pruefen")
        
        # Watchdogtimer anstarten -> beendet Thread anch timeout
        for tid, tobj in threading._active.items():
            if tobj is self:
                thread.start_new_thread(kill,(self,self.iTimeout-self.iStopTimeout-1,tid))
        if self.GoeppelBremse:
            time.sleep(3)
        self.Ablauf()
        self.printf("Nach Ablauf")
        self.__del__()
        pass
    
    def stopped(self):
        return self._EventStop.isSet()


    def Ablauf(self):
        self.printf("ToolSwitchTst")
        self.O_Display.setFortschritt(1)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(1)
        self.O_Display.ResetLastError()
        
        self.O_Display.setActionLP("Push tool-switch slowly")

        self.O_Display.setOKNOK(self.CheckStartschalter(self.PotiStufen))
        self.O_Display.setFortschritt(98)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(98)
        if self.errorcode==0: # Startschalter OK
            self.O_Display.setSelectLP("Confirm with_to ol_switch")
            #self.O_Display.setSelectLeft("Weiter ")
            #self.O_Display.setSelectMiddle("mit Start")
            #self.O_Display.setSelectRight("schalter")
            #self.O_Display.paintDisplay()
            
            #Ergebnis bestaetigen
            self.O_Startschalter.Wait(True,self.stopped)
            # Bildschirm zuruecksetzen auf Default
            self.O_Display.BuildDefaultScreen()

        self.O_Display.setFortschritt(100)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(100)
            

        self.printf("Startschalter Prüfung -> Ende")

        pass

    def CheckStartschalter(self,Zustaende):
        

        Displayfilter = 0
        c_Stufe = 0x3f
        # Poti in (x) Schritte aufteilen
        c_Stufe = (c_Stufe / Zustaende)+1
        
        c_Max = c_Stufe
        c_Min = 0
        self.printf( "Start %i, %i" %(c_Min,c_Max))

        Mittelwert=self.O_Startschalter.GetAnalog()
        for i in range (0,200000,1):
            ADWert=self.O_Startschalter.GetAnalog()*1.0 # float wandeln
            self.printf( "-> Mittelwert = %d ADWert = %d c_Min = %d c_Max = %d prozent = %d"%(Mittelwert,ADWert,c_Min,c_Max,50))
            if ADWert >= 0:
                Mittelwert = ((Mittelwert * self.iFiltertiefe ) + ADWert)/ (self.iFiltertiefe+1)
                #self.printf( " %i> %i < %i" %(c_Min,Mittelwert,c_Max))
                if (c_Max >= 0x3F)&(Mittelwert >= c_Min):
                    self.printf( "OK")
                    self.printf( "-> Mittelwert = %d c_Min = %d c_Max = %d prozent = %d"%(Mittelwert,c_Min,c_Max,50))
                    print "%s"%self.O_XML_Cmd.BuildProgressbar(50)
                    self.O_Display.setFortschritt(50)
                    self.O_Display.paintDisplay()

                    break

                if (Mittelwert > c_Min) & (Mittelwert < c_Max):
                    c_Min = c_Max
                    c_Max = c_Max + c_Stufe
                    self.printf( ("-> c_Min = %d c_Max = %d prozent = %d"%(c_Min,c_Max,(c_Min*40)/0x3F)))
                    print "%s"%self.O_XML_Cmd.BuildProgressbar((c_Min*50)/0x3F)
                    self.O_Display.setFortschritt((c_Min*50)/0x3F)
                    self.O_Display.paintDisplay()
                Displayfilter = Displayfilter +1
                if Displayfilter == 10:
                    Displayfilter = 0 
                    self.O_Display.setFortschritt(((int(Mittelwert)&0x3F)*50)/0x3F)
                    self.O_Display.paintDisplay()

            if self.stopped():
                return
            # Andere Prozesse arbeiten lassen
            time.sleep(0.05)

    
        
        c_Max = 0x3F-c_Stufe
        c_Min = 0x3F-(2*c_Stufe)


        #self.printf( ("merker %d prozent %d"%(c_Min,100-((c_Min*51)/0xFF))))
        #print "%s"%self.O_XML_Cmd.BuildProgressbar(100-((c_Min*51)/0xFF))
        #self.O_Display.setAction("Startschalter","langsam","loslassen")
        self.O_Display.setActionLP("Release tool-switch slowly")
                    
        for i in range (0,200000,1):
            ADWert=self.O_Startschalter.GetAnalog()*1.0 # float wandeln
            if ADWert >= 0:
                Mittelwert = ((Mittelwert * self.iFiltertiefe ) + ADWert)/ (self.iFiltertiefe+1)
                self.printf( "<- Mittelwert = %d ADWert = %d c_Min = %d c_Max = %d prozent %d"%(Mittelwert,ADWert,c_Min,c_Max,98))
                #self.printf( " %i> %i < %i" %(c_Min,Mittelwert,c_Max))
                if (c_Min < c_Stufe)&(Mittelwert < c_Max):
                    self.printf( "<- Mittelwert = %d c_Min = %d c_Max = %d prozent %d"%(Mittelwert,c_Min,c_Max,98))
                    print "%s"%self.O_XML_Cmd.BuildProgressbar(98)
                    self.O_Display.setFortschritt(98)
                    self.O_Display.paintDisplay()
                    self.printf( "OK")
                    self.errorcode=0
                    return True

                if (Mittelwert <= (c_Max)) & (Mittelwert >= (c_Min)):
                    c_Max = c_Min
                    c_Min = c_Min - c_Stufe
                    self.printf( ("<- Mittelwert = %d c_Min = %d c_Max = %d prozent = %d"%(Mittelwert,c_Min,c_Max,98-((c_Max*50)/0x3F))))
                    print "%s"%self.O_XML_Cmd.BuildProgressbar(98-((c_Max*51)/0x3F))
                    self.O_Display.setFortschritt(98-((c_Max*51)/0x3F))
                    self.O_Display.paintDisplay()
                Displayfilter = Displayfilter +1
                if Displayfilter == 10:
                    Displayfilter = 0 
                    self.O_Display.setFortschritt(98-(((int(Mittelwert)&0x3f)*51)/0x3F))
                    self.O_Display.paintDisplay()

            if self.stopped():
                return
            # Andere Prozesse arbeiten lassen
            time.sleep(0.05)



        self.printf( "NOK")
        return False 


    
    def printf(self,string):
        if self.stout:
            print string
        pass


            
    
    def TestMenue(self,O_Paint):
        if O_Paint:
            O_Paint.SetTestText(["Startschalter betätigen"])
            O_Paint.Update()
            Input = ' '
            while Input!= "z":
                Input=O_Paint.TestfunktionsEingabe()
                O_Paint.Update()
            
                O_Paint.Update()
                O_Paint.ClearTestText()
                return Input

        pass

    
    pass


