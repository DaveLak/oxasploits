/*global Ext: false, TR: false */
/*
Controller of the graph window
*/
Ext.define('BS350.controller.GraphCtrl', {
  extend: 'BS350.custom.ViewController',

  stores: ['GraphStore'],

  views: ['GraphView', 'BS350.custom.NumberFieldUnit', 'BS350.custom.ScatterLine', 'Ext.chart.*'],

  items: [
    { name: 'graphAngle', query: '#graphAngle', actions: {mousedown: 'angleMouseDown', mouseup: 'angleMouseUp', mousemove: 'angleMouseMove'}},
    { name: 'graphTime', query: '#graphTime', actions: {mousedown: 'timeMouseDown', mouseup: 'timeMouseUp', mousemove: 'timeMouseMove'}},
    { name: 'header', query: '#graphHeader'},
    { name: 'minValueAngle', query: '#minValueAngle', actions: {change: 'rangeAngleChanged', spin: 'rangeZoom'}},
    { name: 'maxValueAngle', query: '#maxValueAngle', actions: {change: 'rangeAngleChanged', spin: 'rangeZoom'}},
    { name: 'pointCntAngle', query: '#pointCntAngle'},
    { name: 'resetAngleZoom', query: '#resetAngleZoom', actions: {click: 'resetAngleZoom'}},
    { name: 'minValueTime', query: '#minValueTime', actions: {change: 'rangeTimeChanged', spin: 'rangeZoom'}},
    { name: 'maxValueTime', query: '#maxValueTime', actions: {change: 'rangeTimeChanged', spin: 'rangeZoom'}},
    { name: 'pointCntTime', query: '#pointCntTime'},
    { name: 'resetTimeZoom', query: '#resetTimeZoom', actions: {click: 'resetTimeZoom'}}
  ],

  navpath: '/home/graph',
  defaultHeaderValues: {
    aMin: 0,
    LS: "-",
    tMax: 0,
    TF: "-",
    IDCode: "-",
    P: "-",
    Time: "-",
    tMin: 0,
    Channel: "-",
    a: 0.000,
    OK: "?",
    t: 0,
    Date: "-",
    aMax: 0,
    Cycle: '-',
    total_angle: 0,
    margins: [],
    tMinMaxPrec: 10000,
    tPrec: 1000,
    aMinMaxPrec: 10000,
    aPrec: 100,
    tfAngle: false,
    marginsTime:[],
    TurnDirec: 1,
    LastCmdLabel: "",
    QCodeText: "-",
    rework_code: "-",
    rework_text: ""
  },
  currCycleNr: -1,
  rectSelection : null,
  isShowing : false,
  doZooming : true,

  init: function(application) {
    this.currentHeaderValues = this.defaultHeaderValues;
    application.getController('HeaderCtrl').on('updateGraph', this.checkCycle, this);
  },

  calcTimeMargins: function(records) {
    var margins = this.currentHeaderValues['margins'];
    var marginsTime = this.currentHeaderValues['marginsTime'];
    for (var i=0; i < margins.length; i++)
    {
      var stepStart = margins[i]['stepStartAngle'];
      var prev = undefined;
      Ext.Array.each(records, function(item)
      {
        if (prev != undefined)
        {
          if (stepStart >= prev.get('a') && stepStart <= item.get('a'))
          {
            marginsTime[i]['stepStartAngle'] = item.get('tm');
            return (false);
          }
        }
        else
        {
          if (stepStart <= item.get('a'))
          {
            marginsTime[i]['stepStartAngle'] = item.get('tm');
            return (false);
          }
        }
        prev = item;
      });
      var thresh = margins[i]['threshold_angle'];
      prev = undefined;
      if (thresh != 0)
      {
        Ext.Array.each(records, function(item)
        {
          if (prev != undefined)
          {
            if (thresh >= prev.get('a') && thresh <= item.get('a'))
            {
              marginsTime[i]['threshold_angle'] = item.get('tm');
              return (false);
            }
          }
          else
          {
            if (thresh <= item.get('a'))
            {
              marginsTime[i]['threshold_angle'] = item.get('tm');
              return (false);
            }
          }
          prev = item;
        });
      }
    }
  },

  getLastStepStartLimit: function() {
    var margins = this.currentHeaderValues['margins'];
    //We have a value only when at least 2 steps
    if (margins.length > 1)
    {
      var limit = margins[margins.length - 2]['stepEndAngle'];
      if (limit > 0)
      {
        return (limit);
      }
    }
    return (null);
  },

  updateLastStepTimeStartLimit: function() {
    var INVALID = '-';
    this.V.graphTime.series.items[0].RangeMinX = null;
    //do this only when at least onw torque limit is defined
    if (this.currentHeaderValues['tMin'] == INVALID && this.currentHeaderValues['tMax'] == INVALID) return;
    if ((this.currentHeaderValues['aMin'] == INVALID && this.V.graphAngle.series.items[0].RangeMinX != null) ||
        this.currentHeaderValues['aMin'] != INVALID)
    {
      var margins = this.currentHeaderValues['marginsTime'];
      if (margins.length > 1)
      {
        var limit = margins[margins.length - 2]['stepEndAngle'];
        if (limit > 0)
        {
          this.V.graphTime.series.items[0].RangeMinX = limit;
        }
      }
    }
  },

  initView: function() {
    this.V.header.setValues(this.currentHeaderValues);
    this.updateValues(this.currCycleNr);
  },

  checkCycle: function(status) {
    if (this.view && this.currCycleNr !== status.cycle) {
      if (this.isShowing)
      {
        this.updateValues(status.cycle)
      }
    }
  },

  activated: function()
  {
    this.isShowing = true;
    if (this.currCycleNr !== -1)
    {
      this.updateValues(this.currCycleNr);
    }
  },

  deactivated: function()
  {
    this.isShowing = false;
  },

  graphinfoUrl: '/BS350/result/graphinfo',
  updateValues: function(cycle)
  {
    if (cycle < 0)
        return;
    var me = this;
    this.currCycleNr = cycle;
    if (this.view)
    {
      var graphStore = this.V.graphAngle.getStore();
      Ext.Ajax.request({
        url: me.graphinfoUrl,
        params: { id: this.currCycleNr, stored: false },
        success: function(res) {
          me.currentHeaderValues = Ext.JSON.decode(res.responseText);
          //Make an initial copy

          if(me.currentHeaderValues != null){
              BS350.custom.Torque.getTorqueUnit();

              me.V.graphAngle.axes.items[0].title = TR("Torque") + " [" + BS350.custom.Torque.torque_mapping[me.currentHeaderValues.torque_unit] + "]";
              me.V.graphTime.axes.items[0].title = TR("Torque") + " [" + BS350.custom.Torque.torque_mapping[me.currentHeaderValues.torque_unit] + "]";
              me.currentHeaderValues.TF = TR(me.currentHeaderValues.TF);
              me.currentHeaderValues['marginsTime'] = Ext.clone(me.currentHeaderValues['margins']);
              me.currentHeaderValues['TorqueUnit'] = BS350.custom.Torque.torque_mapping[me.currentHeaderValues.torque_unit];
              me.updateRange(me.currentHeaderValues);
              graphStore.proxy.extraParams.id = me.currCycleNr;
              graphStore.load({
                callback: function(records, operation, success) {
                  /*Ext.Array.each(me.currentHeaderValues, function (item) {
                    item.LastCmdLabel = TR('LastCmd');
                  });*/
                  me.V.header.setValues(me.currentHeaderValues);
                  me.calcTimeMargins(records);
                  //CR10667
                  me.updateLastStepTimeStartLimit();
                  me.angleRange = [this.min('a'), this.max('a')];
                  me.timeRange = [this.min('tm'), this.max('tm')];
                  me.resetAngleZoom();
                  me.resetTimeZoom();
                  if (graphStore.hasListeners.refresh) {
                    graphStore.fireEvent('refresh', graphStore);
                  }
                }
              });
          } else {
            me.currentHeaderValues = me.defaultHeaderValues;
          }
        }
      });
    }
  },

  getMonitorOffset : function()
  {
    var offset = this.currentHeaderValues['margins'][this.currentHeaderValues['margins'].length - 1]['threshold_angle'];
    if (offset > 0)
    {
      return (offset);
    }
    if (this.currentHeaderValues['margins'].length === 1)
    {
      return (0);
    }
    offset = this.currentHeaderValues['margins'][this.currentHeaderValues['margins'].length - 1]['angle'];
    return (this.currentHeaderValues['total_angle'] - offset)
  },

  updateRange : function(values)
  {

    var angleSerie = this.V.graphAngle.series.items[0];
    var timeSerie = this.V.graphTime.series.items[0];
    var INVALID = -2147483648;

    var offset = this.getMonitorOffset();
    angleSerie.Margins = this.currentHeaderValues['margins'];
    timeSerie.Margins = this.currentHeaderValues['marginsTime'];
    if (values['aMin'] == INVALID && values['aMax'] == INVALID && !this.currentHeaderValues['tfAngle'])
    {
      //threshold lines only when at least one monitoring angle is given CR8824 or when target function angle is true
      angleSerie.ShowThresh = false;
      timeSerie.ShowThresh = false;
    }
    else
    {
      angleSerie.ShowThresh = true;
      timeSerie.ShowThresh = true;
    }

    var aMin, aMax, tMin, tMax;
    aMin = parseFloat(values['aMin']);
    aMax = parseFloat(values['aMax']);
    tMin = parseFloat(values['tMin']);
    tMax = parseFloat(values['tMax']);

    if (aMin == INVALID)
    {
      values['aMin'] = '-';
      angleSerie.RangeMinX = null;
      //When we have a torque limit and no angle min, we limit to last step start
      //Now CR8824 do this always when any other limit is given
      if (tMin != INVALID || tMax != INVALID || aMax != INVALID)
      {
        angleSerie.RangeMinX = this.getLastStepStartLimit();
      }
    }
    else
    {
      angleSerie.RangeMinX = aMin + offset;
    }

    if (aMax == INVALID)
    {
      values['aMax'] = '-';
      angleSerie.RangeMaxX = null;
    }
    else
    {
      angleSerie.RangeMaxX = aMax + offset;
    }

    var turnDirection = parseFloat(values['TurnDirec']);

    if (tMin == INVALID)
    {
      values['tMin'] = '-';
      angleSerie.RangeMinY = null;
      timeSerie.RangeMinY = null;
    }
    else
    {
      angleSerie.RangeMinY = tMin * turnDirection;
      timeSerie.RangeMinY = tMin * turnDirection;
    }

    if (tMax == INVALID)
    {
      values['tMax'] = '-';
      angleSerie.RangeMaxY = null;
      timeSerie.RangeMaxY = null;
    }
    else
    {
      angleSerie.RangeMaxY = tMax * turnDirection;
      timeSerie.RangeMaxY = tMax * turnDirection;
    }
    //When -ve direction ranges are also turned since values are -ve
    if (turnDirection === -1)
    {
      var tmp = angleSerie.RangeMinY;
      angleSerie.RangeMinY = angleSerie.RangeMaxY;
      angleSerie.RangeMaxY = tmp;
      tmp = timeSerie.RangeMinY;
      timeSerie.RangeMinY = timeSerie.RangeMaxY;
      timeSerie.RangeMaxY = tmp;
    }
  },

  rangeZoom: function()
  {
    this.doZooming = true;
  },

  rangeAngleChanged: function(nfield) {
    if (nfield.isValid()) {
      var store = this.V.graphAngle.getStore();

      var minAngle = (this.V.minValueAngle.isValid() ? this.V.minValueAngle.getValue() : null) || this.angleRange[0];
      this.V.maxValueAngle.setMinValue(minAngle);

      var maxAngle = (this.V.maxValueAngle.isValid() ? this.V.maxValueAngle.getValue() : null) || this.angleRange[1];
      this.V.minValueAngle.setMaxValue(maxAngle);

      var angleAxis = this.V.graphAngle.axes.getAt(1);

      var cnt = 0;
      var useFilter = false;
      for (var i = 0; i < store.getCount(); i++)
      {
        if (!this.doZooming)
        {
          useFilter = true;
          break;
        }
        var val, res, va;
        va = store.getAt(i);
        if (va === undefined) {
          break;
        }
        val = va.get('a');
        res = true;
        if (minAngle !== null) {res &= (val >= minAngle);}
        if (maxAngle !== null) {res &= (val <= maxAngle);}
        if (res == true)
        {
          if (++cnt > 1)
          {
            useFilter = true;
            break;
          }
        }
      }

      if (useFilter)
      {
        angleAxis.rangeQuery = [minAngle, maxAngle];
        var val, res;
        var me = this;
        store.filterBy(function(item) {
          if (!me.doZooming) {return true;}
          val = item.get('a');
          res = true;
          if (minAngle !== null) {res &= (val >= minAngle);}
          if (maxAngle !== null) {res &= (val <= maxAngle);}
          return res;
        });
      }
      this.V.pointCntAngle.setValue(store.getCount() + '/' + store.getTotalCount());
    }
  },

  resetAngleZoom: function() {
    this.doZooming = false;
    try {
      this.V.maxValueAngle.resumeEvents();
      this.V.minValueAngle.resumeEvents();
      this.V.maxValueAngle.setValue(this.angleRange[1]);
      this.V.minValueAngle.setValue(this.angleRange[0]);
      if (this.rectSelectionAngle) {
        this.rectSelectionAngle.remove();
        this.rectSelectionAngle = null;
      }
    } catch (err) {}
    this.doZooming = true;
  },

  rangeTimeChanged: function(nfield) {
    if (nfield.isValid()) {
      var store = this.V.graphTime.getStore();

      var minTime = (this.V.minValueTime.isValid() ? this.V.minValueTime.getValue() : null) || this.timeRange[0];
      this.V.maxValueTime.setMinValue(minTime);

      var maxTime = (this.V.maxValueTime.isValid() ? this.V.maxValueTime.getValue() : null) || this.timeRange[1];
      this.V.minValueTime.setMaxValue(maxTime);

      var timeAxis = this.V.graphTime.axes.getAt(1);

      var cnt = 0;
      var useFilter = false;
      for (var i = 0; i < store.getCount(); i++)
      {
        if (!this.doZooming)
        {
          useFilter = true;
          break;
        }
        var val, res, va;
        va = store.getAt(i);
        if (va === undefined) {
          break;
        }
        val = va.get('tm');
        res = true;
        if (minTime !== null) {res &= (val >= minTime);}
        if (maxTime !== null) {res &= (val <= maxTime);}
        if (res == true)
        {
          if (++cnt > 1)
          {
            useFilter = true;
            break;
          }
        }
      }

      if (useFilter)
      {
        timeAxis.rangeQuery = [minTime, maxTime];
        var val, res;
        var me = this;
        store.filterBy(function(item) {
          if (!me.doZooming) {return true;}
          val = item.get('tm');
          res = true;
          if (minTime !== null) {res &= (val >= minTime);}
          if (maxTime !== null) {res &= (val <= maxTime);}
          return res;
        });
      }
      this.V.pointCntTime.setValue(store.getCount() + '/' + store.getTotalCount());
    }
  },

  resetTimeZoom: function() {
    this.doZooming = false;
    try {
      this.V.maxValueTime.resumeEvents();
      this.V.minValueTime.resumeEvents();
      this.V.maxValueTime.setValue(this.timeRange[1]);
      this.V.minValueTime.setValue(this.timeRange[0]);
      if (this.rectSelectionTime) {
        this.rectSelectionTime.remove();
        this.rectSelectionTime = null;
      }
    } catch (err) {}
    this.doZooming = true;
  },


  angleMouseUp: function(e) {
    this.handleMouseUp(e, this.V.graphAngle, this.V.minValueAngle, this.V.maxValueAngle);
  },

  angleMouseDown: function(e) {
    this.handleMouseDown(e, this.V.graphAngle, this.V.minValueAngle, this.V.maxValueAngle);
  },

  angleMouseMove: function(e) {
    this.handleMouseMove(e, this.V.graphAngle, this.V.minValueAngle, this.V.maxValueAngle);
  },

  timeMouseUp: function(e) {
    this.handleMouseUp(e, this.V.graphTime, this.V.minValueTime, this.V.maxValueTime);
  },

  timeMouseDown: function(e) {
    this.handleMouseDown(e, this.V.graphTime, this.V.minValueTime, this.V.maxValueTime);
  },

  timeMouseMove: function(e) {
    this.handleMouseMove(e, this.V.graphTime, this.V.minValueTime, this.V.maxValueTime);
  },

  handleMouseDown: function(e, graph, minField, maxField) {
    e.preventDefault();
    if (this.rectSelection) {
      this.rectSelection.remove(); this.rectSelection = null;
    }
    var bbox = graph.chartBBox,
        x = e.browserEvent.layerX, y = e.browserEvent.layerY;
    if (x === undefined || y === undefined)
    {
      if (Ext.isIE)
      {
        x = event.x;
        y = event.y;
      }
    }
    if (x >= bbox.x && x < (bbox.x+bbox.width)) {
      this.rectSelection = graph.surface.add({type:'rect', x :x, y: bbox.y, width: 0, height: bbox.height, fill : '#ffff00', opacity:0.5});
      minField.suspendEvents();
      maxField.suspendEvents();
    }
  },

  handleMouseMove: function(e, graph, minField, maxField) {
    if (this.rectSelection) {
      var serie = graph.series.items[0],
          bbox = graph.chartBBox,
          x = e.browserEvent.layerX, y = e.browserEvent.layerY;
      if (x === undefined || y === undefined)
      {
        if (Ext.isIE)
        {
          x = event.x;
          y = event.y;
        }
      }
      if (x > (bbox.x+bbox.width)) x = (bbox.x+bbox.width);
      if (x < bbox.x) x = bbox.x;
      var newWidth = Math.abs(x-this.rectSelection.x),
          newX = (x >= this.rectSelection.x) ? this.rectSelection.x : x;
      this.rectSelection.setAttributes({x: newX, width: newWidth}, true);

      var minVal = ((newX - bbox.x)/serie.xScale) + serie.minX,
          maxVal = ((newX+newWidth - bbox.x)/serie.xScale) + serie.minX;
      minField.setValue(minVal);
      maxField.setValue(maxVal);
    }
  },


  handleMouseUp: function(e, graph, minField, maxField) {
    e.preventDefault();
    if (this.rectSelection) {
      var serie = graph.series.items[0],
          bbox = graph.chartBBox,
          rectBBox = this.rectSelection.getBBox(),
          x = rectBBox.x,
          width = rectBBox.width;

      this.rectSelection.remove();
      this.rectSelection = null;

      minField.resumeEvents();
      maxField.resumeEvents();

      if (width>0) {
        var minVal = ((x - bbox.x)/serie.xScale) + serie.minX,
            maxVal = ((x+width - bbox.x)/serie.xScale) + serie.minX;

        this.doZooming = true;
        minField.setValue(minVal);
        maxField.setValue(maxVal);

        // Workaround: setValue does not fire event
        if (minField === this.V.minValueAngle) this.rangeAngleChanged(this.V.minValueAngle);
        if (minField === this.V.minValueTime) this.rangeTimeChanged(this.V.minValueTime);
      }
    }
  }
});
