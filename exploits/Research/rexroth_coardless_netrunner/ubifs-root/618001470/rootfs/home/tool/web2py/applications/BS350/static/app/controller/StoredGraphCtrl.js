/*global Ext: false, TR: false */
/*
Controller of the stored graph window
*/
Ext.define('BS350.controller.StoredGraphCtrl',
{
  extend: 'BS350.custom.ViewController',
  requires: ['BS350.custom.Analysis'],
  stores: ['StoredGraphStore', 'GraphCycleStore'],

  views: ['StoredGraphView', 'BS350.custom.NumberFieldUnit', 'BS350.custom.ScatterLine', 'Ext.chart.*'],

  items: [
    { name: 'graphAngle', query: '#graphAngle', actions: {mousedown: 'angleMouseDown', mouseup: 'angleMouseUp', mousemove: 'angleMouseMove'}},
    { name: 'graphTime', query: '#graphTime', actions: {mousedown: 'timeMouseDown', mouseup: 'timeMouseUp', mousemove: 'timeMouseMove'}},
    { name: 'header', query: '#graphHeader'},
    { name: 'minValueAngle', query: '#minValueAngle', actions: {change: 'rangeAngleChanged', spin: 'rangeZoom'}},
    { name: 'maxValueAngle', query: '#maxValueAngle', actions: {change: 'rangeAngleChanged', spin: 'rangeZoom'}},
    { name: 'resetAngleZoom', query: '#resetAngleZoom', actions: {click: 'resetAngleZoom'}},
    { name: 'pointCntAngle', query: '#pointCntAngle'},
    { name: 'minValueTime', query: '#minValueTime', actions: {change: 'rangeTimeChanged', spin: 'rangeZoom'}},
    { name: 'maxValueTime', query: '#maxValueTime', actions: {change: 'rangeTimeChanged', spin: 'rangeZoom'}},
    { name: 'pointCntTime', query: '#pointCntTime'},
    { name: 'resetTimeZoom', query: '#resetTimeZoom', actions: {click: 'resetTimeZoom'}},
    { name: 'firstAngleCycle', query: '#firstAngleCycle', actions: {click: 'firstCycleClicked'}},
    { name: 'nextAngleCycle', query: '#nextAngleCycle', actions: {click: 'nextCycleClicked'}},
    { name: 'angleCycleId', query: '#angleCycleId', actions: {change: 'angleCycleIdChanged'}},
    { name: 'prevAngleCycle', query: '#prevAngleCycle', actions: {click: 'prevCycleClicked'}},
    { name: 'lastAngleCycle', query: '#lastAngleCycle', actions: {click: 'lastCycleClicked'}},
    { name: 'rgAngleOKStatus', query: '#rgAngleOKStatus', actions: {change: 'rbAngleOKStatusChanged'}},
   // { name: 'refreshAngleCycle', query: '#refreshAngleCycle', actions: {click: 'refreshCycleClicked'}},
    { name: 'txtAngleDataCount', query: '#txtAngleDataCount'},
    { name: 'firstTimeCycle', query: '#firstTimeCycle', actions: {click: 'firstCycleClicked'}},
    { name: 'nextTimeCycle', query: '#nextTimeCycle', actions: {click: 'nextCycleClicked'}},
    { name: 'timeCycleId', query: '#timeCycleId',  actions: {change: 'timeCycleIdChanged'}},
    { name: 'prevTimeCycle', query: '#prevTimeCycle', actions: {click: 'prevCycleClicked'}},
    { name: 'lastTimeCycle', query: '#lastTimeCycle', actions: {click: 'lastCycleClicked'}},
    { name: 'rgTimeOKStatus', query: '#rgTimeOKStatus', actions: {change: 'rbTimeOKStatusChanged'}},
    //{ name: 'refreshTimeCycle', query: '#refreshTimeCycle', actions: {click: 'refreshCycleClicked'}},
    { name: 'txtTimeDataCount', query: '#txtTimeDataCount'}
  ],

  navpath: '/home/storedgraph',
  defaultHeaderValues: {aMin: 0, Level: "-", tMax: 0, TF: "-", IDCode: "000000000000", Program: "n.a", Time: "-", tMin: 0, Channel: "-", a: 0.000, OK: "?", t: 0, Date: "-", aMax: 0, Cycle: "-", total_angle: 0, margins:[], tMinMaxPrec: 10000, tPrec: 1000, aMinMaxPrec: 10000, aPrec: 100, tfAngle: false, marginsTime:[], TurnDirec: 1, rework_code: "-", rework_text: ""},
  currCycleNr: -1,
  lastStatusCycle: -1,
  rectSelection : null,
  cycleStore: null,
  cycleOkType: 0,
  doZooming : true,
  isShowing : false,
  checkresults: false,

  init: function(application) {
    this.currentHeaderValues = this.defaultHeaderValues;
    application.getController('HeaderCtrl').on('updatestatus', this.checkCycle, this);
    application.getController('DatabaseCtrl').on('resultdbdeleted', this.checkResultDB, this);
  },

  calcTimeMargins: function(records) {
    var margins = this.currentHeaderValues['margins'];
    var marginsTime = this.currentHeaderValues['marginsTime'];
    for (var i=0; i < margins.length; i++)
    {
      var stepStart = margins[i]['stepStartAngle'];
      var prev = undefined;
      Ext.Array.each(records, function(item)
      {
        if (prev != undefined)
        {
          if (stepStart >= prev.get('a') && stepStart <= item.get('a'))
          {
            marginsTime[i]['stepStartAngle'] = item.get('tm');
            return (false);
          }
        }
        else
        {
          if (stepStart <= item.get('a'))
          {
            marginsTime[i]['stepStartAngle'] = item.get('tm');
            return (false);
          }
        }
        prev = item;
      });
      var thresh = margins[i]['threshold_angle'];
      prev = undefined;
      if (thresh != 0)
      {
        Ext.Array.each(records, function(item)
        {
          if (prev != undefined)
          {
            if (thresh >= prev.get('a') && thresh <= item.get('a'))
            {
              marginsTime[i]['threshold_angle'] = item.get('tm');
              return (false);
            }
          }
          else
          {
            if (thresh <= item.get('a'))
            {
              marginsTime[i]['threshold_angle'] = item.get('tm');
              return (false);
            }
          }
          prev = item;
        });
      }
    }
  },

  getLastStepEndLimit: function() {
    var margins = this.currentHeaderValues['margins'];
    //We have a value only when at least 2 steps
    if (margins.length > 1)
    {
      var limit = margins[margins.length - 2]['stepEndAngle'];
      if (limit > 0)
      {
        return (limit);
      }
    }
    return (null);
  },

  updateLastStepTimeStartLimit: function() {
    var INVALID = '-';
    this.V.graphTime.series.items[0].RangeMinX = null;
    //do this only when at least onw torque limit is defined
    if (this.currentHeaderValues['tMin'] == INVALID && this.currentHeaderValues['tMax'] == INVALID) return;
    if ((this.currentHeaderValues['aMin'] == INVALID && this.V.graphAngle.series.items[0].RangeMinX != null) ||
        this.currentHeaderValues['aMin'] != INVALID)
    {
      var margins = this.currentHeaderValues['marginsTime'];
      if (margins.length > 1)
      {
        var limit = margins[margins.length - 2]['stepEndAngle'];
        if (limit > 0)
        {
          this.V.graphTime.series.items[0].RangeMinX = limit;
        }
      }
    }
  },

  initView: function() {
    var me = this;
    var headerValuesFun = function () {
      me.V.header.setValues(me.currentHeaderValues);
    }
    if (APP.torqueUnitFactors === undefined) {
      var channelCtrl = APP.getController('ChannelCtrl');
      channelCtrl.getTorqueUnitFactors(headerValuesFun);
    } else {
      headerValuesFun();
    }
    this.getCyclesStore();
    this.cycleOkType = this.cycleStore.allCycles;
    var me = this;
    this.V.angleCycleId.validator = function(value) {
      return(me.validateAngleCycleId(value));
      };

    this.V.timeCycleId.validator = function(value) {
      return(me.validateTimeCycleId(value));
      };
    this.updateValues(this.currCycleNr);
  },

  checkCycle: function(status) {
    if (this.view && this.currCycleNr !== status.cycle && this.isShowing) {
      if (this.lastStatusCycle !== status.cycle)
      {
        this.getCyclesStore();
      }
      if (this.currCycleNr < 0 || this.V.angleCycleId.value === '' || this.V.angleCycleId.value === undefined)
      {
        this.V.angleCycleId.setValue(status.cycle);
      }
    }
  },

  checkResultDB: function () {
    this.checkresults = true;
  },

  updateValues: function(cycle)
  {
    if (cycle < 0)
        return;
    if (this.currCycleNr === cycle)
      return;

    var me = this;
    this.currCycleNr = cycle;
    if (this.view) {
      var updateValuesFun = function () {
        var graphStore = me.V.graphAngle.getStore();
        Ext.Ajax.request({
          url: '/BS350/result/graphinfo',
          params: {id: me.currCycleNr, stored: true},
          success: function (res) {
            if (res.responseText === "null") {
              //something went wrong update cycles
              me.getCyclesStore();
              return;
            }
            me.currentHeaderValues = Ext.JSON.decode(res.responseText);
            me.V.graphAngle.axes.items[0].title = TR("Torque") + " [" + BS350.custom.Torque.getUnitPres(me.currentHeaderValues.torque_unit) + "]";
            me.V.graphTime.axes.items[0].title = TR("Torque") + " [" + BS350.custom.Torque.getUnitPres(me.currentHeaderValues.torque_unit) + "]";
            me.currentHeaderValues.TF = TR(me.currentHeaderValues.TF);
            //Make an initial copy
            me.currentHeaderValues['marginsTime'] = Ext.clone(me.currentHeaderValues['margins']);
            me.currentHeaderValues['TorqueUnit'] = BS350.custom.Torque.getUnitPres(me.currentHeaderValues.torque_unit);
            me.updateRange(me.currentHeaderValues);
            graphStore.proxy.extraParams.id = me.currCycleNr;
            graphStore.load({
              callback: function (records, operation, success) {
                //me.currentHeaderValues.LastCmdLabel = TR('LastCmd');
                me.V.header.setValues(me.currentHeaderValues);
                me.calcTimeMargins(records);
                //CR10667
                me.updateLastStepTimeStartLimit();
                me.angleRange = [this.min('a'), this.max('a')];
                me.timeRange = [this.min('tm'), this.max('tm')];
                me.resetAngleZoom();
                me.resetTimeZoom();
              }
            });
          }
        });
      }
    };
    if (APP.torqueUnitFactors === undefined) {
      var channelCtrl = me.getController('ChannelCtrl');
      channelCtrl.getTorqueUnitFactors(updateValuesFun);
    } else {
      updateValuesFun();
    }
  },

  getMonitorOffset : function()
  {
    if (this.currentHeaderValues['margins'].length === 0) return 0;
    var offset = this.currentHeaderValues['margins'][this.currentHeaderValues['margins'].length - 1]['threshold_angle'];
    if (offset > 0)
    {
      return (offset);
    }
    if (this.currentHeaderValues['margins'].length === 1)
    {
      return (0);
    }
    offset = this.currentHeaderValues['margins'][this.currentHeaderValues['margins'].length - 1]['angle'];
    return (this.currentHeaderValues['total_angle'] - offset)
  },

  updateRange : function(values)
  {

    var angleSerie = this.V.graphAngle.series.items[0];
    var timeSerie = this.V.graphTime.series.items[0];
    var INVALID = -2147483648;
    var offset = this.getMonitorOffset();
    angleSerie.Margins = this.currentHeaderValues['margins'];
    timeSerie.Margins = this.currentHeaderValues['marginsTime'];
    if (values['aMin'] == INVALID && values['aMax'] == INVALID && !this.currentHeaderValues['tfAngle'])
    {
      //threshold lines only when at least one monitoring angle is given CR8824 or when target function angle is true
      angleSerie.ShowThresh = false;
      timeSerie.ShowThresh = false;
    }
    else
    {
      angleSerie.ShowThresh = true;
      timeSerie.ShowThresh = true;
    }

    var aMin, aMax, tMin, tMax;
    aMin = parseFloat(values['aMin']);
    aMax = parseFloat(values['aMax']);
    tMin = parseFloat(values['tMin']);
    tMax = parseFloat(values['tMax']);

    if (aMin == INVALID)
    {
      values['aMin'] = '-';
      angleSerie.RangeMinX = null;
      //When we have a torque limit and no angle min, we limit to last step start
      //Now CR8824 do this always when any other limit is given
      if (tMin != INVALID || tMax != INVALID || aMax != INVALID)
      {
        // Changed from start angle to step before end angle!
        angleSerie.RangeMinX = this.getLastStepEndLimit();
      }
    }
    else
    {
      angleSerie.RangeMinX = aMin + offset;
    }

    if (aMax == INVALID) {
      values['aMax'] = '-';
      angleSerie.RangeMaxX = null;
    }
    else {
      angleSerie.RangeMaxX = aMax + offset;
    }

    var turnDirection = parseFloat(values['TurnDirec']);

    if (tMin == INVALID) {
      values['tMin'] = '-';
      angleSerie.RangeMinY = null;
      timeSerie.RangeMinY = null;
    }
    else {
      angleSerie.RangeMinY = tMin * turnDirection;
      timeSerie.RangeMinY = tMin * turnDirection;
    }

    if (tMax == INVALID) {
      values['tMax'] = '-';
      angleSerie.RangeMaxY = null;
      timeSerie.RangeMaxY = null;
    }
    else {
      angleSerie.RangeMaxY = tMax * turnDirection;
      timeSerie.RangeMaxY = tMax * turnDirection;
    }
    //When -ve direction ranges are also turned since values are -ve

    if (turnDirection === -1)
    {
      var tmp = angleSerie.RangeMinY;
      angleSerie.RangeMinY = angleSerie.RangeMaxY;
      angleSerie.RangeMaxY = tmp;
      tmp = timeSerie.RangeMinY;
      timeSerie.RangeMinY = timeSerie.RangeMaxY;
      timeSerie.RangeMaxY = tmp;
    }
  },

  rangeZoom: function()
  {
    this.doZooming = true;
  },

  rangeAngleChanged: function(nfield) {
    if (nfield.isValid()) {
      var store = this.V.graphAngle.getStore();

      var minAngle = (this.V.minValueAngle.isValid() ? this.V.minValueAngle.getValue() : null) || this.angleRange[0];
      this.V.maxValueAngle.setMinValue(minAngle);

      var maxAngle = (this.V.maxValueAngle.isValid() ? this.V.maxValueAngle.getValue() : null) || this.angleRange[1];
      this.V.minValueAngle.setMaxValue(maxAngle);

      var angleAxis = this.V.graphAngle.axes.getAt(1);

      var cnt = 0;
      var useFilter = false;
      for (var i = 0; i < store.getCount(); i++)
      {
        if (!this.doZooming)
        {
          useFilter = true;
          break;
        }
        var val, res, va;
        va = store.getAt(i);
        if (va === undefined) {
          break;
        }
        val = va.get('a');
        res = true;
        if (minAngle !== null) {res &= (val >= minAngle);}
        if (maxAngle !== null) {res &= (val <= maxAngle);}
        if (res == true)
        {
          if (++cnt > 1)
          {
            useFilter = true;
            break;
          }
        }
      }

      if (useFilter)
      {
        angleAxis.rangeQuery = [minAngle, maxAngle];
        var val, res;
        var me = this;
        store.filterBy(function(item) {
          if (!me.doZooming) {return true;}
          val = item.get('a');
          res = true;
          if (minAngle !== null) {res &= (val >= minAngle);}
          if (maxAngle !== null) {res &= (val <= maxAngle);}
          return res;
        });
      }
      this.V.pointCntAngle.setValue(store.getCount() + '/' + store.getTotalCount());
    }
  },

  resetAngleZoom: function() {
    this.doZooming = false;
    try {
      this.V.maxValueAngle.resumeEvents();
      this.V.minValueAngle.resumeEvents();
      this.V.maxValueAngle.setValue(this.angleRange[1]);
      this.V.minValueAngle.setValue(this.angleRange[0]);
      if (this.rectSelectionAngle) {
        this.rectSelectionAngle.remove();
        this.rectSelectionAngle = null;
      }
    } catch (err) {}
    this.doZooming = true;
  },

  rangeTimeChanged: function(nfield) {
    if (nfield.isValid()) {
      var store = this.V.graphTime.getStore();

      var minTime = (this.V.minValueTime.isValid() ? this.V.minValueTime.getValue() : null) || this.timeRange[0];
      this.V.maxValueTime.setMinValue(minTime);

      var maxTime = (this.V.maxValueTime.isValid() ? this.V.maxValueTime.getValue() : null) || this.timeRange[1];
      this.V.minValueTime.setMaxValue(maxTime);

      var timeAxis = this.V.graphTime.axes.getAt(1);

      var cnt = 0;
      var useFilter = false;
      for (var i = 0; i < store.getCount(); i++)
      {
        if (!this.doZooming)
        {
          useFilter = true;
          break;
        }
        var val, res, va;
        va = store.getAt(i);
        if (va === undefined) {
          break;
        }
        val = va.get('tm');
        res = true;
        if (minTime !== null) {res &= (val >= minTime);}
        if (maxTime !== null) {res &= (val <= maxTime);}
        if (res == true)
        {
          if (++cnt > 1)
          {
            useFilter = true;
            break;
          }
        }
      }

      if (useFilter)
      {
        timeAxis.rangeQuery = [minTime, maxTime];
        var val, res;
        var me = this;
        store.filterBy(function(item) {
          if (!me.doZooming) {return true;}
          val = item.get('tm');
          res = true;
          if (minTime !== null) {res &= (val >= minTime);}
          if (maxTime !== null) {res &= (val <= maxTime);}
          return res;
        });
      }
      this.V.pointCntTime.setValue(store.getCount() + '/' + store.getTotalCount());
    }
  },

  resetTimeZoom: function() {
    this.doZooming = false;
    try {
      this.V.maxValueTime.resumeEvents();
      this.V.minValueTime.resumeEvents();
      this.V.maxValueTime.setValue(this.timeRange[1]);
      this.V.minValueTime.setValue(this.timeRange[0]);
      if (this.rectSelectionTime) {
        this.rectSelectionTime.remove();
        this.rectSelectionTime = null;
      }
    } catch (err) {}
    this.doZooming = true;
  },


  angleMouseUp: function(e) {
    this.handleMouseUp(e, this.V.graphAngle, this.V.minValueAngle, this.V.maxValueAngle);
  },

  angleMouseDown: function(e) {
    this.handleMouseDown(e, this.V.graphAngle, this.V.minValueAngle, this.V.maxValueAngle);
  },

  angleMouseMove: function(e) {
    this.handleMouseMove(e, this.V.graphAngle, this.V.minValueAngle, this.V.maxValueAngle);
  },

  timeMouseUp: function(e) {
    this.handleMouseUp(e, this.V.graphTime, this.V.minValueTime, this.V.maxValueTime);
  },

  timeMouseDown: function(e) {
    this.handleMouseDown(e, this.V.graphTime, this.V.minValueTime, this.V.maxValueTime);
  },

  timeMouseMove: function(e) {
    this.handleMouseMove(e, this.V.graphTime, this.V.minValueTime, this.V.maxValueTime);
  },

  handleMouseDown: function(e, graph, minField, maxField) {
    e.preventDefault();
    if (this.rectSelection) {
      this.rectSelection.remove(); this.rectSelection = null;
    }
    var bbox = graph.chartBBox,
        x = e.browserEvent.layerX, y = e.browserEvent.layerY;
    if (x === undefined || y === undefined)
    {
      if (Ext.isIE)
      {
        x = event.x;
        y = event.y;
      }
    }
    if (x >= bbox.x && x < (bbox.x+bbox.width)) {
      this.rectSelection = graph.surface.add({type:'rect', x :x, y: bbox.y, width: 0, height: bbox.height, fill : '#ffff00', opacity:0.5});
      minField.suspendEvents();
      maxField.suspendEvents();
    }
  },

  handleMouseMove: function(e, graph, minField, maxField) {
    if (this.rectSelection) {
      var serie = graph.series.items[0],
          bbox = graph.chartBBox,
          x = e.browserEvent.layerX, y = e.browserEvent.layerY;
      if (x === undefined || y === undefined)
      {
        if (Ext.isIE)
        {
          x = event.x;
          y = event.y;
        }
      }
      if (x > (bbox.x+bbox.width)) x = (bbox.x+bbox.width);
      if (x < bbox.x) x = bbox.x;
      var newWidth = Math.abs(x-this.rectSelection.x),
          newX = (x >= this.rectSelection.x) ? this.rectSelection.x : x;
      this.rectSelection.setAttributes({x: newX, width: newWidth}, true);

      var minVal = ((newX - bbox.x)/serie.xScale) + serie.minX,
          maxVal = ((newX+newWidth - bbox.x)/serie.xScale) + serie.minX;
      minField.setValue(minVal);
      maxField.setValue(maxVal);
    }
  },


  handleMouseUp: function(e, graph, minField, maxField) {
    e.preventDefault();
    if (this.rectSelection) {
      var serie = graph.series.items[0],
          bbox = graph.chartBBox,
          rectBBox = this.rectSelection.getBBox(),
          x = rectBBox.x,
          width = rectBBox.width;

      this.rectSelection.remove();
      this.rectSelection = null;

      minField.resumeEvents();
      maxField.resumeEvents();

      if (width>0) {
        var minVal = ((x - bbox.x)/serie.xScale) + serie.minX,
            maxVal = ((x+width - bbox.x)/serie.xScale) + serie.minX;

        this.doZooming = true;
        minField.setValue(minVal);
        maxField.setValue(maxVal);

        // Workaround: setValue does not fire event
        if (minField === this.V.minValueAngle) this.rangeAngleChanged(this.V.minValueAngle);
        if (minField === this.V.minValueTime) this.rangeTimeChanged(this.V.minValueTime);
      }
    }
  },

  resetView: function () {
    this.cycleStore.loadData([]);
    this.currCycleNr = -1;
    this.lastStatusCycle = -1;
    this.cycleOkType = this.cycleStore.allCycles;
    this.currentHeaderValues = this.defaultHeaderValues;
    this.V.header.setValues(this.currentHeaderValues);
    this.updateRange(this.currentHeaderValues);
    this.V.graphAngle.getStore().loadData([]);
    this.V.graphTime.getStore().loadData([]);
    this.calcTimeMargins([]);
    this.updateLastStepTimeStartLimit();
    this.angleRange = [null, null];
    this.timeRange = [null, null];
    this.resetAngleZoom();
    this.resetTimeZoom();
    if (this.V.angleCycleId.isValid()) {this.V.angleCycleId.setValue(-1);}
    if (this.V.timeCycleId.isValid()) {this.V.timeCycleId.setValue(-1);}
  },

  //Store graph Angle
  getCyclesStore: function() {
    var me = this;
    this.cycleStore = this.getGraphCycleStoreStore();
    this.cycleStore.load({
      callback: function(records, operation, success) {
        if (records === null && !success){me.resetView();}
        me.updateAngleNavBtn(me.currCycleNr);
        me.updateTimeNavBtn(me.currCycleNr);
        me.setDataCount();
        me.lastStatusCycle = me.cycleStore.getLastCycle();
        if ((me.currCycleNr < 0 && me.lastStatusCycle > 0) || (me.currCycleNr > 0 && !me.cycleStore.isValid(me.cycleStore.allCycles, Number(me.currCycleNr))))
        {
          me.V.angleCycleId.setValue(-1);
          me.V.angleCycleId.setValue(me.lastStatusCycle);
        }
      }
    });
  },

  refreshCycleClicked: function() {
    this.getCyclesStore();
  },


  firstCycleClicked: function() {
    var cycleid = this.cycleStore.getFirst(this.cycleOkType);
    if (cycleid > 0)
    {
      this.V.angleCycleId.setValue(cycleid);
    }
  },


  nextCycleClicked: function() {
    var cycleid = this.cycleStore.getNext(this.cycleOkType);
    if (cycleid > 0)
    {
      this.V.angleCycleId.setValue(cycleid);
    }
  },


  angleCycleIdChanged: function() {
    if (this.V.angleCycleId.isValid())
    {
      this.updateValues(this.V.angleCycleId.value);
      this.cycleStore.updateIndex(Number(this.V.angleCycleId.value));
    }
    this.V.timeCycleId.setValue(this.V.angleCycleId.value);
  },


  timeCycleIdChanged: function() {
    if (this.V.timeCycleId.isValid())
    {
      this.updateValues(this.V.timeCycleId.value);
      this.cycleStore.updateIndex(Number(this.V.timeCycleId.value));
    }
    this.V.angleCycleId.setValue(this.V.timeCycleId.value);
  },


  prevCycleClicked: function() {
    var cycleid = this.cycleStore.getPrev(this.cycleOkType);
    if (cycleid > 0)
    {
      this.V.angleCycleId.setValue(cycleid);
    }
  },


  lastCycleClicked: function() {
    var cycleid = this.cycleStore.getLast(this.cycleOkType);
    if (cycleid > 0)
    {
      this.V.angleCycleId.setValue(cycleid);
    }
  },

  setDataCount: function() {
    this.V.txtAngleDataCount.setValue(this.cycleStore.getCount(this.cycleOkType));
    this.V.txtTimeDataCount.setValue(this.cycleStore.getCount(this.cycleOkType));
},

  rbAngleOKStatusChanged: function (radiogroup, value) {
    switch (value.rbAngleOKStatus)
    {
      case 2:
        this.cycleOkType = this.cycleStore.onlyOkCycles;
        break;
      case 3:
        this.cycleOkType = this.cycleStore.onlyNotOkCycles;
        break;
      default:
        this.cycleOkType = this.cycleStore.allCycles;
        break;
    }
    this.setDataCount();
    //force update and validate
    var cycleid = this.cycleStore.getLast(this.cycleOkType);
    this.V.angleCycleId.setValue(-1);
    if (cycleid > 0){
      this.V.angleCycleId.setValue(cycleid);
    }
    this.V.rgTimeOKStatus.setValue({rbTimeOKStatus:value.rbAngleOKStatus});
  },


  rbTimeOKStatusChanged: function (radiogroup, value) {
    switch (value.rbTimeOKStatus)
    {
      case 2:
        this.cycleOkType = this.cycleStore.onlyOkCycles;
        break;
      case 3:
        this.cycleOkType = this.cycleStore.onlyNotOkCycles;
        break;
      default:
        this.cycleOkType = this.cycleStore.allCycles;
        break;
    }
    this.setDataCount();
    //force update and validate
    var cycleid = this.V.timeCycleId.value;
    this.V.timeCycleId.setValue(-1);
    this.V.timeCycleId.setValue(cycleid);
    this.V.rgAngleOKStatus.setValue({rbAngleOKStatus:value.rbTimeOKStatus});
  },

  validationMsg: function(cycleid) {
    var limits = this.cycleStore.getLimits(this.cycleOkType, Number(cycleid));
    if (limits.length === 2)
    {
      var lower = limits[0];
      var upper = limits[1];
      if (lower < 0 && upper < 0)
      {
        return(TR('Invalid cycle value: no data available'));
      }
      if (lower < 0)
      {
        return(TR('Invalid cycle value: next valid value is:') + ' ' + upper);
      }
      if (upper < 0)
      {
        return(TR('Invalid cycle value: next valid value is:') + ' ' + lower);
      }
      return(TR('Invalid cycle value: next valid limits are:') + ' [' + lower + ', ' + upper + ']');
    }
    return(TR('Invalid cycle value'));
  },

  updateAngleNavBtn: function(cycleid)
  {
      if (this.cycleStore.getCount(this.cycleOkType) < 2)
      {
        this.V.firstAngleCycle.setDisabled(true);
        this.V.prevAngleCycle.setDisabled(true);
        this.V.lastAngleCycle.setDisabled(true);
        this.V.nextAngleCycle.setDisabled(true);
      }
      else if (this.cycleStore.isFirst(this.cycleOkType, Number(cycleid)))
      {
        this.V.firstAngleCycle.setDisabled(true);
        this.V.prevAngleCycle.setDisabled(true);
        this.V.lastAngleCycle.setDisabled(false);
        this.V.nextAngleCycle.setDisabled(false);
      }
      else if (this.cycleStore.isLast(this.cycleOkType, Number(cycleid)))
      {
        this.V.firstAngleCycle.setDisabled(false);
        this.V.prevAngleCycle.setDisabled(false);
        this.V.lastAngleCycle.setDisabled(true);
        this.V.nextAngleCycle.setDisabled(true);
      }
      else
      {
        this.V.firstAngleCycle.setDisabled(false);
        this.V.prevAngleCycle.setDisabled(false);
        this.V.lastAngleCycle.setDisabled(false);
        this.V.nextAngleCycle.setDisabled(false);
      }
  },

  validateAngleCycleId: function(cycleid) {
    if (this.cycleStore.isValid(this.cycleOkType, Number(cycleid)))
    {
      this.updateAngleNavBtn(cycleid);
      return (true);
    }
    return (this.validationMsg(cycleid));
  },

  updateTimeNavBtn: function(cycleid)
  {
      if (this.cycleStore.getCount(this.cycleOkType) < 2)
      {
        this.V.firstAngleCycle.setDisabled(true);
        this.V.prevAngleCycle.setDisabled(true);
        this.V.lastAngleCycle.setDisabled(true);
        this.V.nextAngleCycle.setDisabled(true);
      }
      else if (this.cycleStore.isFirst(this.cycleOkType, Number(cycleid)))
      {
        this.V.firstTimeCycle.setDisabled(true);
        this.V.prevTimeCycle.setDisabled(true);
        this.V.lastTimeCycle.setDisabled(false);
        this.V.nextTimeCycle.setDisabled(false);
      }
      else if (this.cycleStore.isLast(this.cycleOkType, Number(cycleid)))
      {
        this.V.firstTimeCycle.setDisabled(false);
        this.V.prevTimeCycle.setDisabled(false);
        this.V.lastTimeCycle.setDisabled(true);
        this.V.nextTimeCycle.setDisabled(true);
      }
      else
      {
        this.V.firstTimeCycle.setDisabled(false);
        this.V.prevTimeCycle.setDisabled(false);
        this.V.lastTimeCycle.setDisabled(false);
        this.V.nextTimeCycle.setDisabled(false);
      }
  },

  validateTimeCycleId: function(cycleid) {
    if (this.cycleStore.isValid(this.cycleOkType, Number(cycleid)))
    {
      this.updateTimeNavBtn(cycleid);
      return (true);
    }
    return (this.validationMsg(cycleid));
  },

  activated: function()
  {
    this.isShowing = true;
    if (this.checkresults === true){
      this.checkresults = false;
      this.getCyclesStore();
    }
  },

  deactivated: function()
  {
    this.isShowing = false;
    this.checkresults = false;
  }
});
