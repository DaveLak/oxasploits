# -*- coding: cp1252 -*-
'''
Created on 20.10.2011

@author: sth2mt
'''
import FertigungsTest.Hardware.DatenBus.I2CDev as i2c
import struct as struct


class Treiber(object):
    '''
    classdocs
    '''
    # Achtung dies ist Pseudo Singleton -> variablen werden statisch verwendet. Aufgeraumt wird erst wenn alle instanzen weg sindwird nur einmal instaniiert !!!!
    ObjCount = 0
    _Thread_name = "AD7999"
    stout = False
    O_I2C = None
    s_PathADCValue = "/proc/nexoctrl/"
    s_nameCh = "adcval"
    s_PathChannel = None
    f_ADCValues = file
    MAINSWITCH = 0
    RL_SWITCH = 1
    CURRENT = 2
    BATTERY = 3
    ERR_LT = 4
    ERR_KERNEL = 5
    

    def __init__(self):
        '''
        Constructor
        '''
        Treiber.ObjCount += 1
        self.printf("%i.Construktor %s Anzahl" % (Treiber.ObjCount,Treiber._Thread_name))
        if Treiber.O_I2C == None:
            #I2C Bus Nr 2 ->"/dev/i2c-2"
            Treiber.O_I2C = i2c.Treiber(2)
        
        
    def __del__(self):
        '''
        Destructor
        '''
        self.printf("%i Destruktor %s" % (Treiber.ObjCount,Treiber._Thread_name))
            
        if Treiber.ObjCount == 1:
            self.printf("Reste aufraumen")
            if Treiber.O_I2C != None:
                del(Treiber.O_I2C)
            Treiber.O_I2C = None

        if Treiber.ObjCount > 0:
            Treiber.ObjCount -= 1
            
        pass


    def readAnalog(self,iRxChannel):
        # Spannung einlesen
        if (iRxChannel < 0) & (iRxChannel >3):
            return -1
        o_adcVal=self.Read()
        
        #Kanal rauslesen
        i_RxData=0
        
        if iRxChannel == Treiber.MAINSWITCH:
            i_RxData=o_adcVal[0]>>2
        if iRxChannel == Treiber.RL_SWITCH:
            i_RxData=o_adcVal[0]&0x03
        if iRxChannel == Treiber.CURRENT:
            i_RxData=o_adcVal[1]
        if iRxChannel == Treiber.BATTERY:
            i_RxData=o_adcVal[3]
        if iRxChannel == Treiber.ERR_LT:
            i_RxData=o_adcVal[2]
        if iRxChannel == Treiber.ERR_KERNEL:
            i_RxData=o_adcVal[4]
        
        self.printf( "readSchalterAnalog Channel %i Value %i" % (iRxChannel ,i_RxData) )
        return i_RxData
        pass

    def Open(self):
        try:
            if self.closed():
                Treiber.f_ADCValues = open(self.GetPath(),"r+b")
            self.printf( "AD7999.Open(%s,""r+"")" % self.GetPath())
            return True
        except IOError,e:
            print "AD7999.Open(%s,""r+"") %s" %(self.GetPath(), e)
            return False
        pass
    
    def GetPath(self):

            s_Path=Treiber.s_PathADCValue+Treiber.s_nameCh
            self.printf ("AD7999.GetPath() %s" %(s_Path))
            
            return s_Path
        
        

    def Close(self):
        try:
            if self.closed():
                return True
            Treiber.f_ADCValues.close()
            self.printf( "AD7999.close() %s" % self.GetPath())
            return True
        except IOError,e:
            print "AD7999.close() %s %s" %(self.GetPath(), e)
            return False
        pass

    def Read(self):
        try:
            s_value = 0
            if self.closed():
                self.Open()
            o_Messwerte = struct.pack('=BhBBB',0,0,0,0,0)
            length = struct.calcsize('=BhBBB')

            o_Messwerte = Treiber.f_ADCValues.read(length)
            self.printf( "AD7999.Read() %s" % (self.GetPath()))
            if len(o_Messwerte) != length :
                self.printf("%s.Read() len(o_Messwerte)=%i length=%i readTimeout"%(Treiber._Thread_name,len(o_Messwerte),length))

            self.Close()
            self.printf("%s.Read() o_Messwerte=%s"%(Treiber._Thread_name,o_Messwerte))
            s_value = struct.unpack('=BhBBB',o_Messwerte)
            self.printf("o_Messwerte=%i,%i,%i,%i,%i" % s_value)
           
            return s_value
        except IOError,e:
            print "AD7999.Read() %s %s" %(self.GetPath(), e)
            return s_value
        pass

    
    def closed(self):
        return Treiber.f_ADCValues.closed
    
    def printf(self,string):
        if Treiber.stout:
            print string
        pass
