# -*- coding: cp1252 -*-
'''
Created on 24.11.2011

@author: sth2mt
'''

import time
import threading
import thread
from ctypes import pythonapi, py_object, c_char
import FertigungsTest.GUI.Display as Display
import FertigungsTest.Hardware.StartSchalter as StartSchalter
import FertigungsTest.Hardware.LtInterface as LtInterface
import FertigungsTest.Hardware.BedienTasten as Key_Evn
import FertigungsTest.Hardware.MesswerteInterface as MWG
import FertigungsTest.Hardware.Typschild as Typschild



# <Command>MotTst</Command>
# <Command>exit</Command>

def kill(thread,iStopTimeout,tid):
    if thread:
        thread.printf ("kill iStopTimeout=%d"%iStopTimeout)
        time.sleep(iStopTimeout)
        #nach 30s hart beenden
        if thread.isAlive():
            
            res = pythonapi.PyThreadState_SetAsyncExc(tid,py_object(SystemExit))
            if res == 0:
                raise ValueError("nonexistent thread id (%s)" % thread._Thread_name)
            elif res > 1:
                pythonapi.PyThreadState_SetAsyncExc(tid,0)
                raise SystemError("PyThreadState_SetAsyncExc failed")
            else :
                thread.printf ("kill Thread %s" % thread._Thread_name)
                thread.errorcode=1300
                thread.isTimeout=True
                thread.__del__()
        else:
            thread.printf ( "kill %s not allive" % thread._Thread_name)
    else:
        print "kill: no handle"
   
        

    

class Prueffunktionen(threading.Thread):
    
    '''
    classdocs
    '''
    def __init__(self, O_Parser,O_Serializer,param=None):
        '''
        Constructor
        '''
        threading.Thread.__init__(self)
        super(Prueffunktionen,self).__init__()
        self._EventStop = threading.Event()
        self._Thread_name = "MotTst"
        self.stout = False
        self.printf( "Constructor %s" % self._Thread_name)
        self.iStopTimeout = 3 # Stop Timeout bis zum Kill
        self.iTimeout = 80 # Timeout bis Abbruch
        self.errorcode=1300 # Fehlercode vorbelegen, Wenn Ok wird zurueckgesetzt
        self.isTimeout=False
        self.Drehdauerin_sec=5.0 # Drehdauer des Motor in s
        self.SolldrehzahlProzent=0.8# 80 Prozent von Nenndrehzahl
        
        
        
        self.O_XmlParser = O_Parser
        self.O_XML_Cmd = O_Serializer
        self.O_Display = Display.Treiber()
        self.O_Startschalter = StartSchalter.Treiber()
        self.O_Key_Evn = Key_Evn.Treiber()
        
        self.O_LT = LtInterface.Treiber()
        self.O_MWG = MWG.Treiber()
        self.O_Typschild = Typschild.Treiber()

        # Schrauberdaten aus Typschild lesen
        s_Brc_Typschild = self.O_Typschild.ReadBrcStatParFromEeprom()
        self.MomentLeerlaufMax = self.O_MWG.f_getSpindelNennmoment() * self.O_Typschild.getStatValue(s_Brc_Typschild,"MomentLeerlaufMax")/100.0
        self.printf("MomentLeerlaufMax=%2.2f"%(self.MomentLeerlaufMax))

        #max zulässiges Leerlaufmoment in % von Nennmoment
        self.DrehzahlAbweichung=self.O_Typschild.getStatValue(s_Brc_Typschild,"DrehzahlAbweichung")
        # max zulässige Drehzahlabweichung in % von Max Drehzahl
        self.SpindelNennDrehzahl=self.O_LT.GetSpindelNennDrehzahl()*self.SolldrehzahlProzent
        self.printf("DrehzahlAbweichung=%2.2f"%(self.DrehzahlAbweichung))
        if self.SpindelNennDrehzahl < 0 :
            self.MomentLeerlaufMax = self.MomentLeerlaufMax * (-1)
            self.DrehzahlAbweichung = self.SpindelNennDrehzahl * (-1)

        self.O_Display.setHeadlines("diagnosis tools","speed measurement")
  

        self.O_Display.paintDisplay()

        self.printf( "Constructor %s Ende" % self._Thread_name)
        
        pass
    
    def __del__(self):
        
        '''
        Destructor
        '''
        if self.errorcode==0:
            sAbruchGrund="OK"
        elif self.errorcode==1301:
            sAbruchGrund="NOK Lesefehler Messwelle"
        elif self.errorcode==1304:
            sAbruchGrund="NOK LerrLaufMoment zu hoch"
        elif self.errorcode==1303:
            sAbruchGrund="NOK Drehzahl"
        elif self.errorcode==1305:
            sAbruchGrund="NOK Schalter losgelassen"
        else :
            sAbruchGrund="NOK"
             
        self.printf( "Destructor %s" % self._Thread_name)
        self.printf( "Timeout %i, self._EventStop.isSet() %i"%(self.isTimeout,self._EventStop.isSet()))

        # Display bedienen
        if (self.isTimeout | self._EventStop.isSet()):
            #Abbruch der Funktion -> Fehler anzeigen
            if self._EventStop.isSet():
                sAbruchGrund="Abort"
                self.O_Display.setAction(sAbruchGrund,"","")
            else:
                #Timeout der Funktion -> Fehler anzeigen
                sAbruchGrund="Timeout"
                self.O_Display.setAction(sAbruchGrund,"","")
            self.O_Display.setOKNOK(0)
            self.O_Display.clrSelect()

        print "%s"%self.O_XML_Cmd.BuildRueckgabewert(self._Thread_name,"%s %s"%(self._Thread_name,sAbruchGrund),None,self.errorcode,None)
        
        self.O_Display.paintDisplay()
        
        del(self.O_Typschild)
        del(self.O_MWG)
        del(self.O_LT)
        del(self.O_Key_Evn)
        del(self.O_Startschalter)
        del(self.O_Display)

        # Belegung der Prueffunktion im Parseer objekt loeschen -> Freigabe
        self.O_XmlParser.AktivePrueffunktion=None
        pass

        
    
    def stop(self):
        # Thread normal beenden
        self.printf("stop")
        if self.isAlive():
            self._EventStop.set()
            # Kill-thread falls dieser thread sich nicht nach 30s beendet
            for tid, tobj in threading._active.items():
                if tobj is self:
                    thread.start_new_thread(kill,(self,self.iStopTimeout,tid))
        #print "stop Ende"
        pass
    
    def run(self):
        # Ablauf starten
        self.printf("Ablauf starten")
        print "%s"%self.O_XML_Cmd.BuildTimeout(self.iTimeout,self._Thread_name)
        print "%s"%self.O_XML_Cmd.BuildPrintMainText("Motor drehen pruefen")
        
        # Watchdogtimer anstarten -> beendet Thread nach timeout
        for tid, tobj in threading._active.items():
            if tobj is self:
                thread.start_new_thread(kill,(self,self.iTimeout-self.iStopTimeout-1,tid))

        self.Ablauf()
        self.printf("Nach Ablauf")
        self.__del__()
        pass
    
    def stopped(self):
        return self._EventStop.isSet()


    def Ablauf(self):
        self.printf("Motor drehen rechts")
        self.O_Display.ResetLastError()
        self.O_Display.setActionLP("Push toolswitch for_%is",None,None,self.Drehdauerin_sec)
        self.O_Display.setFortschritt(1)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(1)
        moment = 0.1
        winkel = 1
        SampleTime = 2
        status = 0
        momentmax=0
        statusfehler=0

        #Warten mit Anstarten bis Startschalter betätigt
        self.O_Startschalter.Wait(True,self.stopped)
        if not self.stopped():
            self.O_LT.SetDrehzahl(self.SpindelNennDrehzahl)
            #Motor drehen
            self.O_MWG.f_SetSrbMod(True) # Messung starten
            self.O_LT.start() 
            time.sleep(0.5) # Warten bis Drehzahl erreicht -> Hochlaufzeit
            startzeit=time.time() # Messzeit Scharfschalten
            (status,moment, winkel, SampleTime)=self.O_MWG.f_GetMesswerte()
            startwinkel=winkel
            restzeit=self.Drehdauerin_sec
            while ((restzeit>0)&(self.O_Startschalter.GetZustand(1))):
                for Messwert in range (1,250,1):
                    (status,moment, winkel, SampleTime)=self.O_MWG.f_GetMesswerte()
                    if momentmax<moment:
                        momentmax=moment
                    if status == False:
                        statusfehler = statusfehler + 1
               
                if self.SpindelNennDrehzahl < 0:
                    self.O_Display.setActionRaw(" %2.1fNm   %02d"%(moment,statusfehler),"-%4i\xc2\xb0    %02d"%(winkel,statusfehler),"%2.1fs"%(restzeit))
                else :
                    self.O_Display.setActionRaw(" %2.1fNm   %02d"%(moment,statusfehler)," %4i\xc2\xb0    %02d"%(winkel,statusfehler),"%2.1fs"%(restzeit))
                    
                self.O_Display.setFortschritt(int(((self.Drehdauerin_sec-restzeit)*80/self.Drehdauerin_sec)+10))
                print "%s"%self.O_XML_Cmd.BuildProgressbar(int(((self.Drehdauerin_sec-restzeit)*80/self.Drehdauerin_sec)+10))
                # Andere Prozesse arbeiten lassen
                time.sleep(0.05)
                restzeit=self.Drehdauerin_sec - (time.time() - startzeit)
                
            self.O_Display.setAction("","","")
            (status,moment, winkel, SampleTime)=self.O_MWG.f_GetMesswerte()
            if winkel == 0 :
                (status,moment, winkel, SampleTime)=self.O_MWG.f_GetMesswerte()
                
            self.printf("winkel = %i "%(winkel))

            winkel=winkel-startwinkel
            if self.SpindelNennDrehzahl < 0:
                winkel= winkel * (-1)
            Laufzeit=time.time()-startzeit
            self.O_LT.stop()
            self.O_MWG.f_SetSrbMod(False) # Messung starten

            self.O_Display.setFortschritt(90)
            print "%s"%self.O_XML_Cmd.BuildProgressbar(90)
 
            # Wurde Startschalter schon vorher losgelassen -> Fehler
            if self.O_Startschalter.GetZustand(1):
                self.O_Display.setActionLP("Release tool-switch_!")
                # Warten bis Startschalter losgelassen    
                self.O_Startschalter.Wait(False, self.stopped)
           
                self.O_Display.setAction("","","")
                iSollWinkel=int(self.SpindelNennDrehzahl*Laufzeit*6)
                self.printf("momentmax = %2.2f MomentLeerlaufMax=%2.2f"%(momentmax,self.MomentLeerlaufMax))
                self.printf("winkel = %i iSollWinkel=%i Laufzeit=%2.3fs Drehzahl=%4.1f Solldrehzahl=%4.1f "%(winkel,iSollWinkel,Laufzeit,winkel/Laufzeit/6.0,self.SpindelNennDrehzahl))
            
                if abs(momentmax) <= abs(self.MomentLeerlaufMax):
                    # Leerlaufmoment OK 
                    if abs(winkel) < abs((1+self.DrehzahlAbweichung/100.0) * iSollWinkel) and abs(winkel) > abs((1-self.DrehzahlAbweichung/100.0) * iSollWinkel): #448U/min /60s * 5s *360
                        if statusfehler < 50:
                            #Drehzahl und Winkel OK
                            self.errorcode=0
                        else :
                            #Zu viele Lesefehler Messwelle
                            self.errorcode=self.errorcode+1
                    else :
                        self.printf("NOK !!! winkel = %i iSollWinkel=%i Laufzeit=%2.3fs Drehzahl=%4.1f Solldrehzahl=%4.1f "%(winkel,iSollWinkel,Laufzeit,winkel/Laufzeit/6.0,self.SpindelNennDrehzahl))
                        self.errorcode=self.errorcode+3

                else :
                    self.printf(" NOK !!! momentmax = %2.2f MomentLeerlaufMax=%2.2f"%(momentmax,self.MomentLeerlaufMax))
                    self.errorcode=self.errorcode+4

            else :
                    self.printf(" NOK !!! Startschalter losgelassen")
                    self.errorcode=self.errorcode+5

                
            
            if self.errorcode==0: # Startschalter OK
                self.O_Display.setOKNOK(1)
            else:
                self.O_Display.setOKNOK(0)

        if self.errorcode==0: # Motor OK
            self.O_Display.setSelectLP("Confirm with_to ol_switch")
            self.O_Display.paintDisplay()
            
            #Ergebnis bestaetigen
            self.O_Startschalter.Wait(True,self.stopped)
            # Bildschirm zuruecksetzen auf Default
            self.O_Display.BuildDefaultScreen()
            
        self.O_Display.setFortschritt(100)
        print "%s"%self.O_XML_Cmd.BuildProgressbar(100)

        self.printf("Motor drehen Pr\xc3\xbcfung -> Ende")

        pass

    
    def printf(self,string):
        if self.stout:
            print string
        pass


            
    
    def TestMenue(self,O_Paint):
        if O_Paint:
            #O_Paint.SetTestText(["Startschalter bet\xc3\xa4tigen"])
            O_Paint.SetTestText([u"Startschalter betätigen"])
            O_Paint.Update()
            Input = ' '
            while Input!= "z":
                Input=O_Paint.TestfunktionsEingabe()
                O_Paint.Update()
            
                O_Paint.Update()
                O_Paint.ClearTestText()
                return Input

        pass

    



pass                               