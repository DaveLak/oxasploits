#!/bin/sh
# eeprom Messwelle ins Config Verzeichnis umkopieren
# Mount /proc, /sys
BOOTDEVICE=""
MWMotion_DEVICE="false"

RAM_DISK=/var/run
RAM_DISK_DIAG_PATH=$RAM_DISK/diag
WLAN_DIAG_PATH=$RAM_DISK_DIAG_PATH/tiwlan
LT_DIAG_PATH=$RAM_DISK_DIAG_PATH/lt
RCS_LOGFILE=$RAM_DISK/rcs.log
TMP_DIR=$RAM_DISK/tmp

DataMtdNr=7
DataMtdDev=mtd7

rm -r /mnt/mmc/* >/dev/null 2>&1
mount -t proc proc /proc
mount -t sysfs sysfs /sys
# Remount the root filesystem in read-write & sync
mount -o remount,rw /

#ASIX AX88178 USB 2.0 Gigabit Ethernet Network Adapter
#ASIX AX88772 USB 2.0 Fast Ethernet Network Adapter
#ASIX AX88772A USB 2.0 Fast Ethernet Network Adapter
#ASIX AX88760 USB 2.0 MTT HUB and USB 2.0 to Fast Ethernet Combo Controller
#ASIX AX88772B USB 2.0 Fast Ethernet Network Adapter
#ASIX AX88772C USB 2.0 Fast Ethernet Network Adapter
insmod /lib/modules/2.6.33.7-rt29-REXMAS/kernel/drivers/ax88772/asix.ko
if [ "$?" -eq "0" ]; then
  echo "rcS: asix.ko SUCCESS" >> $RCS_LOGFILE
else
  echo "rcS: insmod asix.ko FAILED" >> $RCS_LOGFILE
  if [ "$?" -ne 0 ]; then
    rmmod asix.ko
  fi
fi


# AX88179 - usb-ethernet Adapter 
insmod /lib/modules/2.6.33.7-rt29-REXMAS/kernel/drivers/ax88179/ax88179_178a.ko
if [ "$?" -eq "0" ]; then
  echo "rcS: ax88179_178a.ko SUCCESS" >> $RCS_LOGFILE
else
  echo "rcS: insmod ax88179_178a.ko FAILED" >> $RCS_LOGFILE
  if [ "$?" -ne 0 ]; then
    rmmod ax88179_178a
  fi
fi

# Populate /dev
mount -t tmpfs mdev /dev
echo /sbin/mdev > /proc/sys/kernel/hotplug
/sbin/mdev -s

# Debug Filesystem mounten
mount -t debugfs debugfs /sys/kernel/debug/

# Create PTS'
mkdir /dev/pts
mount -t devpts /dev/pts /dev/pts

mkdir $RAM_DISK > /dev/null 2>&1
mount -t ramfs ramfs $RAM_DISK
dd if=/dev/zero of=$RAM_DISK
echo "START rcS Skript" >> $RCS_LOGFILE

# diag verzeichnisse in der Ramdisk anlegen
mkdir $RAM_DISK_DIAG_PATH &> /dev/null
mkdir $WLAN_DIAG_PATH &> /dev/null
mkdir $LT_DIAG_PATH &> /dev/null

# Diagnose Daten wlan erzeugen
echo false > $WLAN_DIAG_PATH/interface
echo false > $WLAN_DIAG_PATH/fccmode
echo -1 > $WLAN_DIAG_PATH/constatus
echo -1 > $WLAN_DIAG_PATH/rssi

#default prgnr eintragen
echo -1 > $RAM_DISK_DIAG_PATH/prgnr

# tmp Verzeichnis in der RAM Disk anlegen
mkdir $TMP_DIR
rm -r /tmp
ln -s $TMP_DIR /tmp


# Bootdevice feststellen
cat /proc/cmdline | grep 'rootfs=/dev/nfs' > /dev/null 2>&1
if [ "$?" -eq "0" ]; then
  echo "rcS: cmdline = NFS" >> $RCS_LOGFILE 
  BOOTDEVICE="NFS"
fi
cat /proc/cmdline | grep 'root=/dev/mmcblk0p' > /dev/null 2>&1
if [ "$?" -eq "0" ]; then
  echo "rcS: cmdline = MMC" >> $RCS_LOGFILE 
  BOOTDEVICE="MMC"
fi
cat /proc/cmdline | grep 'root=ubi0:rootfs' > /dev/null 2>&1
if [ "$?" -eq "0" ]; then
  echo "rcS: cmdline = NAND" >> $RCS_LOGFILE 
  BOOTDEVICE="NAND"
fi


#####################################MFU-Boot Modus pruefen################
BOOTCFG="0"
ls -al /mnt/mmc/mmcblk0p1/MFU-Pruefung.jpg > /dev/null 2>&1
if [ "$?" -eq "0" ]; then
  #echo "/mnt/mmc/mmcblk0p1/MFU-Pruefung.jpg vorhanden !"
  md5sum /mnt/mmc/mmcblk0p1/MFU-Pruefung.jpg | grep 'f74814a601657c72c55613e3062b8a62' > /dev/null 2>&1
  if [ "$?" -eq "0" ]; then
    echo "rcS: ****************************************************************" >> $RCS_LOGFILE
    echo "rcS: ************** M F U  -  M O D U S - PLANT *********************" >> $RCS_LOGFILE
    echo "rcS: ****************************************************************" >> $RCS_LOGFILE
    BOOTCFG="1"
  else
    md5sum /mnt/mmc/mmcblk0p1/MFU-Pruefung.jpg | grep 'ec4e963ee76a84fa488a62593ab19329' > /dev/null 2>&1
    if [ "$?" -eq "0" ]; then
      echo "rcS: ****************************************************************" >> $RCS_LOGFILE 
      echo "rcS: ************** M F U  -  M O D U S - SERVICE *******************" >> $RCS_LOGFILE 
      echo "rcS: ****************************************************************" >> $RCS_LOGFILE 
      BOOTCFG="2"
    else
      md5sum /mnt/mmc/mmcblk0p1/MFU-Pruefung.jpg | grep '0671ee027bdadf10eec3d5e20e19a69d' > /dev/null 2>&1
      if [ "$?" -eq "0" ]; then
	if [ "$BOOTDEVICE" == "NFS" ]; then
	  echo "rcS: ****************************************************************" >> $RCS_LOGFILE 
	  echo "rcS: ************* NFS EXPERT  -  M O D U S - SERVICE ***************" >> $RCS_LOGFILE 
	  echo "rcS: ****************************************************************" >> $RCS_LOGFILE 
	  BOOTCFG="3"
	fi
	if [ "$BOOTDEVICE" == "MMC" ]; then
	  echo "rcS: ****************************************************************" >> $RCS_LOGFILE 
	  echo "rcS: ************* MMC EXPERT  -  M O D U S - SERVICE ***************" >> $RCS_LOGFILE 
	  echo "rcS: ****************************************************************" >> $RCS_LOGFILE 
	  BOOTCFG="3"
	fi
      fi
    fi
  fi
fi

# Falls wir im Service Reperatur Vollmodus von SDKarte booten
if [ "$BOOTCFG" -eq "3" ]; then
  # Expert - Modus - SERVICE
  echo "rcS: Service Master Expert BOOT" >> $RCS_LOGFILE
  
  if [ "$BOOTDEVICE" == "NFS" ]; then
    # tmp Verzeichnis in der RAM Disk loeschen und auf rootfs anlegen
    rm -r /tmp
    mkdir /tmp
  fi
   
  # Existiert data Verzeichnis ?
  ls /mnt/data > /dev/null 2>&1
  if [ "$?" -ne "0" ]; then
    echo "rcS: data Verzeichnis existiert nicht -> anlegen " >> $RCS_LOGFILE
    mkdir /mnt/data
  fi
  # Existiert config Verzeichnis ?
  ls /mnt/data/config > /dev/null 2>&1
  if [ "$?" -ne "0" ]; then
    echo "rcS: config Verzeichnis existiert nicht -> anlegen " >> $RCS_LOGFILE
    mkdir /mnt/data/config
  fi
  # Existiert MfuConfig Verzeichnis ?
  ls /mnt/data/config/MfuConfig > /dev/null 2>&1
  if [ "$?" -ne "0" ]; then
    echo "rcS: MfuConfig Verzeichnis existiert nicht -> anlegen " >> $RCS_LOGFILE
    mkdir /mnt/data/config/MfuConfig
  fi

  # Existiert log Verzeichnis ?
  ls /mnt/data/log > /dev/null 2>&1
  if [ "$?" -ne "0" ]; then
    echo "rcS: log Verzeichnis existiert nicht -> anlegen " >> $RCS_LOGFILE
    mkdir /mnt/data/log
  fi

  ls /home/tool/config_mmc &> /dev/null
  if [ "$?" -eq "1" ]; then
    # Verzeichnis existiert noch nicht ... prepare Epertenmodus
    echo "rcS: **** PREPARE S E R V I C E  -  E X P E R T - B O O T C O N F I G ****" >> $RCS_LOGFILE
    # Orginal Config in MfuConfig kopieren
    cp -f -r /home/tool/config/* /mnt/data/config/MfuConfig/
    # spezielle MFU Config in /mnt/data/config/MfuConfig kopieren
    cp -r -f /mnt/data/config/MfuConfig/mfu/service/* /mnt/data/config/MfuConfig
    # lokale Änderung der MFU Config von arte nach /mnt/data/config/MfuConfig kopieren
    cp -r -f /mnt/mmc/mmcblk0p1/config/* /mnt/data/config/MfuConfig
    # Konfiguration symbolisch temporaer auf /mnt/data/config/MfuConfig verlinken
    mv -f /home/tool/config /home/tool/config_mmc
    ln -s /mnt/data/config/MfuConfig /home/tool/config
    # ChanCfg.json symbolisch aus /mnt/data/config/MfuConfig auf Orginal ChanCfg.json verlinken
    rm /mnt/data/config/MfuConfig/ChanCfg.json 
    ln -s /home/tool/config_mmc/ChanCfg.json /mnt/data/config/MfuConfig/ChanCfg.json
    mkdir /Images
    cd /home/tool/config
    mkdir service
    cd service
    mkdir FwPack
  else
    echo "rcS: EXPERT  -  M O D U S - SERVICE bereits konfiguriert" >> $RCS_LOGFILE 
  fi
else
  # kein MFU-Modus
  ls /home/tool/config_mmc &> /dev/null
  if [ "$?" -eq "0" ]; then
    echo "rcS: rcS: ********* RESTORE  N O R M A L - B O O T C O N F I G   *********" >> $RCS_LOGFILE 
    # vorherigen lokalen Ordner auf mmc /mnt/data/config loeschen
    rm -r /mnt/data/config/ -f
    rm -r /Images/ -f
    # Backup Verzeichnis config_mmc existiert -> restore config Ordner
    rm -r /home/tool/config
    mv -f /home/tool/config_mmc /home/tool/config
  fi
fi


###########################################################################
# Partition 'data' nicht bei Booten über Fertigungprüfstand einbinden da dort gelöscht werden muss
cat /proc/cmdline | grep '/usr/local/src/nfsboot/' > /dev/null 2>&1
if [ "$?" -ne "0" ]; then
########### Partition 'data' einbinden ####################################
  if [ "$BOOTCFG" -ne "3" ]; then
    echo "rcS: Nand Partition fest an ubi device 1 binden" >> $RCS_LOGFILE 
    
    # Nand Partition fest an ubi device 1 binden
    UBIDEV=ubi1
    ubiattach /dev/ubi_ctrl -m $DataMtdNr -d 1
    mount -t ubifs $UBIDEV:data /mnt/data

    if [ "$?" -ne "0" ]; then
      echo "rcS: MOUNT DATA PARTION $UBIDEV FAILED" >> $RCS_LOGFILE
      echo "rcS: versuch volume anlegen" >> $RCS_LOGFILE
      ubimkvol /dev/$UBIDEV -N data -m
      echo "rcS: neuer mount Versuch $UBIDEV ..." >> $RCS_LOGFILE
      mount -t ubifs $UBIDEV:data /mnt/data
      if [ "$?" -eq "0" ]; then
	echo "rcS: .. Success" >> $RCS_LOGFILE
	MNT="OK"
      else     
	ubidetach /dev/ubi_ctrl -m $DataMtdNr
	ubiformat /dev/$DataMtdDev
	ubiattach /dev/ubi_ctrl -m $DataMtdNr -d 1
	sleep 1
	ubimkvol /dev/$UBIDEV -N data -m
	mount -t ubifs $UBIDEV:data /mnt/data
	if [ "$?" -eq "0" ]; then
	  echo "rcS: .. data Partition $UBIDEV neu angelegt und eingehaengt!" >> $RCS_LOGFILE
	  MNT="OK"
	else        
	  MNT="NOK"
	fi
      fi
    else
      MNT="OK"
      echo "rcS: MNT = OK" >> $RCS_LOGFILE 
    fi
  else
    echo "rcS: keine Nand Data Partition einbinden -> Service Vollmodus" >> $RCS_LOGFILE 
  fi
fi

if [ "$MNT" == "OK" ]; then
  echo "rcS: MOUNT DATA PARTION SUCCESS" >> $RCS_LOGFILE
  # Existiert log Verzeichnis ?
  ls /mnt/data/log > /dev/null 2>&1
  if [ "$?" -ne "0" ]; then
    echo "rcS: log Verzeichnis existiert nicht -> anlegen " >> $RCS_LOGFILE
    mkdir /mnt/data/log
  fi
  # Existiert config Verzeichnis ?
  ls /mnt/data/config &> /dev/null
  if [ "$?" -ne "0" ]; then
      echo "rcS: config Verzeichnis existiert nicht -> anlegen " >> $RCS_LOGFILE
      mkdir /mnt/data/config
  fi
  
  # Falls wir vom Nand booten, prüfen wir das config Verzeichnis
  if [ "$BOOTDEVICE" == "NAND" ]; then
    echo "rcS: NAND BOOT" >> $RCS_LOGFILE

    # Hatten wir einen FW Update ?
    # Nur prüfen, wenn wir von Nand booten! 
    # Problem: 
    #   wenn ein FW Update gemacht wird und das rootfs ist von NFS eingebunden oder der Schrauber bootet von SD-Karte,
    #   kann das config Verzeichnis verbogen werden -> z.B /etc/version beinhaltet ander Version!    
    ls /mnt/data/fw &> /dev/null
    if [ "$?" -eq "0" ]; then
      echo "rcS: FIRMWARE UPDATE" >> $RCS_LOGFILE     
      lastversion=`cat /mnt/data/lastFwVersion`
      mount -o remount,rw /
      # config Verzeichnis aktualisieren
      SUBDIR=`cat /etc/version`
      MAJOR_CURR_VERSION=`cut -c7-10 /etc/version`
      # FW Update: war die Version schon mal auf dem Schrauber ?
      ls -al /mnt/data/config | grep -w $SUBDIR
      if [ "$?" -eq "0" ]; then
        # ... ja, dann nehmen wir das config Verzeichnis! -> eigenes Config Verzeichnis loeschen und bestehendes verlinken!
	echo "rcS: FW Version <$SUBDIR> war schon mal aktiv" >> $RCS_LOGFILE
        DIR=/mnt/data/config/$SUBDIR
        rm -r /home/tool/config
        ln -s $DIR /home/tool/config 	
      else
        # .... nein, dann nehmen wir unseres 
	DIR=/mnt/data/config/$SUBDIR
	cp -r /home/tool/config $DIR
	rm -r /home/tool/config
	ln -s $DIR /home/tool/config   	
        # Uebernahme von Konfigurationendateien, falls kompatibel
        #########################################################
        
        MAJOR_LAST_VERSION=`cut -c7-10 /mnt/data/lastFwVersion`
        if [ -n "${MAJOR_LAST_VERSION}" ]; then
          if [ "${MAJOR_LAST_VERSION}" -le "${MAJOR_CURR_VERSION}" ]; then
            SRC=/mnt/data/config/$lastversion
            #fuer die webgui die letzte version fuer auth.sq3 Merge wegsichern
            echo 'lastcfg="'$SRC'"' > /mnt/data/config/postupdate
            /etc/fwupdate/merger.sh $SRC $DIR
            #Kanalkonfiguration kopieren
            cp $SRC/ChanCfg.json $DIR
            #Prg selection kopieren
            cp $SRC/GuiPrgSelection.json $DIR
            echo "rcS: akutelles config Verzeichnis $DIR" >> $RCS_LOGFILE
          fi
        fi
      fi
      for i in `ls /mnt/data/config`; do
	if [ -n "$i" ] && [ "$i" != "$SUBDIR" ] && [ "$i" !=  "$lastversion" ] && [ "$i" != "postupdate" ]; then
	  echo  "rcS: Removes old config directory /mnt/data/config/$i" >> $RCS_LOGFILE
	  rm -fr "/mnt/data/config/$i"
	fi
      done      
    else
      SUBDIR=`cat /etc/version`
      DIR=/mnt/data/config/$SUBDIR
      ls $DIR &> /dev/null
      if [ "$?" -eq "0" ]; then
        # Verzeichnis existiert ... check ob Link passt ...
	ls -al /home/tool/ | grep 'config -> '$DIR'' &> /dev/null
	if [ "$?" -ne "0" ]; then
	  # existiert nicht , neu verlinken ...
	  rm -r /home/tool/config
	  ln -s $DIR /home/tool/config   
	  echo "rcS: Link des config Verzeichnis fehlt ... neu verlinkt <$DIR>" >> $RCS_LOGFILE  	
	fi
	if [ "$BOOTCFG" -eq "1" ]; then
	  #MFU-Modus - PLANT
	  # Orginal Config in MfuConfig kopieren
	  cp -r -f /mnt/data/config/$SUBDIR/ /mnt/data/config/MfuConfig
	  # spezielle MFU Config in /mnt/data/config/MfuConfig kopieren
	  cp -r -f /mnt/data/config/$SUBDIR/mfu/plant/* /mnt/data/config/MfuConfig
	  # Konfiguration symbolisch temporaer auf /mnt/data/config/MfuConfig verlinken
	  rm -r /home/tool/config
	  ln -s /mnt/data/config/MfuConfig /home/tool/config
	  # ChanCfg.json symbolisch aus /mnt/data/config/MfuConfig auf Orginal ChanCfg.json verlinken
	  rm /mnt/data/config/MfuConfig/ChanCfg.json 
	  ln -s /mnt/data/config/$SUBDIR/ChanCfg.json /mnt/data/config/MfuConfig/ChanCfg.json
	else 
	  if [ "$BOOTCFG" -eq "2" ]; then
	    #MFU-Modus - SERVICE
	    # Orginal Config in MfuConfig kopieren
	    cp -r -f /mnt/data/config/$SUBDIR/ /mnt/data/config/MfuConfig
	    # spezielle MFU Config in /mnt/data/config/MfuConfig kopieren
	    cp -r -f /mnt/data/config/$SUBDIR/mfu/service/* /mnt/data/config/MfuConfig
	    # lokale Änderung der MFU Config von arte nach /mnt/data/config/MfuConfig kopieren
	    cp -r -f /mnt/mmc/mmcblk0p1/config/* /mnt/data/config/MfuConfig
	    # Konfiguration symbolisch temporaer auf /mnt/data/config/MfuConfig verlinken
	    rm -r /home/tool/config
	    ln -s /mnt/data/config/MfuConfig /home/tool/config
	    # ChanCfg.json symbolisch aus /mnt/data/config/MfuConfig auf Orginal ChanCfg.json verlinken
	    rm /mnt/data/config/MfuConfig/ChanCfg.json 
	    ln -s /mnt/data/config/$SUBDIR/ChanCfg.json /mnt/data/config/MfuConfig/ChanCfg.json
	  else
	    # kein MFU-Modus
	    # vorherigen Ordner /mnt/data/config/MfuConfig loeschen
	    rm -r /mnt/data/config/MfuConfig -f
	  fi
	fi
      else 
	# existiert  nicht ... gibt es ein config Verzeichnis
        ls -al /home/tool | grep 'config ->'
        if [ "$?" -eq "0" ]; then
          echo "rcS: Kein Config Verzeichnis aber Link vorhanden ?" >> $RCS_LOGFILE 
        else   
          ls -al /home/tool | grep 'config'
          if [ "$?" -eq "0" ]; then
	    cp -r /home/tool/config $DIR
	    rm -r /home/tool/config
	    ln -s $DIR /home/tool/config   
	    echo "rcS: akutelles config Verzeichnis $DIR" >> $RCS_LOGFILE  
         fi
        fi
      fi
    fi
  fi

else 
  echo "rcS: **** NICHT MOEGLICH DIE DATA PARTITION EINZUHAENGEN ******" >> $RCS_LOGFILE 
  echo "rcS: **** Hier muss noch ein Fehlerhandling rein **************" >> $RCS_LOGFILE
fi
# Nur wenn rootfs im NAND wird readonly remounted,
# erst hier, da sonst nach fw update /home/tool/config softlink nicht angelegt werden kann
#if [ "$BOOTDEVICE" == "NAND" ]; then
#  mount -o remount,ro /
#fi

#i2c Core Spannung einschalten
echo 142 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio142/direction
echo 1 > /sys/class/gpio/gpio142/value
#epld 3,5V Volt
echo 152 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio152/direction
echo 1 > /sys/class/gpio/gpio152/value
#epld 1,8V
echo 153 > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio153/direction
echo 1 > /sys/class/gpio/gpio153/value

#########################################################################
if [ "$MWMotion_DEVICE" == "true" ]; then
  insmod /lib/modules/2.6.33.7-rt29-REXMAS/kernel/drivers/mwmotion/mwmotion.ko
  if [ "$?" -eq "0" ]; then
    echo "rcS: insmod mwmotion.ko SUCCESS" >> $RCS_LOGFILE
  else
    echo "rcS: insmod mwmotion.ko FAILED" >> $RCS_LOGFILE
    if [ "$?" -ne 0 ]; then
      rmmod mwmotion
    fi
  fi
else
  insmod /lib/modules/2.6.33.7-rt29-REXMAS/kernel/drivers/mwm/mwmspi.ko
  if [ "$?" -eq "0" ]; then
    echo "rcS: insmod mwmspi.ko SUCCESS" >> $RCS_LOGFILE
  else
    echo "rcS: insmod mwmspi.ko FAILED" >> $RCS_LOGFILE
    if [ "$?" -ne 0 ]; then
      rmmod mwmspi
    fi
  fi
fi

insmod /lib/modules/2.6.33.7-rt29-REXMAS/kernel/drivers/lt/lt.ko
if [ "$?" -eq "0" ]; then
  echo "rcS: insmod lt.ko SUCCESS" >> $RCS_LOGFILE
else
  echo "rcS: insmod lt.ko FAILED" >> $RCS_LOGFILE
  if [ "$?" -ne 0 ]; then
    rmmod mwmspi
  fi
fi

cd /etc/init.d/

./dbus-1 start
if [ "$?" -eq "0" ]; then
  echo "rcS: DBUS DAEMON SUCCESS" >> $RCS_LOGFILE
else
  echo "rcS: DBUS DAEMON FAILED" >> $RCS_LOGFILE
fi
/usr/sbin/crond -S
if [ "$?" -eq "0" ]; then
  echo "rcS: CRON DAEMON SUCCESS" >> $RCS_LOGFILE
else
  echo "rcS: CRON DAEMON FAILED" >> $RCS_LOGFILE
fi
/usr/bin/crontab -u root /etc/cron.tab &> /dev/null
if [ "$?" -eq "0" ]; then
  echo "rcS: CRONTAB SUCCESS" >> $RCS_LOGFILE
else
  echo "rcS: CRONTAB FAILED" >> $RCS_LOGFILE
fi
# Zeitzone des Systems setzen
./timezone.sh

if [ "$BOOTDEVICE" == "NAND" ]; then
  # Damit dropbear den login über den key erlaubt muss ~./ssh UND das ganze home Verzeichnis nur "writeable by the user root" sein
  # NUR BEIM BOOTEN VOM NAND, SONST IST BEI NFS DAS /home/tool Verzeichnis nicht mehr ausfuerhbar :-(
  chmod 600 /home/tool/.ssh/authorized_keys
  chmod 600 /home/tool
fi
touch /var/log/lastlog &> /dev/null
# starte mit Option -s : disable password logins
dropbear -s
if [ "$?" -eq "0" ]; then
  echo "rcS: SSH-2 SERVER SUCCESS" >> $RCS_LOGFILE
else
  echo "rcS: SSH-2 SERVER FAILED" >> $RCS_LOGFILE
fi

########################################################
# Speichermanagement / OOM Killer (Out of Memory) / SWAP
# ******************************************************
# Vergabe von Speicher bis max. Swap + overcommit_ratio % RAM
#echo 2 > /proc/sys/vm/overcommit_memory
#echo 80 > /proc/sys/vm/overcommit_ratio
# Cache löschen anstatt auslagern (auch wenn wir keinen SWAP haben)
echo 0 > /proc/sys/vm/swappiness
#kernel panic wenn OOM Killer aktiviert wird
echo 0 > /proc/sys/vm/panic_on_oom 

#hack for i2c
#cat /proc/pwrctrl_ver
#cat /proc/pwrctrl_ver

