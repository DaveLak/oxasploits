json = require('json')


--[[Optionale Parameter
  Name = "Step"
  Category=0
  TorqueThreshold=0
  StartSuppression = 30
  GraphResolution=1
  MeasuringPoints=500
  MF_Time_Switching=10
  CorrectionAngle=false
  CorrectionTorqueCt=1
  StartupTest.MF_Time_Switching=10
  StartupTest.TF_Angle = 30
  StartupTest.MF_TorqueMax_Switching = 5
  StartupTest.Speed = 5
  StartupTest.StartSuppression = 0
]]
--Prg serialisieren
local function f_WritePrgFile( prg, steps)
  assert(prg.Nr)
  local PrgFilePath = "/home/tool/config/srbprg/prg"..tostring(prg.Nr)..".lua"
  
  --prgnr raus
  prg.Nr=nil
  
  local file,err = io.open( tostring(PrgFilePath), "wb" )
  --local file,err = io.open( "PrgTest.lua", "wb" )
  if err then
    return err 
  end
  --Header
  file:write("--Tightening program generated by Open Protcol\n--DO NOT EDIT THIS FILE MANUALLY!!\n--Date: "..os.date() .. "\n\n")

  --Prg tabelle
  file:write( "--General information\nprg={}\n")
  for Key,Value in pairs( prg ) do
    --print(Key .. ": " .. Value .. " " .. type( Key ) .. " " .. type(Value))
    DataType = type(Value)
    if DataType == "string" then
      file:write( "prg." .. Key .. " = " .. string.format("%q", Value) .. "\n" )
    elseif DataType == "number" then
      file:write( "prg." .. Key .. " = " .. tonumber( Value)  .. "\n" )
    end
  end
  
  --Stufentabelle
  file:write("\n--Steps\nsteps={}".."\n")

  Index=1
  while steps[Index]~=nil do
    file:write("\n--steps "..Index.."\nsteps["..Index.."] = {}\n")
    for ParamName, ParamValue in pairs(steps[Index]) do
      --[[if(ParamValue==nil) then
	print(Index .. ": " .. ParamName .. " " .. "nil")
      else
	print(Index .. ": " .. ParamName .. " " .. tostring(ParamValue))
      end]]
      DataType = type(ParamValue)
      if DataType == "string" then
	file:write("steps["..Index.."].".. ParamName .. " = " .. string.format("%q", ParamValue) .. "\n")
      elseif DataType == "number" then
	if (ParamName == "IO_Next" or ParamName == "NIO_Next") and ParamValue == -1  then
	  file:write("steps["..Index.."].".. ParamName .. " = nil\n")
	else
	  file:write("steps["..Index.."].".. ParamName .. " = " .. tonumber(ParamValue) .. "\n")
	end
      elseif DataType == "table" then
	  if ParamName == "StartupTest" then
	    --steps[1].StartupTest = {  
	    file:write("steps["..Index.."].StartupTest = {\n")
	    for key, val in pairs (ParamValue) do
		--print(key .. "  " .. val)
		DataType = type(val)
		if DataType == "number" then
		  file:write("  " .. key .. " = " .. tonumber(val) .. ",\n")
		end
	    end
	    file:write("}\n")
	  end
      end --elseif
    end --for
    Index=Index+1
  end --while
  --file:write("\nreturn prg, steps")
  file:write("\n")
  file:close()    
end

local function f_CheckGraphResolution(Step)
    if Step.GraphResolution == nil then
	Step.GraphResolution = 1
    end
    --0.25, 0.5, 1, 2, 5, 10,20,50
    if Step.Type ~=0 then
      --In Schraubstufen bedeutet Resolution 'as start"
      if ( Step.GraphResolution~=0 and Step.GraphResolution~=0.25 and Step.GraphResolution~=0.5 and Step.GraphResolution~=1 and Step.GraphResolution~=2 and 
	   Step.GraphResolution~=5 and Step.GraphResolution~=10 and Step.GraphResolution~=20 and Step.GraphResolution~=50) then
	assert(nil, "Step: " .. tostring(table) .. " - GraphResolution <" .. tostring(Step.GraphResolution) .. "> not valid")
      end
    else
      if ( Step.GraphResolution~=0.25 and Step.GraphResolution~=0.5 and Step.GraphResolution~=1 and Step.GraphResolution~=2 and Step.GraphResolution~=5 and 
	  Step.GraphResolution~=10 and Step.GraphResolution~=20 and Step.GraphResolution~=50) then
	assert(nil, "Step: " .. tostring(table) .. " - GraphResolution <" .. tostring(Step.GraphResolution) .. "> not valid")
      end
    end
end

local function f_CheckBorders(StepNr, ParamName, Value,Min,Max)
  assert (Value>=Min and Value <=Max, "Step: " .. tostring(StepNr) .. " " .. tostring(ParamName) .. " Val <" .. tostring(Value) .. "> out of borders")
end

local function f_CheckStepCategory(Step)
      --Category 0- 11
      if Step.Category == nil then
	--default Category
	Step.Category=0
      else
	assert(Step.Category>=0 and Step.Category <=11, "Step: " .. tostring(table) .. " - Category <" .. tostring(Step.Category) .. "> out of bounds")  
      end
end
local function f_CheckPlausi(PrgParamTable, StepsParamTable)
  --has name
  if PrgParamTable.Name == nil then
    PrgParamTable.Name = ""
  end
  --Nr
  assert(PrgParamTable.Nr, "no nr")
  --has torque unit
  assert(PrgParamTable.TorqueUnit,"no torque unit")
  if (PrgParamTable.TorqueUnit < 0 or PrgParamTable.TorqueUnit > 5 ) then
    assert(nil, "TorqueUnit <" .. PrgParamTable.TorqueUnit .. "> not supported")
  end
  --has comment
  if PrgParamTable.Comment == nil then
    PrgParamTable.Comment = ""
  end
  --has version
  if PrgParamTable.Version == nil then
    PrgParamTable.Version=""
  end
  --has date
  if PrgParamTable.Date == nil then
    PrgParamTable.Date = os.time()
  end
  --has user
  if PrgParamTable.User == nil then
    PrgParamTable.User = "Open Protocol"
  end
  
  StepNr=1
  NrTargetFuncts = 0
  NrTF_Angle=0
  NrTF_Time=0
  NrTF_Torque=0
  MFTorqueMax=-2147483648.0
  MFTorqueMin=-2147483648.0
  MFAngleMax=-2147483648.0
  MFAngleMin=-2147483648.0
  while StepsParamTable[StepNr] ~= nil do
    --Type
    assert(StepsParamTable[StepNr].Type, "step <" .. tostring(StepNr) .. "> no type")
    if (StepsParamTable[StepNr].Type < 0 or StepsParamTable[StepNr].Type > 2 ) then
      assert(nil, "Step: " .. tostring(StepNr) .. " - Type <" .. tostring(StepsParamTable[StepNr].Type) .. "> not supported")
    end
    --io_next
    assert(StepsParamTable[StepNr].IO_Next, "step <" .. tostring(StepNr) .. "> no io_next")
    --0 nicht erlaubt Indizierung beginnt bei 1
    assert(StepsParamTable[StepNr].IO_Next~=0, "Step: " .. tostring(StepNr) .. " - IO_Next <" .. tostring(StepsParamTable[StepNr].IO_Next) .. "> no valid successor")
    -- indizierug < -1 nicht erlaubt
    assert(StepsParamTable[StepNr].IO_Next>=-1, "Step: " .. tostring(StepNr) .. " - IO_Next <" .. tostring(StepsParamTable[StepNr].IO_Next) .. "> no valid successor")
    --io Nachfolger pruefen - 
    if ( StepsParamTable[StepNr].IO_Next == -1) then
      -- -1 nur in EndeStufe erlaubt
      assert(StepsParamTable[StepNr].Type == 2,"Step: " .. tostring(StepNr) .. " - IO_Next <" .. tostring(StepsParamTable[StepNr].IO_Next) .. "> no valid successor") 
    else
      --io Nachfolger definiert - existiert dieser?
      assert (StepsParamTable[StepsParamTable[StepNr].IO_Next], "Step: " .. tostring(StepNr) .. " - IO_Next <" .. tostring(StepsParamTable[StepNr].IO_Next) .. "> successor not found")
      --ja, darf aber nicht <= der eignenen Stufennummer sein sonst h채tten wir bedingte Spr체nge
      assert(StepsParamTable[StepsParamTable[StepNr].IO_Next] > StepNr, "Step: " .. tostring(StepNr) .. " - IO_Next <" .. tostring(StepsParamTable[StepNr].IO_Next) .. "> successor not ascending")
    end
    
    
    --nio_next
    assert(StepsParamTable[StepNr].NIO_Next, "step <" .. tostring(StepNr) .. "> no nio_next")
    --0 nicht erlaubt Indizierung beginnt bei 1
    assert(StepsParamTable[StepNr].NIO_Next~=0, "Step: " .. tostring(StepNr) .. " - NIO_Next <" .. tostring(StepsParamTable[StepNr].NIO_Next) .. "> no valid successor")
    -- indizierug < -1 nicht erlaubt
    assert(StepsParamTable[StepNr].NIO_Next>=-1, "Step: " .. tostring(StepNr) .. " - NIO_Next <" .. tostring(StepsParamTable[StepNr].NIO_Next) .. "> no valid successor")
    --nio next nur in Ende- und Startstufe erlaubt
    if (StepsParamTable[StepNr].NIO_Next == -1 ) then
      assert(StepsParamTable[StepNr].Type==0 or StepsParamTable[StepNr].Type == 2,"Step: " .. tostring(StepNr) .. " - NIO_Next <" .. tostring(StepsParamTable[StepNr].NIO_Next) .. "> no valid successor")
    else
      --nio Nachfolger definiert - existiert dieser?
      assert (StepsParamTable[StepsParamTable[StepNr].NIO_Next], "Step: " .. tostring(StepNr) .. " - NIO_Next <" .. tostring(StepsParamTable[StepNr].NIO_Next) .. "> successor not found")
      --ja, darf aber nicht <= der eignene Stufennummer sein sonst h채tten wir bedingte Spr체nge
      assert(StepsParamTable[StepsParamTable[StepNr].NIO_Next] > StepNr, "Step: " .. tostring(StepNr) .. " - NIO_Next <" .. tostring(StepsParamTable[StepNr].IO_Next) .. "> successor not ascending")
    end
    
    --Column
    assert(StepsParamTable[StepNr].Column, "step <" .. tostring(StepNr) .. "> no column")
    assert(StepsParamTable[StepNr].Column == 0, "Step: " .. tostring(StepNr) .. " - Column <" .. tostring(StepsParamTable[StepNr].Column) .. "> not supported")
    --Row
    assert(StepsParamTable[StepNr].Row, "step <" .. tostring(StepNr) .. "> no row")
    assert(StepsParamTable[StepNr].Row >=0 and StepsParamTable[StepNr].Row <= 11, "Step: " .. tostring(StepNr) .. " - Row <" .. tostring(StepsParamTable[StepNr].Row) .. "> out of bounds")

    --Name
    if StepsParamTable[StepNr].Name == nil then
      StepsParamTable[StepNr].Name = "Step " .. tostring(StepNr)
    end
    assert(StepsParamTable[StepNr].Name, "step <" .. tostring(StepNr) .. "> no name")
    
    if StepsParamTable[StepNr].Type == 0 then
      --Startstufe
      --Category 0- 11
      f_CheckStepCategory(StepsParamTable[StepNr])
      
      --Korrekturfaktor Moment
      if StepsParamTable[StepNr].CorrectionTorqueCt == nil then
	StepsParamTable[StepNr].CorrectionTorqueCt = 1
      else
	--plausi 0.8 - 1.2
	assert(StepsParamTable[StepNr].CorrectionTorqueCt>=0.8 and StepsParamTable[StepNr].CorrectionTorqueCt <= 1.2, "Step: " .. tostring(StepNr) .. " - CorrectionTorqueCt <" .. tostring(StepsParamTable[StepNr].CorrectionTorqueCt) .. "> out of bounds")
      end
      --MeasuringPoints
      if StepsParamTable[StepNr].MeasuringPoints == nil then
	--default =500
	StepsParamTable[StepNr].MeasuringPoints = 500
      end
      --100,200,500,1000,1500, 2000
      if (StepsParamTable[StepNr].MeasuringPoints ~= 500 and StepsParamTable[StepNr].MeasuringPoints ~= 200 and StepsParamTable[StepNr].MeasuringPoints~=500 and StepsParamTable[StepNr].MeasuringPoints ~=1000 and StepsParamTable[StepNr].MeasuringPoints~=1500 and StepsParamTable[StepNr].MeasuringPoints~=2000) then
	assert(nil, "Step: " .. tostring(StepNr) .. " - MeasuringPoints <" .. tostring(StepsParamTable[StepNr].MeasuringPoints) .. "> not valid")
      end
      
      --Resolution
      f_CheckGraphResolution(StepsParamTable[StepNr])
      
      --Korrektur Winkel
      if StepsParamTable[StepNr].CorrectionAngle == nil then
	StepsParamTable[StepNr].CorrectionAngle = false
      end
      
      --PlayStartSwitch 0 -100%
      if(StepsParamTable[StepNr].PlayStartSwitch == nil ) then
	--default 5%
	StepsParamTable[StepNr].PlayStartSwitch = 5
      end
      assert(StepsParamTable[StepNr].PlayStartSwitch>=0 and StepsParamTable[StepNr].PlayStartSwitch <= 100, "Step: " .. tostring(StepNr) .. " - PlayStartSwitch <" .. tostring(StepsParamTable[StepNr].CorrectionTorqueCt) .. "> out of bounds")
      
      --TorqueThreshold 
      if ( StepsParamTable[StepNr].TorqueThreshold == nil )then
	StepsParamTable[StepNr].TorqueThreshold = 0
      end
      
      --StartupTest
      if ( StepsParamTable[StepNr].StartupTest ~= nil )then
	  --MF_Time_Switching - 0 - 1000
	  if (StepsParamTable[StepNr].StartupTest.MF_Time_Switching == nil )then
	    StepsParamTable[StepNr].StartupTest.MF_Time_Switching = 10
	  else
	    f_CheckBorders(StepNr, "MF_Time_Switching",StepsParamTable[StepNr].StartupTest.MF_Time_Switching,0,1000)
	  end
	  --TF_Angle
	  if (StepsParamTable[StepNr].StartupTest.TF_Angle == nil )then
	    StepsParamTable[StepNr].StartupTest.TF_Angle = 30
	  else
	    f_CheckBorders(StepNr, "TF_Angle", StepsParamTable[StepNr].StartupTest.TF_Angle,0,200000)
	  end
	  --MF_TorqueMax_Switching
	  if (StepsParamTable[StepNr].StartupTest.MF_TorqueMax_Switching == nil )then
	    StepsParamTable[StepNr].StartupTest.MF_TorqueMax_Switching = 5
	  else
	    f_CheckBorders(StepNr, "MF_TorqueMax_Switching", StepsParamTable[StepNr].StartupTest.MF_TorqueMax_Switching,0,100)
	  end
	  --Speed
	  if (StepsParamTable[StepNr].StartupTest.Speed == nil )then
	    StepsParamTable[StepNr].StartupTest.Speed = 5
	  else
	    f_CheckBorders(StepNr, "Speed", StepsParamTable[StepNr].StartupTest.Speed,0,100)
	  end
	  --StartSuppression
	  if (StepsParamTable[StepNr].StartupTest.StartSuppression == nil )then
	    StepsParamTable[StepNr].StartupTest.StartSuppression = 0
	  else
	  f_CheckBorders(StepNr, "StartSuppression", StepsParamTable[StepNr].StartupTest.StartSuppression,0,100)
	  end
      end
      
    elseif StepsParamTable[StepNr].Type == 1 then
      --Standardstufe
      --Category
      f_CheckStepCategory(StepsParamTable[StepNr])
      
      --TorqueThreshold
      if (StepsParamTable[StepNr].TorqueThreshold == nil )then
	StepsParamTable[StepNr].TorqueThreshold = 0
      else
	f_CheckBorders(StepNr, "TorqueThreshold", StepsParamTable[StepNr].TorqueThreshold,0,1000)
      end
      
      --StartSuppression
      if (StepsParamTable[StepNr].StartSuppression == nil )then
	StepsParamTable[StepNr].StartSuppression = 30
      else
	f_CheckBorders(StepNr, "StartSuppression", StepsParamTable[StepNr].StartSuppression,0,100)
      end
      
      --GraphResolution
      f_CheckGraphResolution(StepsParamTable[StepNr])
      
      --Drehzahl
      assert(StepsParamTable[StepNr].Speed, "step <" .. tostring(StepNr) .. "> no speed")
      
      --MF Time switching
      if (StepsParamTable[StepNr].MF_Time_Switching == nil )then
	StepsParamTable[StepNr].MF_Time_Switching = 10
      else
	f_CheckBorders(StepNr, "MF_Time_Switching", StepsParamTable[StepNr].MF_Time_Switching,0,1000)
      end
      
      --TF1_Angle
      if (StepsParamTable[StepNr].TF1_Angle ~= nil)then
	NrTargetFuncts = NrTargetFuncts+1
	NrTF_Angle=NrTF_Angle+1
	f_CheckBorders(StepNr, "TF1_Angle", StepsParamTable[StepNr].TF1_Angle,0.001,200000)
      end
      --TF1_Time
      if (StepsParamTable[StepNr].TF1_Time ~= nil)then
	NrTargetFuncts = NrTargetFuncts+1
	NrTF_Time=NrTF_Time+1
	f_CheckBorders(StepNr, "TF1_Time", StepsParamTable[StepNr].TF1_Time,0.001,1000)
      end
      --TF1_Torque
      if (StepsParamTable[StepNr].TF1_Torque ~= nil)then
	NrTargetFuncts = NrTargetFuncts+1
	NrTF_Torque=NrTF_Torque+1
	f_CheckBorders(StepNr, "TF1_Torque", StepsParamTable[StepNr].TF1_Torque,0.001,200000)
      end
      --TF2_Angle
      if (StepsParamTable[StepNr].TF2_Angle ~= nil)then
	NrTargetFuncts = NrTargetFuncts+1
	NrTF_Angle=NrTF_Angle+1
	f_CheckBorders(StepNr, "TF2_Angle", StepsParamTable[StepNr].TF2_Angle,0.001,200000)
      end
      --TF2_Time
      if (StepsParamTable[StepNr].TF2_Time ~= nil)then
	NrTargetFuncts = NrTargetFuncts+1
	NrTF_Time=NrTF_Time+1
	f_CheckBorders(StepNr, "TF2_Time", StepsParamTable[StepNr].TF2_Time,0.001,1000)
      end
      --TF2_Torque
      if (StepsParamTable[StepNr].TF2_Torque ~= nil)then
	NrTargetFuncts = NrTargetFuncts+1
	NrTF_Torque=NrTF_Torque+1
	f_CheckBorders(StepNr, "TF2_Torque", StepsParamTable[StepNr].TF2_Torque,0.001,200000)
      end
      assert(NrTargetFuncts~=0, "Step: " .. tostring(StepNr) .. " - no target function found")
      assert(NrTargetFuncts<=2, "Step: " .. tostring(StepNr) .. " - " .. tostring(NrTargetFuncts) .. " target functions found")
      assert(NrTF_Angle<=1,"Step: " .. tostring(StepNr) .. " - TF_Angle found " .. tostring(NrTF_Angle) .. " times")
      assert(NrTF_Time<=1,"Step: " .. tostring(StepNr) .. " - TF_Time found " .. tostring(NrTF_Time) .. " times")
      assert(NrTF_Torque<=1,"Step: " .. tostring(StepNr) .. " - TF_Torque found " .. tostring(NrTF_Torque) .. " times")
      if(StepsParamTable[StepNr].Speed == 0 ) then
	--es darf nur TF_Time aktiv sein
	assert(NrTF_Time~=0 and NrTF_Angle==0 and NrTF_Torque==0,"Step: " .. tostring(StepNr) .. " - Speed " .. tostring(StepsParamTable[StepNr].Speed) .. " not allowed")
      else
	f_CheckBorders(StepNr, "Speed", StepsParamTable[StepNr].Speed,-20000,20000)
      end
      
      --Ueberwachungsfunktionen
      --MF_TorqueMax/switching
      if (StepsParamTable[StepNr].MF_TorqueMax ~= nil) then
	f_CheckBorders(StepNr, "MF_TorqueMax", StepsParamTable[StepNr].MF_TorqueMax,-1000,1000)
	MFTorqueMax = StepsParamTable[StepNr].MF_TorqueMax
      elseif ( StepsParamTable[StepNr].MF_TorqueMax_Switching ~= nil) then
	f_CheckBorders(StepNr, "MF_TorqueMax_Switching", StepsParamTable[StepNr].MF_TorqueMax_Switching,-1000,1000)
	MFTorqueMax = StepsParamTable[StepNr].MF_TorqueMax_Switching
      end
      
      --MF_TorqueMin/switching
      if (StepsParamTable[StepNr].MF_TorqueMin ~= nil) then
	f_CheckBorders(StepNr, "MF_TorqueMin", StepsParamTable[StepNr].MF_TorqueMin,-1000,1000)
	MFTorqueMin = StepsParamTable[StepNr].MF_TorqueMin
      elseif( StepsParamTable[StepNr].MF_TorqueMin_Switching ~= nil) then
	f_CheckBorders(StepNr, "MF_TorqueMin_Switching", StepsParamTable[StepNr].MF_TorqueMin_Switching,-1000,1000)
	MFTorqueMin = StepsParamTable[StepNr].MF_TorqueMin_Switching
      end
      
      --MF_AngleMax/switching
      if (StepsParamTable[StepNr].MF_AngleMax ~= nil) then
	f_CheckBorders(StepNr, "MF_AngleMax", StepsParamTable[StepNr].MF_AngleMax,0,200000)
	MF_AngleMax = StepsParamTable[StepNr].MF_AngleMax
      elseif ( StepsParamTable[StepNr].MF_AngleMax_Switching ~= nil) then
	f_CheckBorders(StepNr, "MF_AngleMax_Switching", StepsParamTable[StepNr].MF_AngleMax_Switching,0,200000)
      end
      
      --MF_AngleMin/switching
      if (StepsParamTable[StepNr].MF_AngleMin ~= nil) then
	f_CheckBorders(StepNr, "MF_AngleMin", StepsParamTable[StepNr].MF_AngleMin,0,200000)
	MF_AngleMin = StepsParamTable[StepNr].MF_AngleMin
      end
      
      --Plausipruefung Min Max
      if ( MFTorqueMax ~= -2147483648.0 and  MFTorqueMin~=-2147483648.0) then
	assert(MFTorqueMax>MFTorqueMin, "Step: " .. tostring(StepNr) .. " - MFTorqueMax <" .. tostring(MFTorqueMax) .. "> smaller or equal than MFTorqueMin <" .. tostring(MFTorqueMin) .. ">")
      end
      if ( MFAngleMax ~= -2147483648.0 and  MFAngleMin~=-2147483648.0) then
	assert(MFAngleMax>MFAngleMin, "Step: " .. tostring(StepNr) .. " - MFAngleMax <" .. tostring(MFAngleMax) .. "> smaller or equal than MFAngleMin <" .. tostring(MFAngleMin) .. ">")
      end
    end
    --Anzahl Zielfunktionen wieder zur체cknehmen
    NrTargetFuncts=0
    NrTF_Angle=0
    NrTF_Time=0
    NrTF_Torque=0
    MFTorqueMax=-2147483648.0
    MFTorqueMin=-2147483648.0
    MFAngleMax=-2147483648.0
    MFAngleMin=-2147483648.0
    --Naechste Stufe betrachten
    StepNr=StepNr+1
  end
  return 0
  
end
function f_WriteJson(jString)
  --json parsen
  --print (jString .. "\n")
  PrgParams = json.decode(jString)
  assert(PrgParams, " no PrgParams")
  --print("Params: " .. tostring(type(PrgParams)) .. "\n")
  assert(PrgParams.steps,  "no StepParams")

  local prg={}
  local steps={}

  --prgtabelle einpflegen
  for key, val in pairs (PrgParams) do
    --print(key.."->"..tostring(val))
    prg[key]=val
  end
  --aktuelles Datum einplegen
  prg.Date=os.time()
  
  steptable=1
  while PrgParams.steps[steptable]~=nil do
    --neues stufenmitglied
    steps[steptable]={}
    ParamId=1
    --print("Step: " .. steptable .. "\n")
    for Key,Value in pairs( PrgParams.steps[steptable] ) do
      --print(tostring(Key).."="..tostring(PrgParams.steps[steptable][tostring(Key)]))
      steps[steptable][tostring(Key)]=Value
    end
    steptable = steptable+1
  end
  if(f_CheckPlausi(prg,steps) ~= 0 ) then
      return -1
  end
  return f_WritePrgFile(prg, steps)
end


function f_ReadJson(PrgNr)
  
  WrkFile="/home/tool/config/srbprg/wrkfile.lua"
  --WrkFile="/omap/rootfs/home/tool/config/srbprg/wrkfile.lua"
  os.execute("rm " .. WrkFile)
  os.execute("echo 'module(..., package.seeall)\n' >>" ..  WrkFile)
  --os.execute("cat /home/tool/config/srbprg/prg1.lua >>" .. WrkFile)
  --os.execute("cat /omap/rootfs/home/tool/config/srbprg/prg" .. PrgNr .. ".lua >>" .. WrkFile)
  os.execute("cat /home/tool/config/srbprg/prg" .. PrgNr .. ".lua >>" .. WrkFile)
  
  --lua prg laden
  PrgData = require "wrkfile"
  assert(PrgData)
  assert(PrgData.prg)
  assert(PrgData.steps)
  
  --jsonParseBuffer
  PrgToJson={}
  --globale Prg Parameter
  for Key,Value in pairs( PrgData.prg ) do
    PrgToJson[Key]=Value
    --print(Key .. " " .. Value)
  end
  
  --Torque Unit eintragen falls nicht vorhanden
  if PrgToJson["TorqueUnit"]== nil then
    PrgToJson["TorqueUnit"] = 0
  end
  --Prg Nr eintragen
  PrgToJson["Nr"]=PrgNr
  
  --Datum als string
  Date = tonumber(PrgToJson.Date)
  
  tDate={}
  tDate=os.date("*t",Date)
  assert(tDate)
  PrgToJson.Date = tDate.day ..  "." ..tDate.month .. "." .. tDate.year .. " " .. tDate.hour .. ":" .. tDate.min .. ":" .. tDate.sec
  
  --stufentabelle als globalen Parameter ablegen
  PrgToJson["steps"]=PrgData.steps
  steptable=1
  --io nio nexts nil Werte als -1 hochgeben
  while PrgData.steps[steptable] do
    if PrgData.steps[steptable].IO_Next == nil then
      PrgData.steps[steptable]["IO_Next"] = -1
      --print("Step: " .. steptable .. " has IO_Next = nil\n")
    end
    if PrgData.steps[steptable].NIO_Next == nil then
      PrgData.steps[steptable]["NIO_Next"] = -1
      --print("Step: " .. steptable .. " has NIO_Next = nil\n")
    end    
    steptable=steptable+1
  end
  jsonStream = json.encode(PrgToJson)
  --print(jsonStream)
  return jsonStream
end --ende f_ReadJson