from datetime import datetime
from gluon.serializers import json
import WGDBus
from struct import unpack_from
import json as def_json
from gluon.serializers import custom_json

__author__ = 'frank.sattelberger@bittwister.com'


QCODE_BIT_WZUH = 0x02  # NIO, Winkel zu hoch
QCODE_BIT_WZUN = 0x04  # NIO, Winkel zu niedrig
QCODE_BIT_MZUH = 0x08  # NIO, Moment zu hoch
QCODE_BIT_MZUN = 0x10  # NIO, Moment zu niedrig
QCODE_BIT_TZUH = 0x20  # NIO, Zeit zu hoch

INVALID_VAL = -2147483648


torque_precision = 3
angle_precision = 6
time_precision = 6


class PrettyFloat(float):
    def __repr__(self):
        return '%.15g' % self


def dec(x, nd):
    return PrettyFloat(round(x, nd))


def graphdata(request, resultdb):
    """
    Return an array of points usef to draw the graph.
    Returns an empty array if the id does not exist.

    parameters:
      id : cycle id
    """
    #now = ttime.time()
    # Get parameters
    global torque_precision
    global angle_precision
    global time_precision

    cycleId = request.vars.id
    res = None
    #torque_spindle = []
    if not cycleId or cycleId == "-1":
        res = resultdb.executesql('SELECT MAX(id), torque_unit FROM srbergallg')
        #torque_spindle = resultdb.executesql('SELECT MIN(torque_spindle) FROM srbergallg')
    else:
        res = resultdb.executesql('SELECT id, torque_unit FROM srbergallg WHERE srbergallg.cycle=%s' % cycleId)
        #torque_spindle = resultdb.executesql('SELECT torque_spindle FROM srbergallg WHERE srbergallg.cycle=%s' % cycleId)
    #
    if res:
        cycleId = res[0][0]
        torque_unit = res[0][1]
    else:
      return json([{'a': 0, 'tq': 0, 'tm': 0, 'tu': 0}, {'a': 0, 'tq': 0, 'tm': 0, 'tu': 0}])

    res = []
    # Retrieve all level entries related to the cycle
    levels = [r[0] for r in resultdb.executesql("SELECT id FROM stuferg WHERE allg_id=%s" % cycleId)]

    ptidx = 1
    for level in levels:
        # Retrieve points data from SrbKurve table
        angle, torque, time = [r[0] for r in resultdb.executesql("SELECT data FROM srbcurve WHERE stuferg_id=%d" % level)]
        # add point to the result array
        for offset in xrange(0, len(angle), 8):
            res.append({'tq': dec(unpack_from('d', torque, offset)[0], torque_precision),
                        'a': dec(unpack_from('d', angle, offset)[0], angle_precision),
                        'tm': dec(unpack_from('d', time, offset)[0], time_precision),
                        'tu': torque_unit,
                        'i': ptidx})
            ptidx = ptidx + 1

    if not res:
        return json([{'a': 0, 'tq': 0, 'tm': 0}, {'a': 0, 'tq': 0, 'tm': 0}])
    result_str = def_json.dumps(res, default=custom_json, separators=(',', ':'))
    #syslog.syslog(syslog.LOG_DEBUG, str(ttime.time() - now))
    return result_str


def graphinfo(request, resultdb):
  """
  Return information for graph header (date, time, program number,..)

  parameters:
    id : cycle id
  """
  global torque_precision

  # Get parameters
  cycleId = request.vars.id
  stored = request.vars.stored
  if stored == 'true':
    stored = True
  else:
    stored = False

  res = None
  if not cycleId or cycleId == "-1":
    res = resultdb.executesql('SELECT MAX(id) FROM srbergallg')
  else:
    res = resultdb.executesql('SELECT id FROM srbergallg WHERE srbergallg.cycle=%s' % cycleId)
    #
  if res:
    cycleId = res[0][0]
  else:
    return json(None)

  # Retrieve levels
  levels = resultdb.executesql(
    """SELECT stuferg.id,
    timestamp,
    srbergallg.cycle,
    id_code,
    chan_name,
    prg_nr,
    row,
    col,
    srbergallg.last_cmd,
    srbergallg.torque_spindle,
    srbergallg.result,
    torque,
    stuferg.angle,
    srbergallg.QCode,
    srbergallg.qcode_text,
    srbergallg.job_nr,
    srbergallg.rework_code,
    srbergallg.rework_text,
    srbergallg.torque_unit,
    srbergallg.angle,
    stuferg.speed
    FROM stuferg JOIN srbergallg ON stuferg.allg_id=srbergallg.id WHERE srbergallg.id=%s""" % cycleId)

  # Retrieve last level of the cycle
  stufId, timestamp, cycle, idcode, chan_name, prg_nr, row, col, last_cmd, torque_spindle, result, torque, angle, QCode, qcode_text, job_nr, rework_code, rework_text, torque_unit, total_angle, speed = levels[-1]
  turnDirect = 1
  if speed <> None:
    if speed < 0:
      turnDirect = -1

  # Retrieve actual values + min/max
  #torque, angle, time = resultdb.executesql("SELECT actual, nom ,max FROM srbfncts WHERE stuferg_id=%d" % stufId)

  tMin = INVALID_VAL
  tMax = INVALID_VAL
  aMin = INVALID_VAL
  aMax = INVALID_VAL
  #target function angle
  tfAngle = False

  monitors = resultdb.executesql("SELECT cmd, nom FROM srbfncts WHERE stuferg_id=%s AND switching>=0" % stufId)
  if monitors:
    for monitor in monitors:
      if monitor[0] == 105:  # Torque Max
        tMax = monitor[1]
      elif monitor[0] == 106:  # Torque Min
        tMin = monitor[1]
      elif monitor[0] == 117:  # Angle Max
        aMax = monitor[1]
      elif monitor[0] == 118:  # Angle Min
        aMin = monitor[1]
      elif monitor[0] == 5:  # Target function angle
        tfAngle = True

  Ar = 0
  Dr = 0
  Tr = 0
  if result < 0:
    Ar, Dr, Tr = applyQCode(QCode)

  #precisions
  tMinMaxPrec = 3
  tPrec = torque_precision
  aMinMaxPrec = 2
  aPrec = 2

  # Set data to the return data structure
  d = datetime.fromtimestamp(timestamp)
  res = {
      'Date': d.date().isoformat(),
         'Time': d.time().isoformat(),
         'Cycle': cycle,
         'IDCode': idcode,
         'Channel': chan_name,
         'P': prg_nr,
         'LS': levelName(row, col),
         'TF': cmdName(last_cmd, False),
         'OK': 'OK' if result > 0 else 'NOK',
         'QCodeText': qcode_text,
         'J': get_job_nr(job_nr),
         'rework_code': rework_code,
         'rework_text': rework_text,
         'torque_unit': torque_unit,
         'tMin': ("{:.%df}"%tMinMaxPrec).format(dec(tMin, tMinMaxPrec)),
         'tMax': ("{:.%df}"%tMinMaxPrec).format(dec(tMax, tMinMaxPrec)),
         't': ("{:.%df}"%tPrec).format(dec(torque, tPrec)),
         'aMin': ("{:.%df}"%aMinMaxPrec).format(dec(aMin, aMinMaxPrec)),
         'aMax': ("{:.%df}"%aMinMaxPrec).format(dec(aMax, aMinMaxPrec)),
         'a': ("{:.%df}"%aPrec).format(dec(angle, aPrec)),
         'total_angle': total_angle,
         'margins': graphMargins(request, resultdb),
         'tMinMaxPrec': dec(1, tMinMaxPrec),
         'tPrec': dec(1, tPrec),
         'aMinMaxPrec': dec(1, aMinMaxPrec),
         'aPrec': dec(1, aPrec),
         'tfAngle': tfAngle,
         'Tr': Tr, # -1, 0, 1
         'Ar': Ar, # -1, 0, 1, 2
         'Dr': Dr, # -1, 0, 1, 2
         'TurnDirec': turnDirect
  }

  if WGDBus.getNewResult() or stored:
    return json(res)
  else:
    return json(None)


def get_job_nr(job_nr):
    if job_nr < 0:
      return '-'
    else:
      return job_nr


def applyQCode(QCode):
  Tr = 0
  Ar = 0
  Dr = 0

  if (QCode & QCODE_BIT_WZUH) == QCODE_BIT_WZUH:
    Ar = 1

  if (QCode & QCODE_BIT_WZUN) == QCODE_BIT_WZUN:
    if Ar == 1:
      Ar = 2
    else:
      Ar = -1

  if (QCode & QCODE_BIT_MZUH) == QCODE_BIT_MZUH:
    Tr = 1
  if (QCode & QCODE_BIT_MZUN) == QCODE_BIT_MZUN:
    if Tr == 1:
      Tr = 2
    else:
      Tr = -1
  if (QCode & QCODE_BIT_TZUH) == QCODE_BIT_TZUH:
    Dr = 1

  return Ar, Dr, Tr


def levelName(row, col):
  """
  Return a string representation of a level given the row and col position
  """
  return '%d,%s' % (row + 1,
                    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
                     'U'][col])


def cmdName(code, switching):
  if code == 1:
    return 'TF T'
  if code == 2:
    return 'TF Tl'
  if code == 3:
    return 'TF T&'
  if code == 4:
    return 'TF Tl&'
  if code == 5:
    return 'TF A'
  if code == 6:
    return 'TF Ln'
  if code == 7:
    return 'TF t'
  if code == 8:
    return 'TF Yp'
  if code == 9:
    return 'TF G'

  if code == 101:
    return 'Cw->0'
  if code == 102:
    return 'CCw->0'
  if code == 103:
    return 'En->0'
  if code == 104:
    return 'MFs t+'
  if code == 105:
    return 'MFs T+' if switching else 'MFe T+'
  if code == 106:
    return 'MFs T-' if switching else 'MFe T-'
  if code == 107:
    return 'MFs T&+' if switching else 'MFe T&+'
  if code == 108:
    return 'MFs T&-' if switching else 'MFe T&-'
  if code == 109:
    return 'MFs T>+' if switching else 'MFe T>+'
  if code == 110:
    return 'MFs T<-' if switching else 'MFe T<-'
  if code == 111:
    return 'MFe TA+'
  if code == 112:
    return 'MFe TA-'
  if code == 113:
    return 'MFe T[+'
  if code == 114:
    return 'MFe T[-'
  if code == 115:
    return 'MFs TR+-'
  if code == 116:
    return 'MFs AR+-'
  if code == 117:
    return 'MFs A+' if switching else 'MFe A+'
  if code == 118:
    return 'MFe A-'
  if code == 119:
    return 'MFs AO+' if switching else 'MFe AO+'
  if code == 120:
    return 'MFs AO-' if switching else 'MFe AO-'
  if code == 121:
    return 'MFs G+' if switching else 'MFe G+'
  if code == 122:
    return 'MFs G-' if switching else 'MFe G-'
  if code == 123:
    return 'MFe GA+'
  if code == 124:
    return 'MFe GA-'
  if code == 125:
    return 'MFs STS+'
  if code == 126:
    return 'MFe TCh+'
  if code == 127:
    return 'MFe TCh-'
  if code == 128:
    return 'MFs Yp+'
  if code == 129:
    return 'SysFault'
  if code == 130:
    return 'Rdy->0'
  return '???'


def graphMargins(request, resultdb):
  """
  Return list of margin values of each step.
  Returns an empty array if the id does not exist.

  parameters:
    id : cycle id
  """
  # Get parameters
  cycleId = request.vars.id
  res = None
  if not cycleId or cycleId == "-1":
    res = resultdb.executesql('SELECT MAX(id) FROM srbergallg')
  else:
    res = resultdb.executesql('SELECT id FROM srbergallg WHERE srbergallg.cycle=%s' % cycleId)
    #
  if res:
    cycleId = res[0][0]
  else:
    return json([{'step': 0, 'angle': 0, 'torque': 0, 'time': 0, 'threshold_angle': 0, 'stepEndAngle': 0, 'stepStartAngle': 0},
                 {'step': 1, 'angle': 0, 'torque': 0, 'time': 0, 'threshold_angle': 0, 'stepEndAngle': 0, 'stepStartAngle': 0}])

  res = []
  marginValues = []
  # Retrieve all margin values of each step related to the given cycle
  marginValues = [r for r in resultdb.executesql(
    "SELECT id, angle, torque, time, threshold_angle FROM stuferg WHERE allg_id=%s" % cycleId)]

  if not marginValues:
    return json([{'step': 0, 'angle': 0, 'torque': 0, 'time': 0, 'threshold_angle': 0, 'stepEndAngle': 0, 'stepStartAngle': 0},
                 {'step': 1, 'angle': 0, 'torque': 0, 'time': 0, 'threshold_angle': 0, 'stepEndAngle': 0, 'stepStartAngle': 0}])
  else:
    for val in marginValues:
      step, angle, torque, time, threshold_angle = [entry for entry in val]
      res.append({'step': step, 'angle': angle, 'torque': torque, 'time': time, 'threshold_angle': threshold_angle,
                  'stepEndAngle': 0, 'stepStartAngle': 0})
    #Calc step start and end
    prevEnd = 0
    for item in res:
      dd = getStepData(item['step'], resultdb)
      if dd != []:
        item['stepStartAngle'] = dd[0]['a']
      if item['threshold_angle'] > 0:
        item['stepEndAngle'] = item['threshold_angle'] + item['angle']
      else:
        item['stepEndAngle'] = prevEnd + item['angle']
      prevEnd = item['stepEndAngle']
  return res


def getStepData(level, resultdb):
  global torque_precision
  global angle_precision
  global time_precision

  res = []
  try:
    angle, torque, time = [r[0] for r in resultdb.executesql("SELECT data FROM srbcurve WHERE stuferg_id=%d" % level)]
    for offset in xrange(0, len(angle), 8):
      res.append({'tq': dec(unpack_from('d', torque, offset)[0], torque_precision),
                  'a': dec(unpack_from('d', angle, offset)[0], angle_precision),
                  'tm': dec(unpack_from('d', time, offset)[0], time_precision)})
  except:
    pass
  return res


def actualvalues(request, resultdb):
    """
    Return actual values for each level of the given cycle

    parameters:
      id : cycle id
    """
    global torque_precision

    # Get parameters
    cycleId = request.vars.id
    stored = request.vars.stored
    if stored == 'true':
        stored = True
    else:
        stored = False
    res = None
    if not cycleId or cycleId == "-1":
        res = resultdb.executesql('SELECT MAX(id) FROM srbergallg')
    else:
        res = resultdb.executesql('SELECT id FROM srbergallg WHERE srbergallg.cycle=%s' % cycleId)

    if res:
        cycleId = res[0][0]
    else:
        return json(None)

    levels = resultdb.executesql(
      """SELECT
          stuferg.id,
          timestamp,
          srbergallg.cycle,
          chan_name,
          row,
          col,
          stuferg.last_cmd,
          srbergallg.torque_spindle,
          srbergallg.result,
          prg_nr,
          stuferg.qcode,
          stuferg.qcode_text,
          srbergallg.job_nr,
          srbergallg.id_code,
          srbergallg.rework_code,
          srbergallg.rework_text,
          srbergallg.torque_unit,
          stuferg.time,
          stuferg.angle,
          stuferg.torque
         FROM stuferg JOIN srbergallg ON stuferg.allg_id=srbergallg.id WHERE srbergallg.id=%s""" % cycleId)

    res = []
    for stufId, timestamp, cycle, chan_name, row, col, last_cmd, torque_spindle, result, prgnr, qcode, qcode_text, job_nr, idcode, rework_code, rework_text, torque_unit, duration, angle, torque in levels:        
        #TMin, T, TMax, AMin, A, AMax, D, DMax = resultdb.executesql("SELECT MomentMax, MomentIst, MomentMin, WinkelMax, WinkelIst, WinkelMin, ZeitIst, ZeitMax FROM stuferg WHERE id=%s" % stufId)[0]
        #if (result < 0):
        #if last_cmd < 100:
        #  # Target reached but monitor failed
        #  monitors = resultdb.executesql("SELECT cmd, actual, nom FROM srbfncts WHERE stuferg_id=%s AND switching=0" % stufId)
        #  if monitors:
        #    for monitor in monitors:
        #      if monitor[0] == 105:  # Torque Max
        #        Tr = 1 if monitor[1] > monitor[2] else 0
        #      elif monitor[0] == 106:  # Torque Min
        #        Tr = -1 if monitor[1] < monitor[2] else 0
        #      elif monitor[0] == 117:  # Angle Max
        #        Ar = 1 if monitor[1] > monitor[2] else 0
        #      elif monitor[0] == 118:  # Angle Min
        #        Ar = -1 if monitor[1] < monitor[2] else 0
        #else:
        #  # Monitor stopped
        #  if last_cmd == 105:  # Torque Max
        #    Tr = 1
        #  elif last_cmd == 106:  # Torque Min
        #    Tr = -1
        #  elif last_cmd == 117:  # Angle Max
        #    Ar = 1
        #  elif last_cmd == 118:  # Angle Min
        #    Ar = -1
        #  elif last_cmd == 104:  # Time Max
        #    Dr = 1
        Ar = 0
        Dr = 0
        Tr = 0
        if result < 0:
          Ar, Dr, Tr = applyQCode(qcode)
        #precisions
        tPrec = torque_precision
        aPrec = 2
        dPrec = 3

        d = datetime.fromtimestamp(timestamp)
        res.append({
          'Date': d.date().isoformat(),
          'Time': d.time().isoformat(),
          'Cycle': cycle,
          'Channel': chan_name,
          'P': prgnr,
          'LS': levelName(row, col),
          'TF': cmdName(last_cmd, True),
          'QC': qcode,
          'QCodeText': qcode_text,
          'J': get_job_nr(job_nr),
          'IDCode': idcode,
          'rework_code': rework_code,
          'rework_text': rework_text,
          'torque_unit': torque_unit,
          'OK': 'OK' if result > 0 else 'NOK',
          'T': ("{:.%df}"%tPrec).format(dec(torque, tPrec)),
          'A': ("{:.%df}"%aPrec).format(dec(angle, aPrec)),
          'D': ("{:.%df}"%dPrec).format(dec(duration, dPrec)),
          'Tr': Tr, # -1, 0, 1
          'Ar': Ar, # -1, 0, 1, 2
          'Dr': Dr, # -1, 0, 1, 2
          'tPrec': dec(1, tPrec),
          'aPrec': dec(1, aPrec),
          'dPrec': dec(1, dPrec)
        })

    if WGDBus.getNewResult() or stored:
        return json(res)
    else:
        return json(None)
