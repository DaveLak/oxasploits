# coding=utf-8
import os
import cStringIO
import traceback
import Activity
import mimetypes
import FilePaths
import fsio
import types
import syslog
import sys
import time
from gluon.contrib import user_agent_parser
import logConfig
import notify_activity
import status_mod

# Fake globals for syntax check
if False:
  response = None
  request = None
  session = None
  db = None
  HTTP = None

SHOW_HIDDEN = False

#These function are called periodically by gui and non is issued by user.
#In case if it s inetended to be called by user, the function must be called indirectly using another name.
if request.function != 'sdPathList' and \
        request.function != 'checkCfgDir' and \
        request.function != 'checkLogsDir' and \
        request.function != 'checkDocDir':
  status_mod.sessionUserMgr.setLastVisit(session, request)

if logConfig.fsSessFrgt:
  session.forget(response)


@auth.requires(request.ajax==True, requires_login=True)
def version():
  return (FilePaths.version())


@auth.requires(request.ajax==True, requires_login=True)
def getitems():
  path = request.vars.node
  back = request.vars.back

  path = os.path.expandvars(path)
  dirpath, dirnames, filenames = os.walk(path).next()
  dirnames.sort()
  filenames.sort()

  data = []
  if back == 'true':
    data.append({'text': '..', 'leaf': False, 'id': path[:path.rfind('/')]})

  for dirname in dirnames:
    if SHOW_HIDDEN or not dirname.startswith('.'):
      data.append({'text': dirname, 'leaf': False, 'id': os.path.join(path, dirname)})
  for filename in filenames:
    if SHOW_HIDDEN or not filename.startswith('.'):
      data.append({'text': filename, 'leaf': True, 'id': os.path.join(path, filename)})
  return response.json(data)


@auth.requires(request.ajax==True, requires_login=True)
def findDir(rootPath, matchDir):
  found = None
  #always as list
  if rootPath != types.ListType:
     rootPath = [rootPath]
  for node in rootPath:
    path = os.path.expandvars(node)
    dirpath, dirnames, filenames = os.walk(path).next()
    for dirname in dirnames:
      if dirname == matchDir:
        found = node
        break
    if found != None:
      break;
  return found


@auth.requires(request.ajax==True, requires_login=True)
def checkDocDir():
  data = []
  path = findDir(request.vars.node, FilePaths.SD_DOC_DIR_NAME)
  if path != None:
    path = os.path.join(path, FilePaths.SD_DOC_DIR_NAME);
    p = os.path.expandvars(path)
    dirpath, dirnames, filenames = os.walk(p).next()
    data.append(len(filenames))
  return response.json(data)


@auth.requires(request.ajax==True, requires_login=True)
def checkCfgDir():
  if os.access(request.vars.path + '/' + FilePaths.SD_CFG_DIR_NAME, os.F_OK):
    return ('true')
  return ('false')


@auth.requires(request.ajax==True, requires_login=True)
def checkLogsDir():
  if os.access(request.vars.path + '/' + FilePaths.SD_LOGS_DIR_NAME, os.F_OK):
    return ('true')
  return ('false')


@auth.requires(request.ajax==True, requires_login=True)
def getcfgs():
  ver = version().strip()
  def excludeF(fname):
    return (False)#not fname.startswith(ver))
  return (getDirFiles(request.vars.node, FilePaths.SD_CFG_DIR_NAME, FilePaths.SD_CFG_EXT, excludeF))


@auth.requires(request.ajax==True, requires_login=True)
def getDirFiles(rootPath, searchDir, ext='*', exclude=None):
  path = findDir(rootPath, searchDir)
  data = []
  if path != None:
    path = os.path.join(path, searchDir);
    p = os.path.expandvars(path)
    dirpath, dirnames, filenames = os.walk(p).next()
    filenames.sort()
    for filename in filenames:
      if SHOW_HIDDEN or not filename.startswith('.'):
        if exclude != None:
          if exclude(filename):
            continue
        if ext == '*':
          data.append({'text': filename, 'id': os.path.join(path, filename)})
        elif filename.endswith('.' + ext):
          data.append({'text': filename, 'id': os.path.join(path, filename)})

  return response.json(data)


@auth.requires(request.ajax==True, requires_login=True)
def getTXT():
  filename = os.path.expandvars(request.vars.f)

  try:
    data = fsio.read(filename)
  except:
    raise HTTP(404, "Cannot open file")

  if '\0' in data:
    raise HTTP(404, "Cannot open binary files")

  return data


@auth.requires(request.ajax==True, requires_login=True)
def saveTXT():
  filename = os.path.expandvars(request.vars.f)
  try:
    fsio.write(filename, request.body.read())
  except:
    raise HTTP(404, "Cannot save file")

  notify_activity.configChanged(filename, Activity.FILE_SAVED, session=session)


@auth.requires(request.ajax==True, requires_login=True)
def newFile():
  filename = request.vars.f
  filename = os.path.expandvars(filename)

  if os.access(filename, os.R_OK):
    raise HTTP(404, "File already exists")

  try:
    fsio.write(filename, '')
  except:
    raise HTTP(404, "Cannot save file")

  notify_activity.configChanged(filename, Activity.FILE_NEW, session=session)


@auth.requires(request.ajax==True, requires_login=True)
def newDir():
  dirname = request.vars.f
  dirname = os.path.expandvars(dirname)
  if os.access(dirname, os.R_OK):
    raise HTTP(404, "Directory already exists")

  try:
    os.mkdir(dirname)
  except:
    raise HTTP(404, "Cannot create directory")

  Activity.LOG(session, Activity.DIRECTORY_NEW, dirname)


@auth.requires(request.ajax==True, requires_login=True)
def remove():
  filename = request.vars.f
  filename = os.path.expandvars(filename)
  if os.path.isdir(filename):
    try:
      os.rmdir(filename)
      Activity.LOG(session, Activity.DIRECTORY_DELETED, filename)
    except:
      raise HTTP(404, "Cannot remove directory")
  else:
    try:
      os.remove(filename)
      Activity.LOG(session, Activity.FILE_DELETED, filename)
    except:
      raise HTTP(404, "Cannot remove file")


@auth.requires(request.ajax==True, requires_login=True)
def rename():
  filenameOld = request.vars.fo
  filenameNew = request.vars.fn
  filenameOld = os.path.expandvars(filenameOld)
  filenameNew = os.path.expandvars(filenameNew)

  try:
    os.rename(filenameOld, filenameNew)
  except:
    raise HTTP(404, "Cannot rename item")

  Activity.LOG(session, Activity.PATH_RENAMED, filenameOld, filenameNew)


def upload():
  try:
    dirname = os.path.expandvars(request.vars.trgtPath)
    filename = os.path.join(dirname, request.vars.fileupload.filename.split("\\")[-1])
  except:
    return response.json({'success': False, 'msg': 'Invalid parameters'})

  try:
    # only to check whether file is accessible
    fp = open(filename, 'wb')
  except:
    return response.json({'success': False, 'msg': 'Cannot open file'})
  finally:
    fp.close()
  try:
    data = cStringIO.StringIO(request.vars.fileupload.file.read())
    fsio.write(filename, data.getvalue())
  except:
    return response.json({'success': False, 'msg': 'Cannot write file'})
  fp.close()

  notify_activity.configChanged(filename, Activity.FILE_UPLOAD, session=session)

  return response.json({'success': True, 'msg': ':-)'})


def download():
  path = request.vars.f
  filename = os.path.split(path)[1]
  try:
    with open(path, 'rb') as f_in:
      data = f_in.read()
      response.headers['Content-Disposition'] = 'attachment; filename="%s"' % filename
      response.headers['Content-Type'] = 'application/octet-stream; name="%s"' % filename
  except:
    raise HTTP(400, 'file not found')
  return data


def downloadR():
  data = download()
  try:
    remove()
  except:
    pass
  return data


def uploadFile():
  try:
    filename = request.vars.fileupload.filename.split("\\")[-1]
    target = request.vars.trgtPath
    fileTarget = os.path.join(target, filename)
  except:
    return response.json({'success': False, 'msg': 'Invalid parameters'})
  try:
    fsio.write(fileTarget, request.vars.fileupload.value)
  except:
    syslog.syslog(syslog.LOG_ERR, str(sys.exc_info()[1]))
    return response.json({'success': False, 'msg': 'Cannot write file'})

  notify_activity.configChanged(fileTarget, Activity.FILE_UPLOAD, session=session)

  return response.json({'success': True, 'msg': ':-)'})


def view():
  path = request.vars.f
  filename = os.path.split(path)[1]
  try:
    with open(path, 'rb') as f_in:
      data = f_in.read()
      response.headers['Content-Type'] = '{0}; name={1}'.format(mimetypes.guess_type(filename)[0], filename)
  except:
    raise HTTP(400, 'file not found')
  return data


@auth.requires(request.ajax==True, requires_login=True)
def test():
  path = request.vars.path
  tst = request.vars.t
  if tst == 'e':
    return 'true' if os.access(path, os.F_OK) else 'false'
  if tst == 'r':
    return 'true' if os.access(path, os.R_OK) else 'false'
  if tst == 'w':
    return 'true' if os.access(path, os.W_OK) else 'false'
  return 'false'


@auth.requires(request.ajax==True, requires_login=True)
def sdPathList():
  return response.json(FilePaths.getSDPaths())
