# coding: utf8

# -------------- Modules -------------------------
from gluon.serializers import json
from datetime import datetime
from struct import unpack_from
import WGDBus
import logConfig
import result_mod
import status_mod

# -------------- Constants -------------------------
import syslog


INVALID_VAL = -2147483648

torque_precision = 3
angle_precision = 6
time_precision = 6

# Fake globals for syntax check
if False:
    response = None
    request = None
    session = None
    db = None
    resultdb = None

status_mod.sessionUserMgr.setLastVisit(session, request)
if logConfig.resultSessFrgt:
    session.forget(response)

# -------------- Utils -------------------------

"""
This functions are used internally and are not
callable with an HTTP request.
They must have parameters or start with __
"""

def decOld(x, nd):
    """
    Approximate x to the nd position after comma
    """
    f = 10 ** nd
    #return round(x * f) / f
    #fix for python round bug on target
    #return int(x * f)
    return round(x, nd) * f


def targetName(code):
    if code == 0x1600:
        return '->ZFM'
    if code == 0x1601:
        return '->ZFW'
    if code == 0x1601:
        return '->ZFZ'
    return '???'


def monitorName(code):
    return '???'


def precT(tSpindle):
    return 3
    #if tSpindle < 10: return 3
    #if tSpindle < 100: return 2
    #if tSpindle < 1000: return 1
    #return 0


"""
def lastCmdName(cmdCode):
  Return the name of a command code

  if cmdCode == 0x1200:
    return 'Cw->0'
  if cmdCode == 0x1600:
    return '-> ZFM'
  if cmdCode == 0x1601:
    return '-> ZFW'
  if cmdCode == 0x1602:
    return '-> ZFZ'
  return '???'
"""
# -------------- Exposed -------------------------
"""
This are the function callable with an HTTP request.
"""


@auth.requires(request.ajax==True, requires_login=True)
def cycleList():
    """
    Return the list of cycles.

    parameters: none
    """
    cycleList = []
    cycleEntries = resultdb.executesql("SELECT id, cycle FROM srbergallg")
    for cycleEntry in cycleEntries:
        cycleList.append({'id': cycleEntry[0], 'cycle': cycleEntry[1]})
    return json(cycleList)


@auth.requires(request.ajax==True, requires_login=True)
def levelList():
    """
    Return the list of levels for a cycle.

    parameters:
      id : cycle id
    """
    levelList = []
    allg_id = request.vars.id
    if allg_id:
        levelEntries = resultdb.executesql("SELECT id, row, col FROM stuferg WHERE allg_id=%s" % allg_id)
        for levelEntry in levelEntries:
            levelList.append({'id': levelEntry[0],
                              'row': levelEntry[1],
                              'col': levelEntry[2],
                              'name': result_mod.levelName(levelEntry[1], levelEntry[2])})
    return json(levelList)


@auth.requires(request.ajax==True, requires_login=True)
def graphdata():
    return result_mod.graphdata(request, resultdb)


@auth.requires(request.ajax==True, requires_login=True)
def graphinfo():
    return result_mod.graphinfo(request, resultdb)


@auth.requires(request.ajax==True, requires_login=True)
def actualvalues():
    return result_mod.actualvalues(request, resultdb)


@auth.requires(request.ajax==True, requires_login=True)
def lastCycle():
    """
    Return the last cycle id
    """
    res = resultdb.executesql('SELECT MAX(id) FROM srbergallg')
    if res:
        cycleId = res[0][0]
    else:
        cycleId = 0
    return json(cycleId)


@auth.requires(request.ajax==True, requires_login=True)
def graphcycles():
    cycleEntries = resultdb.executesql("SELECT cycle, result FROM srbergallg")
    cycleData = []
    for cycleEntry in cycleEntries:
        cycleData.append({'cycleId': cycleEntry[0], 'okStatus': True if cycleEntry[1] > 0 else False})

    if cycleData != []:
        return json(cycleData)
    else:
        return json(None)
