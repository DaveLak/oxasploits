import json
import pprint
import traceback
import WGDBus
import FilePaths
import time
import fsio
import datetime
import Activity
import syslog
import glob
import os
import re
import subprocess
from subprocess import call
import notify_activity

if False:
  response = None
  request = None
  session = None
  db = None



# ------ In END Step action[2] not implemented!!  RemoteJobs()!


BMS = {}
BMS['BMS_SE_E_PROGi'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn','dest': 1, 'range': 8, 'state': 1, 'valueList': "", 'comment': "BMS_SE_E_PROGi"}
BMS['BMS_SE_A_ACKi'] = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeBms', 'dest': 1,'range': 8, 'state': 1, 'valueList': "", 'comment': "BMS_SE_A_ACKi"}
BMS['TriggerInModePrgNrAck'] = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModePrgNrAck', 'dest': 1,'range': 8, 'state': 1, 'valueList': "", 'comment': "Wait for prog no acknowledge"}
BMS['BMS_SE_E_EN'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 9, 'range': 1, 'state': 1, 'valueList': "", 'constname': "Tool enable", 'undo': "true", 'comment': "BMS_SE_E_EN"}
BMS['BMS_SE_E_EN_Dis'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 9, 'range': 1, 'state': 0, 'valueList': "", 'constname': "Tool disable", 'comment':"BMS_SE_E_EN"}
BMS['BMS_SE_E_CW'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 11, 'range': 1, 'state': 1, 'valueList': "", 'constname': "Clock Wise", 'undo': "true", 'comment': "BMS_SE_E_CW"}
BMS['BMS_SE_E_CW_Dis'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 11, 'range': 1, 'state': 0, 'valueList': "", 'constname': "Clock Wise disable", 'comment': "BMS_SE_E_CW"}
#BMS.BMS_SE_A_JOB_APPOUTx = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 145, 'range': 1, 'state': 1, 'valueList': "", 'comment': "BMS_SE_A_JOB_APPOUTx"}
BMS['BMS_SE_E_JOB_NRx'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 106,'range': 8, 'state': 1, 'valueList': "", 'comment': "BMS_SE_E_JOB_NRx"}
BMS['BMS_SE_E_JOB_EN'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn',  'dest': 100, 'range': 1, 'state': 1, 'valueList': "", 'constname': "Job enable", 'undo': "true", 'comment': "BMS_SE_E_JOB_EN"}
BMS['BMS_SE_E_JOB_EN_Dis'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 100, 'range': 1, 'state': 1, 'valueList': "", 'constname': "Job disable", 'undo': "true", 'comment': "BMS_SE_E_JOB_EN"}
BMS['BMS_SE_E_JOB_CW'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 101, 'range': 1, 'state': 1, 'valueList': "", 'constname': "Job run", 'undo': "true", 'comment': "BMS_SE_E_JOB_CW"}
BMS['BMS_SE_E_JOB_CW_Dis'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn', 'dest': 101, 'range': 1, 'state': 1, 'valueList': "", 'constname': "Job stop", 'undo': "true", 'comment': "BMS_SE_E_JOB_CW"}
BMS['bms_cycmp'] = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeCyCmpInternal', 'dest': 'plc.Out.CyCmp', 'range': 0, 'state': 1, 'valueList': "", 'constname': 'Wait for cycle complete', 'comment': "bms_cycmp"}
BMS['BMS_SE_E_SOCK_CHAM_SELECTEDz'] = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeBms', 'dest': 80, 'range': 8, 'state': 0, 'valueList': "", 'comment': "BMS_SE_E_SOCK_CHAM_SELECTEDz"}
BMS['BMS_KE_E_FOxDISABLE'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn',  'dest': 0, 'range': 1, 'state': 1, 'valueList': "", 'comment': "Disable FOBlock"}
BMS['BMS_KE_E_FOxCw'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeBmsIn',  'dest': 0, 'range': 1, 'state': 1, 'valueList': "", 'comment': "set FO x Cw"}
BMS['BMS_FOBLOCKz'] = 16
BMS['BMS_FOxSIZE'] = 24
BMS['BMS_E_FOxCW'] = 8
BMS['BMS_E_FOxDISABLE'] = 16
BMS['BMS_SE_A_CYCMP'] = 13
BMS['BMS_A_FOxCYCMP'] = 16

# add virtual bms entries for atoms not handling bms-signals
BMS['TighteningResult']		= {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeTighteningResult', 'dest': 0, 'range': 0, 'state': 0, 'valueList': "", 'comment': "wait for tightening results"}
BMS['devicelocal']      	= {'type': 'c.TypeDevice',     'mode': 'c.DeviceModeLocal',           'dest': '',    'range': 0, 'state': 0, 'valueList': "", 'constname': "Set device to local", 'comment': "device atom local"}
BMS['deviceremote']     		= {'type': 'c.TypeDevice',     'mode': 'c.DeviceModeRemote',          'dest': '""',  'range': 0, 'state': 0, 'valueList': "", 'comment': "device atom remote"}
BMS['deviceOP']         		= {'type': 'c.TypeDevice',     'mode': 'c.DeviceModeOpenProtocol',   'dest': '""',  'range': 0, 'state': 0, 'valueList': "", 'nodesuppress': True, 'comment': "device atom OP"}
BMS['deviceOpWaitGroup']  		= {'type': 'c.TypeDevice',     'mode': 'c.DeviceModeOpenProtocol',    'dest': '""',  'range': 0, 'state': 0, 'valueList': "", 'comment': "device atom OP wait group"}
BMS['DisplayPrgStepText'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 2, 'valueList': {}, 'constname': 'DisplayPrgStepText', 'comment': ''}
BMS['DisplayPrgStepTextTimeDelay'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': "", 'constname': 'DisplayPrgStepTextTimeDelay', 'comment': ''}
BMS['SetOkNokCounter']  		= {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeSetOkNok',    'dest': 0,     'range': 0, 'state': 7, 'valueList': {}, 'undo': False, 'comment': "set OkNok-counter"}
BMS['SetOkNokCounterUndo']		= {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeDelOkNok',    'dest': 0,     'range': 0, 'state': 7, 'valueList': "", 'undo': True, 'comment': "set OkNok-counter"}
BMS['DelOkNokCounter'] 		= {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeDelOkNok',    'dest': 0,     'range': 0, 'state': 7, 'valueList': "", 'comment': "del OkNok-counter"}
BMS['OkNokResult']      		= {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeOkNokResult',  'dest': 0,     'range': 0, 'state': 0, 'valueList': "", 'comment': "wait for OkNok-counter results"}
BMS['ApplicationResult']       = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeApplicationResult', 'dest': 0, 'range': 0, 'state': 0, 'valueList':"", 'comment': "wait for Application results"}
BMS['AppOkNokResult']    		= {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeAppOkNokResult', 'dest': 0,   'range': 0, 'state': 0,'valueList': "", 'comment': "wait for AppOkNok results"}
BMS['ILAck']                   = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeILAck',        'dest': 0,     'range': 0, 'state': 0, 'valueList': "", 'comment': "wait for IL acknowledge"}
BMS['WaitTimeDelay']    		= {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeTimeDelay',   'dest': 0,     'range': 0, 'state': 0, 'valueList': "", 'comment': "wait for delayed time"}
BMS['SetTimeDelay']    		= {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay',   'dest': 0,     'range': 0, 'state': 5, 'valueList': "", 'comment':"set time for delay"}
BMS['SetAppOutSignals'] 		= {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeJobAppOut',   'dest': 0,     'range': 0, 'state':5, 'valueList': "", 'comment': "set JobOut signals"}
BMS['SetAppInSignals'] 		= {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeJobAppIn',     'dest': 0,     'range': 0, 'state': 5,'valueList': "", 'comment': "set JobIn signals"}
BMS['JobResult']        		= {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeJobResult',    'dest': 0,     'range': 0, 'state': 0,'valueList': "", 'comment': "wait for Job results"}
BMS['TriggerOutModeStepInit']	= {'type':'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeStepInit',    'dest': 0,     'range': 0,'state':0, 'valueList': "", 'comment': "step init"}
BMS['TriggerOutModeStepFinal']	= {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeStepFinal',   'dest': 0,     'range': 0, 'state': 0, 'valueList': "", 'comment': "step final"}
BMS['ILBridge']                = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeILBridge',    'dest': 0,     'range': 0, 'state': 0, 'valueList': "", 'comment': "IL Bridge"}
BMS['jobTriggerInModeILAck'] 	= {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeILAck', 		'dest': 0,	  'range': 0, 'state': 0, 'valueList': "", 'comment': "wait for IL Bridge acknowledge"}
BMS['InitScanner'] = {'type': 'c.TypeTriggerOut',  'mode': 'c.TriggerOutModeScanInit', 		'dest': 0,	  'range': 0, 'state': 0, 'valueList': {}, 'constname': "InitScanner", 'comment': "state gibt id des id code steps vor einer Prg Stufe an: 1 = IDCode Step 1, 2. IDCode Step=2, ...., im Modus= 0"}
BMS['WaitScanInitAck'] = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeScanInitAck', 		'dest': 'plc.Out.EnScanAck',	  'range': 0, 'state': 0, 'valueList': "", 'constname': "WaitScanInitAck", 'comment': "c.TriggerOutScanPrg"}
BMS['WaitScanStartTrigger'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeScanTrigger', 'dest': 0, 'state': 1, 'range': 1, 'valueList': {}, 'constname': "WaitScanStartTrigger", 'comment': 'c.TriggerOutScanPrg'}
BMS['DoScan'] = {'type': 'c.TypeTriggerOut',  'mode': 'c.TriggerOutModeDoScan', 		'dest': 0,	  'range': 0, 'state': 0, 'valueList': "", 'constname': "DoScan", 'comment': "c.TriggerOutScanPrg"}
BMS['DisplayIDCode'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 2, 'valueList': {}, 'constname': 'DisplayIDCode', 'comment': ''}
BMS['DisplayIDCodeTimeDelay'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': "", 'constname': 'DisplayIDCodeTimeDelay', 'comment': ''}
BMS['TriggerInGrp'] = {'type': 'c.TypeTriggerInGrp', 'members': ["WaitIdCode", "WaitIdCodeTimeout"], 'constname': "TriggerInGrp"}

BMS['WaitIdCodeTimeout'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeoutAtom', 'dest': 0, 'range': 1, 'state': 'c.TriggerInModeIdCode', 'timeout': 3, 'constname': 'WaitIdCodeTimeout', 'comment': ''}
BMS['WaitIdCode'] = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeIdCode', 		'dest': 0,	  'range': 0, 'state': 1, 'valueList': "", 'constname': "WaitIdCode", 'comment': ""}

BMS['ScanFailed'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 3, 'valueList': {}, 'constname': 'ScanFailed', 'comment': ""}
BMS['ScanFailedTimeDelay'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': 'ScanFailedTimeDelay', 'text': '{{{ID input failed', 'failure': True, 'comment': ""}
BMS['SetIdCode'] = {'type': 'c.TypeTriggerOut',  'mode': 'c.TriggerOutIDCodeParts', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': "Set IdCode", 'comment': "combine scanned ID Codes --"}
BMS['ScanFinalOK'] = {'type': 'c.TypeTriggerOut',  'mode': 'c.TriggerOutModeScanFinal', 'dest': 0, 'range': 0, 'state': 1, 'valueList': {}, 'constname': "ScanFinalOK", 'comment': "state: 0= hide Scan Icon, 1= still display Scan Icon"}
BMS['ScanFinalNOK'] = {'type': 'c.TypeTriggerOut',  'mode': 'c.TriggerOutModeScanFinal', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': "ScanFinalNOK", 'comment': "state: 0= hide Scan Icon, 1= still display Scan Icon"}
BMS['ScanFinalTimeout'] = {'type': 'c.TypeTriggerOut',  'mode': 'c.TriggerOutModeScanFinal', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': "ScanFinalTimeout", 'comment': "state: 0= hide Scan Icon, 1= still display Scan Icon"}

BMS['OkNokResultTimeout'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeoutAtom', 'dest': 0, 'range': 1, 'state': 'c.TriggerInModeOkNokResult', 'timeout': 600, 'constname': 'OkNokResultTimeout', 'comment': ''}

BMS['DoNokResult'] = {'type': 'c.TypeTriggerOut',  'mode': 'c.TriggerOutModeJobResult', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': "DoNokResult", 'comment': ""}




#----------------------------------------------MSG Loop atoms-----------------------------------------------------------
BMS['DisplayMsgTimeDelay'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 3, 'valueList': {}, 'constname': 'DisplayMsgTimeDelay', 'comment': ""}
BMS['DisplayPrgStepTimeDelay'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': 'DisplayPrgStepTimeDelay', 'text': 'timeout', 'failure': True, 'comment': ""}

BMS['DisplayNoScanner'] =  {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeScanInitAck', 'dest': 0, 'range': 0, 'state': 1, 'valueList': {}, 'constname': 'DisplayNoScanner', 'text': '{{{Scanner initialization failed', 'comment': ""}
BMS['DisplayScannerNotActive'] =  {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeScanInitAck', 'dest': 0, 'range': 0, 'state': 1, 'valueList': {}, 'constname': 'DisplayScannerNotActive', 'text': '{{{Scanner not active', 'comment': ""}

BMS['DisplayMsgTimeoutDelay'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 3, 'valueList': {}, 'constname': 'DisplayMsgTimeoutDelay', 'comment': ""}
BMS['ScanTimeoutDelay'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': 'ScanTimeoutDelay', 'text': '{{{ID input failed', 'failure': True, 'comment': ""}

BMS['DisplayMsgScanTimeoutDelay'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 3, 'valueList': {}, 'constname': 'DisplayMsgScanTimeoutDelay', 'comment': ""}
BMS['ScanTimeoutMsg'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': 'ScanTimeoutMsg', 'text': '{{{Scan Failed', 'failure': True, 'comment': ""}

BMS['DisplayMsgNotSupportedDelay'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 3, 'valueList': {}, 'constname': 'DisplayMsgNotSupportedDelay', 'comment': ""}
BMS['CodeNotSupportedMsg'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': 'CodeNotSupportedMsg', 'text': '{{{Barcode not supported', 'failure': True, 'comment': ""}

BMS['DisplayMsgNotActiveDelay'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 3, 'valueList': {}, 'constname': 'DisplayMsgNotActiveDelay', 'comment': ""}
BMS['CodeNotActiveMsg'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': 'CodeNotActiveMsg', 'text': '{{{Barcode not active in Job', 'failure': True, 'comment': ""}

BMS['DisplayMsgNoAssignmentDelay'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 1000, 'range': 0, 'state': 3, 'valueList': {}, 'constname': 'DisplayMsgNoAssignmentDelay', 'comment': ""}
BMS['DisplayNoAssignment'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': 'DisplayNoAssignment', 'text': '{{{Code not found in assignment table', 'failure': True, 'comment': ""}

#----------------------------------------------END MSG Loop atoms-----------------------------------------------------------

#BMS['DisplayScanStepText'] = {'type': 'c.TypeTriggerOut', 'mode': 'c.TriggerOutModeTimeDelay', 'dest': 0, 'range': 0, 'state': 2, 'valueList': {}, 'constname': 'DisplayScanStepText', 'comment': ''}
#BMS['DisplayScanStepTextTimeDelay'] = {'type': 'c.TypeTriggerIn', 'mode': 'c.TriggerInModeTimeDelay', 'dest': 0, 'range': 0, 'state': 0, 'valueList': "", 'constname': 'DisplayScanStepTextTimeDelay', 'comment': ''}
BMS['IdCodeInit'] = {'type': 'c.TypeTriggerOut',  'mode': 'c.TriggerOutModeIdCodeInit', 'dest': 0, 'range': 0, 'state': 0, 'valueList': {}, 'constname': "IdCodeInit", 'comment': ""}
BMS['WaitForIncycle'] = {'type': 'c.TypeTriggerIn',  'mode': 'c.TriggerInModeInCyInternal', 'dest': 0, 'range': 0, 'state': 1, 'valueList': {}, 'constname': "Wait for Incycle", 'comment': ""}
BMS['TriggerInGrpOkNokResult'] = {'type': 'c.TypeTriggerInGrp', 'members': ["Text on screen", "OkNokResultTimeout"], 'constname': "TriggerInGrpOkNokResult"}



#Bms Eingangssignale
In = {}
In['In.Prog0']     = 1
In['In.Prog1']     = 2
In['In.Prog2']     = 3
In['In.Prog3']     = 4
In['In.Prog4']     = 5
In['In.Prog5']     = 6
In['In.Prog6']     = 7
In['In.Prog7']     = 8

In['In.En']        = 9    # E : Betriebsmittelsteuerung bereit
In['In.ResF']      = 10   # E : Quittierung Systemfehler
In['In.Cw']        = 11   # E : Schrauberstart rechts
In['In.Ccw']       = 12   # E : Suchlauf links (Programm 99)
In['In.ResRs']    = 13   # E : Ergebnis Reset
In['In.NokAc']     = 14   # E : NIO Quittierung
In['In.DisRp']     = 15   # E : Unterdrueckung Ergebnisausgabe
In['In.DisRpFtp']  = 16   # Unterdrueckung FTP-Ergebnisausgabe

In['In.CntRes']    = 17   # E : Summenzaehler Counter Reset

In['In.CntSel0']  =   18   # E : BMS Summenzaehler Auswahl Bit 0
In['In.CntSel1']  =   19   # E : BMS Summenzaehler Auswahl Bit 1
In['In.CntSel2']  =   20   # E : BMS Summenzaehler Auswahl Bit 2
In['In.CntSel3']  =   21   # E : BMS Summenzaehler Auswahl Bit 3
In['In.CntSel4']  =   22   # E : BMS Summenzaehler Auswahl Bit 4
In['In.CntSel5']  =   23   # E : BMS Summenzaehler Auswahl Bit 5
In['In.CntSel6']  =   24   # E : BMS Summenzaehler Auswahl Bit 6
In['In.CntSel7']  =   25   # E : BMS Summenzaehler Auswahl Bit 7

In['In.AppIn0']   =   28   # E : Applikations Eingaenge 0
In['In.AppIn1']   =   29   # E : Applikations Eingaenge 1
In['In.AppIn2']   =   30   # E : Applikations Eingaenge 2
In['In.AppIn3']   =   31   # E : Applikations Eingaenge 3
In['In.AppIn4']   =   32   # E : Applikations Eingaenge 4
In['In.AppIn5']   =   33   # E : Applikations Eingaenge 5
In['In.AppIn6']   =   34   # E : Applikations Eingaenge 6
In['In.AppIn7']   =   35   # E : Applikations Eingaenge 7
In['In.AppIn8']   =   36   # E : Applikations Eingaenge 8
In['In.AppIn9']   =   37   # E : Applikations Eingaenge 9
In['In.AppIn10']  =   38   # E : Applikations Eingaenge 10
In['In.AppIn11']  =   39   # E : Applikations Eingaenge 11
In['In.AppIn12']  =   40   # E : Applikations Eingaenge 12
In['In.AppIn13']  =   41   # E : Applikations Eingaenge 13
In['In.AppIn14']  =   42   # E : Applikations Eingaenge 14
In['In.AppIn15']  =   43   # E : Applikations Eingaenge 15

In['In.ActEn']    =   44   # E: Freigabe Kanal fuer 1 Zyklus
In['In.CcwLock']  =   45   # E: Linkslauf Sperren
In['In.CwLock']   =   46   # E: Rechtslauf sperren
In['In.CcwSel']   =   47   # E: Abfrage Stellung Startschalter
In['In.EnScan']   =   48   # E: Freigabe Scanner
In['In.ActScan']  =   49   # E: Scanner Laser Einschalten
In['In.ScanCTS']  =   50   # E: Scanner Clear To Send

#Bms Ausgangssignale
Out = {}
Out['Out.Ack0']       =  1    # A : Quittierung Programm Bit 0
Out['Out.Ack1']       =  2    # A : Quittierung Programm Bit 1
Out['Out.Ack2']       =  3    # A : Quittierung Programm Bit 2
Out['Out.Ack3']       =  4    # A : Quittierung Programm Bit 3
Out['Out.Ack4']       =  5    # A : Quittierung Programm Bit 4
Out['Out.Ack5']       =  6    # A : Quittierung Programm Bit 5
Out['Out.Ack6']       =  7    # A : Quittierung Programm Bit 6
Out['Out.Ack7']       =  8    # A : Quittierung Programm Bit 7

Out['Out.Rdy']        =  9    # A : Schraubersteuerung bereit
Out['Out.NF']         = 10    # A : Systemfehler (No Fault)
Out['Out.InCy']       = 11    # A : Start aktiv (In Cycle)
Out['Out.InCyCcw']    = 12    # A : In Cycle Counter Clock Wise
Out['Out.CyCmp']      = 13    # A : Ablaufende (Cycle Complete)
Out['Out.Ok']         = 14    # A : Ergebnis in Ordnung
Out['Out.Nok']        = 15    # A : Ergebnis nicht in Ordnung
Out['Out.FtpF']       = 16    # A : FTP Client Ausgabefehler
Out['Out.CCwSelAck']  = 17    # A : Richtung des Drehrichtungschalters
Out['Out.CheckTool']  = 18    # A : Serviceinterval (ErgoSpin)
Out['Out.CntOK']      = 19    # A : Summenzaehler OK Summe Ueberlauf
Out['Out.CntNOK']     = 20    # A : Summenzaehler NOK Summe Ueberlauf
Out['Out.TorqH']      = 21    # A : Moment zu hoch
Out['Out.TorqL']      = 22    # A : Moment zu niedrig
Out['Out.AnglH']      = 23    # A : Winkel zu hoch
Out['Out.AnglL']      = 24    # A : Winkel zu niedrig
Out['Out.TimeH']      = 25    # A : Zeit zu hoch
Out['Out.CcwLockAck'] = 26    # A : Bestaetigung,dass ccw-lock gesperrt
Out['Out.EnAck']      = 27    # A : Bestaetigung ueber Enable-Signal
Out['Out.ActENAck']   = 28    # A : Bestaetigung ueber ActEn-Signal
Out['Out.CwLockAck']  = 29    # A : Bestaetigung ueber CW-Lock
Out['Out.CwAck']      = 30    # A : Bestaetigung ueber CW
Out['Out.CcwAck']     = 31    # A : Bestaetigung ueber CCW

Out['Out.AppOut0']    = 32    # A : Applikation Ack0
Out['Out.AppOut1']    = 33    # A : Applikation Ack1
Out['Out.AppOut2']    = 34    # A : Applikation Ack2
Out['Out.AppOut3']    = 35    # A : Applikation Ack3
Out['Out.AppOut4']    = 36    # A : Applikation Ack4
Out['Out.AppOut5']    = 37    # A : Applikation Ack5
Out['Out.AppOut6']    = 38    # A : Applikation Ack6
Out['Out.AppOut7']    = 39    # A : Applikation Ack7
Out['Out.AppOut8']    = 40    # A : Applikation Ack8
Out['Out.AppOut9']    = 41    # A : Applikation Ack9
Out['Out.AppOut10']   = 42    # A : Applikation Ack10
Out['Out.AppOut11']   = 43    # A : Applikation Ack11
Out['Out.AppOut12']   = 44    # A : Applikation Ack12
Out['Out.AppOut13']   = 45    # A : Applikation Ack13
Out['Out.AppOut14']   = 46    # A : Applikation Ack14
Out['Out.AppOut15']   = 47    # A : Applikation Ack15

Out['Out.BattOk']     = 48    # A : AkkuOK
Out['Out.BattOff']    = 49    # A : Akku Abgezogen
Out['Out.EnScanAck']  = 50    # A : Enable Scanner Acknoledge
Out['Out.ScanRdy']    = 51    # A : Scanner engine ready
Out['Out.ActScanAck'] = 52    # A : Scanner Laser Einschalten Acknoledge
Out['Out.ScanRxID']   = 53    # A : Scanner Received New ID-Code



class SingletonType(type):
    def __call__(cls, *args, **kwargs):
        try:
            return cls.__instance
        except AttributeError:
            cls.__instance = super(SingletonType, cls).__call__(*args, **kwargs)
            return cls.__instance


step = {}
StartStep = {}
table = []
idinput_source = []
idtrigger_list = []


def formatRowColAtom(prefix, row, col, atom):
   prefix = prefix or "p"
   row = row or 0
   col =col or 1
   colstring = chr(col + 64)
   atom = atom or 0
   return '%s$%02d%s%02d' % (prefix, row, colstring, atom)


class Node:

  def __init__(
      self,
      atom,
      nodename,
      steprow,
      stepcol,
      atomno,
      io,
      nio,
      comment,
      idSrc,
      displayName
  ):
    self.__index = self
    self.atom = atom
    self.atomname = atom.name
    self.nodename = nodename
    self.steprow = steprow
    self.stepcol = stepcol
    self.atomno = atomno
    self.io_next = io
    self.nio_next = nio
    self.comment = comment
    self.id_src = idSrc
    self.displayName = displayName


  def getNodeName(self):
    return formatRowColAtom(self.nodename, self.steprow, self.stepcol, self.atomno)

  def getAtomName(self):
    return self.atomname

  def getColumn(self):
    return self.stepcol or "no column"

  def getRow(self):
    return self.steprow or "no row"

  def getName(self):
    return self.nodename or "no step name"

  def getDisplayName(self):
    return self.displayName or "no step name"

  def getIO(self):
    return self.io_next or 0

  def getNIO(self):
    return self.nio_next or 0

  def getComment(self):
    if self.comment != "":
      self.comment = self.comment.replace("\\", "\\\\")
    return self.comment or ""

  def getIDSource(self):
    return self.id_src or 0

  def __str__(self):
    res = " Step (atomname: " + str(self.atomname)
    res += "; nodename: " + str(self.nodename)
    res += "; steprow: " + str(self.steprow)
    res += "; stepcol: " + str(self.stepcol)
    res += "; atomno: " + str(self.atomno)
    res += "; io_next: " + str(self.io_next)
    res += "; nio_next: " + str(self.nio_next)
    res += "; comment: " + str(self.comment)
    res += "; id_source: " + str(self.id_src)
    res += ")"
    return res

  def __repr__(self):
    return self.__str__()


class Step:

  __metaclass__ = SingletonType

  def __init__(self, io=0, nio=0):
    self.nodes = []
    self.__index = self
    self.steprow = 0
    self.stepcol = 1
    self.atomno = 0
    self.stepname = ""
    self.displayName = ""

  def setDisplayName(self, displayName):
    self.displayName = displayName

  def nextStep(self, stepname):
    self.steprow = self.steprow + 1
    self.atomno = 0
    self.stepname = stepname or "no step name"

  def addNode(self, atom, id_src):
    node = Node(
        atom,
        self.stepname,
        self.steprow,
        self.stepcol,
        self.atomno,
        step['IO_Next'],
        step['NIO_Next'],
        step['comment'],
        id_src,
        self.displayName
    )
    self.nodes.append(node)
    self.atomno = self.atomno + 1

  def getRowColName(self, prefix, undo):
    undo = undo or False
    if undo:
      self.atomno = self.atomno - 1
    name = formatRowColAtom(prefix, self.steprow, self.stepcol, self.atomno)
    if undo:
      self.atomno = self.atomno + 1
    return name

  def getFirstNodeName(self):
    return self.nodes[0].getNodeName()

  def resetList(self):
    self.nodes = []
    self.steprow = 0
    self.stepcol = 1
    self.atomno = 0

  def serialize(self, t):
    t.append('-- BS350 Nodes List\n')
    t.append('nodes = {}\n')

    #for (i, tup) in enumerate(self.nodes):
    #  if self.nodes[i].getAtomName().startswith('OkNokResultTimeout$'):
    #    del self.nodes[i]
    #  if self.nodes[i].getAtomName().startswith('Text on screen$'):
    #    del self.nodes[i]


    #print("SERIALIZE NODES LIST")
    for i in self.nodes:
        from pprint import pprint
        ##pprint(i)
        t.append('nodes["' + i.getNodeName() + '"] = {}')

    nodes_per_step = {}
    for i in range(len(self.nodes)):
        n = self.nodes[i]
        steprow = n.steprow
        if not steprow in nodes_per_step:
            nodes_per_step[steprow] = []
        nodes_per_step[steprow].append(n)

    id_source = 0

    #print "got nodes_per_step"
    for i in range(len(self.nodes)):
    #for i, localnode in enumerate(reversed(self.nodes)):

        localnode = self.nodes[i]
        steprow = localnode.steprow
        atom = localnode.atom
        #print "INDEX", (i + 1), "--->", atom, "steprow", localnode.steprow, "", localnode.getNodeName(), localnode
        #for n in nodes_per_step[steprow]:
        #    print "all rows of the step!", n.atom.name, n.getNodeName(), n.steprow

        if not localnode.getNodeName():
            print("Serialize: not node:getnodename()")
        if not localnode.getAtomName():
            print("Serialize: not node:getatomname()")


        if localnode.getNodeName() and localnode.getAtomName():
            t.append('nodes["' + str(localnode.getNodeName()) + '"].atom = atoms["' + str(localnode.getAtomName()) + '"]')

        #---------------------------------------------------------------------------------------------------------------
        # DoScan NODE
        #---------------------------------------------------------------------------------------------------------------
        if localnode.getAtomName().startswith("DoScan$"):
            stepnodes = nodes_per_step.get(localnode.steprow)
            for n in stepnodes:
                if n.getAtomName().startswith("TriggerInGrp$"):  # n.getAtomName().startswith("WaitScanResult$"):    # n.getAtomName().startswith("TriggerInGrp$"):
                    successor = n
                    t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # IdCodeInit NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("IdCodeInit$"):
            id_source = localnode.getIDSource()
            if id_source == 1 or id_source == 5:
                stepnodes = nodes_per_step.get(localnode.steprow)
                for n in stepnodes:
                    if n.getAtomName().startswith("TriggerInGrp$"):  # n.getAtomName().startswith("WaitScanResult$"):    # n.getAtomName().startswith("TriggerInGrp$"):
                        successor = n
                        t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')
            else:
                stepnodes = nodes_per_step.get(localnode.steprow)
                for n in stepnodes:
                    if n.getAtomName().startswith("InitScanner$"):  # n.getAtomName().startswith("WaitScanResult$"):    # n.getAtomName().startswith("TriggerInGrp$"):
                        successor = n
                t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # WaitScanTimeout NODE
        #---------------------------------------------------------------------------------------------------------------
        #elif localnode.getAtomName().startswith("WaitIdCodeTimeout$"):
        #    for n in stepnodes:
        #        if n.getAtomName().startswith("ScanFailed$"):
        #            successor = n
        #            t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # DisplayIDCodeTimeDelay NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("DisplayIDCodeTimeDelay$"):
            #successor = nodes_per_step.get(steprow + 1)[0]
            for n in stepnodes:
              if n.getAtomName().startswith("ScanFinalOK$"):
                successor = n
            t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')

        #---------------------------------------------------------------------------------------------------------------
        # ScanFailedTimeDelay NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("ScanFailedTimeDelay$"):
            for n in stepnodes:
              if n.getAtomName().startswith("ScanFinalTimeout$"):
                successor = n

            #successor = nodes_per_step.get(max(nodes_per_step.iterkeys()))[0]
            t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # ScanFailedTimeDelayRepeats NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("ScanFailedTimeDelayRepeat$"):
          if id_source == 1:
              stepnodes = nodes_per_step.get(localnode.steprow)
              for n in stepnodes:
                  if n.getAtomName().startswith("TriggerInGrp$"):
                      successor = n
                      t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')
          else:
              t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + stepnodes[1].getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # ScanFinalOk NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("ScanFinalOK$"):
          successor = stepnodes[-1]
          t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # ScanFinalTimeout NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("ScanFinalTimeout$"):
          stepnodes = nodes_per_step.get(localnode.steprow)
          for step in self.nodes:
            if step.atom.name.startswith("DoNokResult$"):
              successor = step
          #successor = nodes_per_step.get(max(nodes_per_step.iterkeys()))[0]

          t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # ScanFinalNOK NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("ScanFinalNOK$"):
          for step in stepnodes:
            if step.atom.name.startswith("DoNokResult$"):
              successor = step

          #successor = nodes_per_step.get(max(nodes_per_step.iterkeys()))[0]
          t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # InitScanner NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("InitScanner"):
            stepnodes = nodes_per_step.get(localnode.steprow)
            successors = {}
            nodesuccessor = self.nodes[i + 1]
            for step in stepnodes:
              if step.atom.name.startswith("DisplayNoScanner"):
                successors[0] = step
              if step.atom.name.startswith("DisplayScannerNotActive"):
                successors[1] = step
              if step.atom.name.startswith("WaitScanInitAck"):
                successors[2] = step

            t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "idcodestatus", val = c.jobResultScannerNotReady, next = nodes["' + successors.get(1).getNodeName() + '"]},')
            t.append('                                 { var = "idcodestatus", val = c.jobResultComponentHasNoScanner, next = nodes["' + successors.get(0).getNodeName() + '"]},')
            t.append('                                 { var = "idcodestatus", val = c.jobResultScannerRdy, next = nodes["' + successors.get(2).getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # DisplayNoScanner NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("DisplayNoScanner") or localnode.getAtomName().startswith("DisplayScannerNotActive"):
            t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{var = "dummy", val = nil, next = f.EndNode}}')



        #---------------------------------------------------------------------------------------------------------------
        # TriggerInGrp NODE
        #---------------------------------------------------------------------------------------------------------------
        elif localnode.getAtomName().startswith("TriggerInGrp$"):
            stepnodes = nodes_per_step.get(localnode.steprow)
            successors = {}
            for step in stepnodes:

                if step.atom.name.startswith("DisplayMsgTimeoutDelay$"):
                    successors[0] = step
                elif step.atom.name.startswith("DisplayMsgScanTimeoutDelay$"):
                    successors[1] = step
                elif step.atom.name.startswith("DisplayMsgNotActiveDelay$"):
                    successors[2] = step
                elif step.atom.name.startswith("DisplayMsgNotSupportedDelay$"):
                    successors[3] = step
                elif step.atom.name.startswith("DisplayIDCode$"):
                    successors[4] = step
                elif step.atom.name.startswith("DisplayMsgNoAssignmentDelay$"):
                    successors[5] = step

            t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{ var = "timeout", val = 1, next = nodes["' + successors.get(0).getNodeName() + '"]},')
            t.append('                                 { var = "idcodestatus", val = c.jobResultScanTimeout, next = nodes["' + successors.get(1).getNodeName() + '"]},')
            t.append('                                 { var = "idcodestatus", val = c.jobResultScannedCodeNotActive, next = nodes["' + successors.get(2).getNodeName() + '"]},')
            t.append('                                 { var = "idcodestatus", val = c.jobResultScannedCodeNotSupported, next = nodes["' + successors.get(3).getNodeName() + '"]},')
            t.append('                                 { var = "idcodestatus", val = c.jobResultNewIDCodeAssignment, next = nodes["' + successors.get(4).getNodeName() + '"]},')
            t.append('                                 { var = "idcodestatus", val = c.jobResultNoAssignmentFound, next = nodes["' + successors.get(5).getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # Global id code timeout NODE
        #---------------------------------------------------------------------------------------------------------------

        elif localnode.getAtomName().startswith("ScanTimeoutDelay"):
            successor = stepnodes[-1]
            t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # DisplayMsgAtoms NODE
        #---------------------------------------------------------------------------------------------------------------

        elif localnode.getAtomName().startswith("ScanTimeoutMsg") \
                or localnode.getAtomName().startswith("CodeNotSupportedMsg") \
                or localnode.getAtomName().startswith("CodeNotActiveMsg") \
                or localnode.getAtomName().startswith("DisplayNoAssignment"):
            if id_source == 0:
                stepnodes = nodes_per_step.get(localnode.steprow)
                for n in stepnodes:
                    if n.getAtomName().startswith("InitScanner$"):
                        successor = n
                t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')
            else:
                stepnodes = nodes_per_step.get(localnode.steprow)
                for n in stepnodes:
                    if n.getAtomName().startswith("TriggerInGrp$"):
                        successor = n
                t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')

        #---------------------------------------------------------------------------------------------------------------
        # WaitForCycleComplete NODE
        #---------------------------------------------------------------------------------------------------------------

        elif localnode.getAtomName().startswith("Wait for cycle complete$"):
            stepnodes = nodes_per_step.get(localnode.steprow)
            for step in stepnodes:
                if step.atom.name.startswith("TriggerInGrpOkNokResult$"):
                    successor = step
            t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{var = "dummy", val = nil, next = nodes["' + successor.getNodeName() + '"]}}')


        #---------------------------------------------------------------------------------------------------------------
        # TriggerInGrpOkNokResult NODE
        #---------------------------------------------------------------------------------------------------------------

        elif localnode.getAtomName().startswith("TriggerInGrpOkNokResult$"):
            stepnodes = nodes_per_step.get(localnode.steprow)
            successors = {}
            for step in stepnodes:
                if step.atom.name.startswith("DisplayMsgTimeDelay$"):
                    successors[0] = step
                if step.atom.name.startswith("Tool disable$"):
                    successors[1] = step


            t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{ var = "timeout", val = 1, next = nodes["' + successors.get(0).getNodeName() + '"]},')
            t.append('                                                {var = "dummy", val = nil, next = nodes["' + successors.get(1).getNodeName() + '"]}}')

        #---------------------------------------------------------------------------------------------------------------
        # Endnodes
        #---------------------------------------------------------------------------------------------------------------
        elif i == (len(self.nodes) - 1):
            t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{var = "dummy", val = nil, next = f.EndNode}}')

        elif i == (len(self.nodes) - 2):
            t.append('nodes["' + str(localnode.getNodeName()) + '"].successor = {{var = "dummy", val = nil, next = f.EndNode}}')

        else:
            nodesuccessor = self.nodes[i + 1]
            t.append('nodes["' + localnode.getNodeName() + '"].successor = {{var = "dummy", val = nil, next = nodes["' + nodesuccessor.getNodeName() + '"]}}')

        theText = localnode.getDisplayName()
        if isinstance(theText, unicode):
          theText = theText.encode('utf8')

        getComment = localnode.getComment()
        if isinstance(getComment, unicode):
          getComment = getComment.encode('utf8')

        t.append('nodes["' + str(localnode.getNodeName()) + '"].step = { row = ' + str(localnode.getRow()) + ', column = '
                 + str(localnode.getColumn()) + ', name = "' + str(localnode.getName()) + '", display_name = "' + theText
                 + '", io_next = ' + str(localnode.getIO()) + ', nio_next = ' + str(localnode.getNIO()) + ', comment = "' + getComment
                 + '"' + ' }\n')


class Atom:

  def __init__(self, bms=None):
    self.__index = self
    self.name = ""
    self.members = []
    self.type = bms.get('type')
    self.mode = bms.get('mode')
    if bms is not None:
      if 'c.TypeDevice' in bms.get('type'):
        self.createDeviceAtom(bms)
      elif 'c.TypeTriggerInGrp' in bms.get('type'):
        self.createTriggerInGrpAtom(bms)
      else:
        self.createActionAtom(bms, bms.get('undo'))

  def __str__(self):
    res = "Atom (name: " + str(self.name)
    res += "; type: " + str(self.type)
    res += "; mode: " + str(self.mode)
    if len(self.members) > 0:
        res += "; members: " + ", ".join(self.members)
    res += ")"
    return res

  def __repr__(self):
    return self.__str__()


  def createDeviceAtom(self, bms):
    nodes = Step()
    self.name = bms.get('constname') or ""
    if len(self.name) < 1:
      self.name = bms.get('dest') or nodes.getRowColName(" ", "")
    self.content = 'atoms["%s"]={\n' % self.name + '    type = ' + str(bms.get('type')) + ',\n'
    self.content = self.content + '    mode = ' + str(bms.get('mode')) + ',\n' + '    dest = "' + str(bms.get('dest')) + '"\n}\n'

  def createTriggerInGrpAtom(self, bms):
    nodes = Step()

    nodes_per_step = {}
    for i in range(len(nodes.nodes)):
        n = nodes.nodes[i]
        steprow = n.steprow
        if not steprow in nodes_per_step:
            nodes_per_step[steprow] = []
        nodes_per_step[steprow].append(n)

    members = bms.get('members')
    for member in members:
      self.members.extend(map(lambda a: a.atomname, [i for i in nodes_per_step[nodes.steprow] if i.atomname.startswith(member + "$")]))

    self.name = nodes.getRowColName(bms.get('constname'), False)
    self.content = 'atoms["%s"]={\n' % self.name
    self.content = self.content + '    type = ' + str(bms.get('type')) + ',\n'
    #self.content = self.content + '    attempts = ' + str(step.get('ScanAttempts')) + ',\n'
    self.content = self.content + '    members = {' + (", ".join(map(lambda a: '"' + a + '"', self.members))) + '}\n'
    self.content = self.content + '}\n'


  def createActionAtom(self, bms, undo):
    nodes = Step()
    prefix = bms.get('constname') or bms.get('comment')   #1. exchanged 1 and 2 for text on screen message
    if len(prefix) < 1:
      prefix = bms.get('text') or ""                      #2.
    self.name = nodes.getRowColName(prefix, undo)
    if undo:
      self.name = self.name + "UNDO"

    bms_dest = ""
    if bms.get('dest') == 9:
      bms_dest = "plc.In.En"
    else:
      bms_dest = str(bms.get('dest'))

    self.content = 'atoms["%s"]={\n' % self.name
    theText = bms.get('text')
    if theText:
      if isinstance(theText, unicode):
         theText = theText.encode('utf8')
    self.content = self.content + '    text ="' + str(theText or "") + '",\n'
    if bms.get('info'):
      self.content = self.content + '    info = "' + str(bms.get('info')) + '",\n'
    ##print "BMS.mode", bms.get('mode'), "type", bms.get('type')
    if bms.get('mode') == "c.TriggerInModeTimeDelay" and not bms.get('failure') and bms.get('constname') == 'DisplayIDCodeTimeDelay':
      self.content = self.content + "    action = \"atoms['" + self.name + "'].text = '{{{IDCode: [[[' .. cpp.job:getJobSeqParams('idcode') .. ']]] received'\",\n"
    if bms.get('timeout'):
      self.content = self.content + '    timeout= ' + str(bms.get('timeout')) + ',\n'
    self.content = self.content + '    type = ' + str(bms.get('type')) + ',\n'
    self.content = self.content + '    mode = ' + str(bms.get('mode')) + ',\n'
    self.content = self.content + '    dest = ' + bms_dest + ',    --    ' + str(bms.get('comment')) + '\n'
    self.content = self.content + '    range= ' + str(bms.get('range')) + ',\n'
    self.content = self.content + '    state= ' + str(bms.get('state')) + ',\n'
    if bms.get('valueList') == None:
      pass  # no valueList to printout
    elif type(bms.get('valueList')) is dict:
      stringValue =""
      for key, value in bms.get('valueList').items():
        stringValue = stringValue + '      ' + str(key) + ' = ' + str(value) + ',\n'
      self.content = self.content + '    valueList = {\n' + stringValue[:-2] + '\n    }\n'
    else:
      self.content = self.content + '    valueList = {' + bms.get('valueList') + '}\n'

    self.content += '}\n'


class Atoms:

  __metaclass__ = SingletonType

  def __init__(self):
    self.atoms = []
    self.__index = self

  def existAtom(self, atom):
    exist = False
    for i in self.atoms:
      if str(atom.name) in  i.name:
        exist = True
        break
    return exist

  def insertAtom(self, atom):
    if not self.existAtom(atom):
      self.atoms.append(atom)

  def addAtom(self, bms, id_src=0):
    nodes = Step()
    vl = bms.get('valueList')
    if vl and type(vl) == dict and vl.get('id') and vl.get('id').startswith('$idcode'):
        vl['id'] = "\"" + vl.get('id') + "@A" + str(nodes.steprow) + "\""

    atom = Atom(bms)

    if atom.name and not "0.0.0.0" in atom.name:
      undo = bms.get('undo') or False
      self.insertAtom(atom)
      suppress = bms.get('nodesuppress') or undo
      if not suppress:
        #type: c.TypeTriggerOut; mode: c.TriggerOutModeStepInit

        nodes.addNode(atom, id_src)

  def resetList(self):
    self.atoms = []

  def serialize(self, t):
    count = 0
    idstepcount = 0
    for i in self.atoms:
      if i.name.startswith('IdCodeInit$'):
        idstepcount += 1
    scanFinalSteps = 0

    for i in self.atoms:
      if i.name.startswith('ScanFinal') and (self.atoms[count + 3].name.startswith('set OkNok-counter$') or self.atoms[count + 2].name.startswith('set OkNok-counter$') or self.atoms[count + 4].name.startswith('set OkNok-counter$')):
        i.content = i.content.replace('state= 1', 'state= 0')
      elif i.name.startswith('ScanFinal') and (self.atoms[count + 3].name.startswith('IdCodeInit$')):
        scanFinalSteps += 1
        if scanFinalSteps < len(idinput_source) and scanFinalSteps < idstepcount:
          if idinput_source[scanFinalSteps] == 1:
            i.content = i.content.replace('state= 1', 'state= 0')
          elif idtrigger_list[scanFinalSteps] in [0, 4]:
            i.content = i.content.replace('state= 1', 'state= 0')

      count += 1

      t.append(i.content)



#----AddSetGroup and AddWaitGroupRedundance used for Remote Job!!!! Implementation later

'''
  def addSetGroup(self, tabAddresses):
    atomcontent = ""
    atomname = "Device Group "
    members = ''
    atom = Atom()
    for index
'''




def Get1or0(s):
  if 'true' in s: return 1
  else: return 0

def GetNOT1or0(s):
  if s and 'true' in s:
    return 0
  else:
    return 1


def AddOkNokCounter():
  global table
  #table.insert(step.get('oknokcounter'), {'socket': 1, 'program': 0, 'maxok': 0, 'maxnok': 0})


def SetOkNokSocket(entryVal):
  if entryVal != " ":
    step['oknokcounter']['socket'] = entryVal
  else:
    step['oknokcounter']['socket'] = "-1"


def SetOkNokProgram(entryVal):
  if entryVal:
    step['oknokcounter']['program'] = entryVal
  else:
    step['oknokcounter'][len(step.get('oknokcounter'))]['program'] = "0"


def SetOkNokMaxOk(entryVal):
  if entryVal:
    step['oknokcounter']['maxok'] = entryVal
  else:
    step['oknokcounter'][len(step.get('oknokcounter'))]['maxok'] = "0"


def SetOkNokMaxNok(entryVal):
  if entryVal:
    step['oknokcounter']['maxnok'] = entryVal
  else:
    step['oknokcounter'][len(step.get('oknokcounter'))]['maxnok'] = "0"



def SetOkNokCounterFOx():
  SetOkNokCounter(step.get('ApplicationBlock'))

def objToStr(obj):
  stringify = "{{"
  for key, value in obj.items():
    stringify = stringify + str(key) + '=' + str(value) + ', '
  stringify = stringify[:-2] + "}}"
  return stringify


ID_InputRE = re.compile("(.*)(ID Input)(.*)")

def SetOkNokCounter(setCounterNo):
  atoms = Atoms()

  # clear idinput_source array for correct ScanFinalOK state
  #idinput_source = []


  b = BMS.get('SetOkNokCounter')
  if setCounterNo == True:
    setNoOfCounter = 0
  else:
    setNoOfCounter = int(setCounterNo)
  b['dest'] = setNoOfCounter
  progno = 0


  #---Funktion um Counter zu generieren!
  counter = {'Nr':  str(step['oknokcounter']['program']), 'Ok': str(step['oknokcounter']['maxok']),
             'Nok': str(step['oknokcounter']['maxnok']), 'SocketTrayNr': str(step['oknokcounter']['socket'])}

  b['valueList'] = {'LockCtrl': step['blockNutrunner'], 'EnablePrg99': step['LooseProgram99'], 'BlockPrg99AfterOk': step['blockLooseningProgAfterOK'],
                    'BlockPrg99AfterNok': step['blockLooseningProgAfterNOK'], 'CountOverAllCounters': step['CompleteAllConfiuredCounters'],
                    'SocketTrayCoding': '4712', 'DecrementOkCounter': step['DecOkCounter'], 'Src': '5',
                    'Counters': objToStr(counter)}
  '''
  b['valueList'] = str(Get1or0(step['blockNutrunner'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['LooseProgram99'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['blockLooseningProgAfterOK'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['blockLooseningProgAfterNOK'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['CompleteAllConfiuredCounters'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['SetSignals'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['DecOkCounter'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0("true")) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['BlinkSignals'])) + ","
  b['valueList'] = b['valueList'] + "-1" + ","
  if 'BoxNutSelX' in step['AutoselectProg']:
    b['valueList'] = b['valueList'] + "1,"
  else:
    b['valueList'] = b['valueList'] + "0,"

  #for i in step['oknokcounter']:
     #if i <= int(step['CountOfSockets']):
    #   progno = v['program']
    #   b['valueList'] = b['valueList'] + str(v['program']) + ","
    #   b['valueList'] = b['valueList'] + str(v['maxok']) + ","
    #   b['valueList'] = b['valueList'] + str(v['maxnok']) + ","
    #   b['valueList'] = b['valueList'] + str(v['socket']) + ","

  progno = step['oknokcounter']['program']
  b['valueList'] = b['valueList'] + str(step['oknokcounter']['program']) + ","
  b['valueList'] = b['valueList'] + str(step['oknokcounter']['maxok']) + ","
  b['valueList'] = b['valueList'] + str(step['oknokcounter']['maxnok']) + ","
  b['valueList'] = b['valueList'] + str(step['oknokcounter']['socket']) + ""
  '''

  b['undo'] = False
  atoms.addAtom(b)


  b = BMS.get('SetIdCode')
  valuelist = ""
  for i in range(0, 12):
    access = "IDpart" + str(i)
    if step.get(access) == "$Mode":
      step[access] = "\"$Mode\""  # '0'
    #elif "scanresults" in step.get(access):
    #  step[access] = str(step.get(access)[12])
    elif len(step[access]) == 0:
      step[access] = "\"\""
    else:
      res = ID_InputRE.match(step[access])
      if res:
          step[access] = res.groups()[0] + "idcode" + res.groups()[2]
      step[access] = "\"" + step[access] + "\""
    valuelist += step.get(access) + ", "
  valuelist = valuelist[:-2]
  b['valueList'] = valuelist

  if step.get('mixIDCode') == 'true':
    atoms.addAtom(b)


  if setNoOfCounter < 1:
    ToolEnable("true")
  else:
    _FODisable(setNoOfCounter, "false")

  if step.get('ClockWise') and 'true' in step.get('ClockWise'):
    if setNoOfCounter < 1:
      ClockWise("true")
    else:
      _FO_Cw(setNoOfCounter, "true")

  if len(step.get('text').strip()) > 0:
    b = BMS.get("WaitForIncycle")
    b['text'] = step.get('text')
    atoms.addAtom(b)
    #b = BMS.get("DisplayPrgStepText")
    #b['dest'] = str(float(StartStep.get('displayTime')) * 1000) or 1000
    #atoms.addAtom(b)
    #b = BMS.get("DisplayPrgStepTextTimeDelay")
    #b['text'] = step.get('text')
    #atoms.addAtom(b)

  _WaitForCycleComplete(setNoOfCounter, step.get('text'))

  b = BMS.get('OkNokResultTimeout')
  b['timeout'] = step.get('PrgTimeout')
  atoms.addAtom(b)

  _WaitForOkNokResult(setNoOfCounter, "")

  b = BMS.get('TriggerInGrpOkNokResult')
  atoms.addAtom(b)

  b = BMS.get('DisplayMsgTimeDelay')
  b['dest'] = str(int(float(StartStep.get('displayTime')) * 1000))
  atoms.addAtom(b)

  b = BMS.get('DisplayPrgStepTimeDelay')
  b['text'] = step.get('PrgErrMsg')
  atoms.addAtom(b)


  if step.get('ClockWise') and 'true' in step.get('ClockWise'):
    if setNoOfCounter < 1:
      ClockWiseDisable()
    else:
      _FO_Cw(setNoOfCounter, "false")

  if setNoOfCounter < 1: ToolDisable()
  else: _FODisable(setNoOfCounter, "true")

  if step.get('waitForBoxNutSel') and 'true' in step.get('waitForBoxNutSel'):
    b = BMS.get('BMS_SE_E_SOCK_CHAM_SELECTEDz')
    atoms.addAtom(b)

  ResetOkNokCounter()
  ResetOkNokCounter(True)


def SetFOxOkNokCounter(FOxOkNokCounter, application):
  atoms = Atoms()
  b = BMS.get('SetOkNokCounter')
  setNoOfCounter = int(FOxOkNokCounter) or 1
  b['dest'] = FOxOkNokCounter
  progno = 0
  '''
  b['valueList'] = str(Get1or0(step['blockNutrunner'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['LooseProgram99'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['blockLooseningProgAfterOK'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['blockLooseningProgAfterNOK'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['CompleteAllConfiuredCounters'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['SetSignals'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['DecOkCounter'])) + ","
  b['valueList'] = b['valueList'] + str(Get1or0("true")) + ","
  b['valueList'] = b['valueList'] + str(Get1or0(step['BlinkSignals'])) + ","
  b['valueList'] = b['valueList'] + "-1" + ","
  b['valueList'] = b['valueList'] + "1,"
  b['valueList'] = b['valueList'] + str(application) + ","
  b['valueList'] = b['valueList'] + str(step['maxok']) + ","
  b['valueList'] = b['valueList'] + str(step['maxnok']) + ","
  b['valueList'] = b['valueList'] + str(-1)
  b['undo'] = False
  '''

  counter = {'Nr':  str(step['oknokcounter']['program']), 'Ok': str(step['oknokcounter']['maxok']),
             'Nok': str(step['oknokcounter']['maxnok']), 'SocketTrayNr': str(step['oknokcounter']['socket'])}

  b['valueList'] = {'LockCtrl': step['blockNutrunner'], 'EnablePrg99': step['LooseProgram99'], 'BlockPrg99AfterOk': step['blockLooseningProgAfterOK'],
                    'BlockPrg99AfterNok': step['blockLooseningProgAfterNOK'], 'CountOverAllCounters': step['CompleteAllConfiuredCounters'],
                    'SocketTrayCoding': '4712', 'DecrementOkCounter': step['DecOkCounter'], 'Src': '5',
                    'Counters': objToStr(counter)}

  atoms.addAtom(b)
  b = BMS.get('SetOkNokCounterUndo')
  b['dest'] = FOxOkNokCounter


  counter = {'Nr': str(setNoOfCounter), 'Ok': '0', 'Nok': '0', 'SocketTrayNr': '-1'}
  b['valueList'] = {'LockCtrl': 'false', 'EnablePrg99': 'false', 'BlockPrg99AfterOk': 'false',
                    'BlockPrg99AfterNok': 'false', 'CountOverAllCounters': 'false',
                    'SocketTrayCoding': '4712', 'DecrementOkCounter': 'false', 'Src': '5',
                    'Counters': objToStr(counter)}


  #b['valueList'] = "0,0,0,0,0,0,0,1,0,-1,0"


  atoms.addAtom(b)



def ResetOkNokCounter(undo=False):
  atoms = Atoms()
  b = BMS.get('DelOkNokCounter')
  b['undo'] = undo
  prgNr = -1
  if step.get('oknokcounter') != None and step.get('oknokcounter').get('program') != None:
    prgNr = step.get('oknokcounter').get('program')
  counter = {'Nr': str(prgNr), 'Ok': '0', 'Nok': '0', 'SocketTrayNr': '-1'}
  b['valueList'] = {'LockCtrl': 'false', 'EnablePrg99': 'false', 'BlockPrg99AfterOk': 'false',
                    'BlockPrg99AfterNok': 'false', 'CountOverAllCounters': 'false',
                    'SocketTrayCoding': '4712', 'DecrementOkCounter': 'false', 'Src': '5',
                    'Counters': objToStr(counter)}

  #b['valueList'] = "0,0,0,0,0,0,0,1,0,-1,0"


  atoms.addAtom(b)

# No usages found:
#def ResetAllOkNokCounter():
#  atoms = Atoms()
#  b = BMS.get('DelOkNokCounter')
#  b['undo'] = False

#  counter = {'Nr': '0', 'Ok': '0', 'Nok': '0', 'SocketTrayNr': '-1'}
#  b['valueList'] = {'LockCtrl': 'false', 'EnablePrg99': 'false', 'BlockPrg99AfterOk': 'false',
#                    'BlockPrg99AfterNok': 'false', 'CountOverAllCounters': 'false',
#                    'SocketTrayCoding': '4712', 'DecrementOkCounter': 'false', 'Src': '5',
#                    'Counters': objToStr(counter)}

  #b['valueList'] = "0,0,0,0,0,0,0,1,0,-1,0"


#  for i in range(8):
#    b['text'] = b['comment'] + i+1
#    b['dest'] = i+1
#    atoms.addAtom(b)

def SetWaitStep():
  atoms = Atoms()
  ToolDisable()
  b = BMS.get('SetTimeDelay')
  b['dest'] = step['timeout']
  atoms.addAtom(b)
  b = BMS.get('WaitTimeDelay')
  b['text'] = step['text']
  atoms.addAtom(b)


def SetWaitStepFO():
  atoms = Atoms()
  for i, v in step['signals'].items():
    if 'true' in v:
      _FODisable (i, "true")
  b = BMS.get('SetTimeDelay')
  b['dest'] = step['timeout']
  atoms.addAtom(b)
  b = BMS.get('WaitTimeDelay')
  b['text'] = step['text']
  atoms.addAtom(b)

def SetScanStep():
  try:
    atoms = Atoms()
    steps = Step()

    scancodes = "{"
    for i in step['ScanCodes']:
      i = i.replace(" ","")
      if 'Code' in i:
        scancodes = scancodes + 'codes.Code' + i[4:] + ','
      elif i == 'UCC/EAN-128':
        scancodes += 'codes.UccEan128,'
      else:
        if i == 'MSI':
          i = 'Msi'
        scancodes = scancodes + 'codes.' + i + ','
    if len(scancodes) > 1:
      scancodes = scancodes[:-1] + '}'
    else:
       scancodes = scancodes + '}'

    if len(step['ScanMasking']) > 0:
      idarray = step['ScanMasking'].split(';')
      idarray2 = map(lambda val: val.split('-'), idarray)
      for id in idarray2:
        if len(id) == 1:
          id[0] = int(id[0])
          id[0] -= 1
          id.append(int(id[0]))
        else:
          id[0] = int(id[0])
          id[1] = int(id[1])
          id[0] -= 1
          id[1] -= 1
          if id[0] > id[1]:
            tmp = id[0]
            id[0] = id[1]
            id[1] = tmp
    else:
      idarray2 = [[0, 255]]

    idarray = map(lambda a: "\"" + a + "\"", map(lambda a: "-".join(map(lambda a: str(a), a)), idarray2))
    from functools import reduce
    res = reduce(lambda a, b: a + ", " + b, idarray)
    range = "{" + res + "}"

    id_src = 'idsrc.scanner'
    idSrc = 0

    if step.get('IDSource').isdigit():
      if int(step.get('IDSource')) == 0:
        id_src = 'idsrc.scanner'
        idSrc = 0
      elif int(step.get('IDSource')) == 1:
        id_src = 'idsrc.openprotocol'
        idSrc = 1
      else:
        id_src = 'idsrc.vwxml'
        idSrc = 5
    else:
      if step.get('IDSource') == 'Scanner':
        id_src = 'idsrc.scanner'
        idSrc = 0
      elif step.get('IDSource') == 'Open Protocol':
        id_src = 'idsrc.openprotocol'
        idSrc = 1
      elif step.get('IDSource') == 'VW XML':
        id_src = 'idsrc.vwxml'
        idSrc = 5

    idinput_source.append(idSrc)
    idtrigger_list.append(int(float(step['ScanTrigger'])))

   # idSrc = "{" + id_src + "}"

    b = BMS.get('IdCodeInit')
    b['valueList'] = {
        'id': '$idcode' + step['scanID'][-1:] + '',
        'fire_idcode': 0,
        'src': id_src,
        'target':  int(float(step['ScanTarget'])),
        'range': range
    }
    atoms.addAtom(b, idSrc)

    playSound = 0
    if step.get('PlayScanSound') == 'true':
      playSound = 1
    else:
      playSound = 0

    b = BMS.get('InitScanner')
    b['state'] = step['scanID'][-1:]
    b['valueList'] = {
        'id': '$idcode' + b['state'] + '',
        #'target': step['ScanTarget'] or 1,
        'trigger': int(float(step['ScanTrigger'])),
        'laserontime': (float(step.get('ScanLaserOnTime'))),
        'play_sound': playSound,
        'codes': scancodes
        #'range': range
    }
    atoms.addAtom(b)
    b = BMS.get('DisplayNoScanner')
    atoms.addAtom(b)

    b = BMS.get('DisplayScannerNotActive')
    atoms.addAtom(b)

    b = BMS.get('WaitScanInitAck')
    atoms.addAtom(b)

    b = BMS.get('WaitScanStartTrigger')

    if idSrc == 0:
        b['text'] = step.get('displayText')
    else:
        b['text'] = ""

    atoms.addAtom(b)


    b = BMS.get('DoScan')
    atoms.addAtom(b)


    b = BMS.get('WaitIdCodeTimeout')

    if idSrc == 1 or idSrc == 5:
        b['text'] = step.get('displayText')
    else:
        b['text'] = ""

    b['timeout'] = int(float(step.get('ScanTimeout')))
    atoms.addAtom(b)


    b = BMS.get('WaitIdCode')
    atoms.addAtom(b)

    b = BMS.get('TriggerInGrp')
    atoms.addAtom(b)

    b = BMS.get('DisplayIDCode')
    b['dest'] = str(int(float(StartStep.get('displayTime')) * 1000))

    atoms.addAtom(b)
    b = BMS.get('DisplayIDCodeTimeDelay')
    atoms.addAtom(b)

    b = BMS.get('DisplayMsgTimeoutDelay')
    b['dest'] = str(int(float(StartStep.get('displayTime')) * 1000))
    atoms.addAtom(b)

    b = BMS.get('ScanTimeoutDelay')
    b['text'] = step.get('ScanErrMsg') or ""
    atoms.addAtom(b)

    b = BMS.get('DisplayMsgScanTimeoutDelay')
    b['dest'] = str(int(float(StartStep.get('displayTime')) * 1000))
    atoms.addAtom(b)

    b = BMS.get('ScanTimeoutMsg')
    atoms.addAtom(b)

    b = BMS.get('DisplayMsgNotSupportedDelay')
    b['dest'] = str(int(float(StartStep.get('displayTime')) * 1000))
    atoms.addAtom(b)

    b = BMS.get('CodeNotSupportedMsg')
    atoms.addAtom(b)

    b = BMS.get('DisplayMsgNotActiveDelay')
    b['dest'] = str(int(float(StartStep.get('displayTime')) * 1000))
    atoms.addAtom(b)

    b = BMS.get('CodeNotActiveMsg')
    atoms.addAtom(b)

    b = BMS.get('DisplayMsgNoAssignmentDelay')
    b['dest'] = str(int(float(StartStep.get('displayTime')) * 1000))
    atoms.addAtom(b)

    b = BMS.get('DisplayNoAssignment')
    atoms.addAtom(b)

    b = BMS.get('ScanFinalOK')
    atoms.addAtom(b)



    #b = BMS.get('ScanFinalTimeout')
    #atoms.addAtom(b)
    #b = BMS.get('ScanFinalNOK')
    #atoms.addAtom(b)


  except:
    import sys
    print "ERROR", sys.exc_info()
    import traceback
    print traceback.print_tb(sys.exc_info()[2])




  """ Use for Scanning Prg No


  if '1' in str(step['ScanTarget']) or '3' in str(step['ScanTarget']):

    setNoOfCounter = 0
    b = BMS.get('SetOkNokCounter')

    b['dest'] = setNoOfCounter
    progno = 0

    #---Funktion um Counter zu generieren!
    counter = {'Nr': 'tonumber(cpp.job:getJobSeqParams("prgnr"))', 'Ok': '3', 'Nok': '1', 'SocketTrayNr': '-1'}

    b['valueList'] = {'LockCtrl': 'true', 'EnablePrg99': 'true', 'BlockPrg99AfterOk': 'false',
                      'BlockPrg99AfterNok': 'false', 'CountOverAllCounters': 'false',
                      'SocketTrayCoding': '4712', 'DecrementOkCounter': 'false', 'Src': '1',
                      'Counters': objToStr(counter)}

    b['undo'] = False
    atoms.addAtom(b)

    b = BMS.get('SetOkNokCounterUndo')
    b['dest'] = setNoOfCounter
    b['undo'] = True

    counter = {'Nr': '1', 'Ok': '0', 'Nok': '0', 'SocketTrayNr': '-1'}
    b['valueList'] = {'LockCtrl': 'false', 'EnablePrg99': 'false', 'BlockPrg99AfterOk': 'false',
                      'BlockPrg99AfterNok': 'false', 'CountOverAllCounters': 'false',
                      'SocketTrayCoding': '4712', 'DecrementOkCounter': 'false', 'Src': '1',
                      'Counters': objToStr(counter)}

    atoms.addAtom(b)

    if setNoOfCounter < 1:
      ToolEnable("true")
    else:
      _FODisable(setNoOfCounter, "false")


    if step.get('ClockWise') and 'true' in step.get('ClockWise'):
      if setNoOfCounter < 1:
        ClockWise("true")
      else:
        _FO_Cw(setNoOfCounter, "true")

    if step.get('ClockWise') and 'true' in step.get('ClockWise'):
      if setNoOfCounter < 1:
        ClockWiseDisable()
      else:
        _FO_Cw(setNoOfCounter, "false")

    if step.get('waitForBoxNutSel') and 'true' in step.get('waitForBoxNutSel'):
      b = BMS.get('BMS_SE_E_SOCK_CHAM_SELECTEDz')
      atoms.addAtom(b)

  """




def _WaitForCycleComplete(oknokCounterNo, dispText):
  atoms = Atoms()
  b = BMS.get('bms_cycmp')
  if oknokCounterNo < 1:
    pass
  else:
    b['dest'] = BMS.get('BMS_A_FOxCYCMP') + BMS.get('BMS_FOxSIZE') * oknokCounterNo
  b['text'] = ""  #dispText

  atoms.addAtom(b)

def _WaitForOkNokResult(oknokCounterNo, dispText):
  atoms = Atoms()
  b = BMS.get('OkNokResult')
  b['constname'] = 'Text on screen'
  b['dest'] = str(oknokCounterNo)
  b['text'] = dispText
  atoms.addAtom(b)


def _WaitForTighteningResult(oknokCounterNo, dispText):
  atoms = Atoms()
  b = BMS.get('TighteningResult')
  b['dest'] = str(oknokCounterNo)
  b['text'] = dispText
  atoms.addAtom(b)

def _FODisable(FOBlock, disable):
  atoms = Atoms()
  FOBlock = int(FOBlock) or 1
  disable = disable or "true"
  b = BMS.get('BMS_KE_E_FOxDISABLE')
  comment = b['comment']
  b['comment'] = b['comment'] + str(FOBlock)
  b['dest'] = BMS.get('BMS_FOBLOCKz') + (BMS.get('BMS_FOxSIZE') * (FOBlock - 1)) + BMS.get('BMS_E_FOxDISABLE')
  b['state'] = Get1or0(disable)
  b['undo'] = False
  atoms.addAtom(b)
  if b['state'] < 1:
    b['state'] = GetNOT1or0(disable)
    b['undo'] = True
    atoms.addAtom(b)
  b['comment'] = comment

def _FO_Cw(FOBlock, setCw):
  atoms = Atoms()
  d = BMS.get('SetTimeDelay')
  d['dest'] = 80
  atoms.addAtom(d)
# Wait for time delay
  d = BMS.get('WaitTimeDelay')
  d['text'] = step['text']
  atoms.addAtom(d)

  FOBlock = int(FOBlock) or 1
  setCw = setCw or "true"
  b = BMS.get('BMS_KE_E_FOxCw')
  comment = b['comment']
  b['comment'] = b['comment'] + FOBlock
  b['dest'] = BMS.get('BMS_FOBLOCKz') + (BMS.get('BMS_FOxSIZE') * (FOBlock - 1)) + BMS.get('BMS_E_FOxCW')
  b['state'] = Get1or0(setCw)
  b['undo'] = False
  atoms.addAtom(b)
  if b['state'] > 0:
    b['state'] = GetNOT1or0(setCw)
    b['undo'] = True
    atoms.addAtom(b)
  b['comment'] = comment


def ToolEnable(enable):
  atoms = Atoms()
  b = BMS.get('BMS_SE_E_EN')
  b['state'] = Get1or0(enable)
  b['undo'] = False
  atoms.addAtom(b)
  if b['state'] > 0:
    b['state'] = GetNOT1or0(enable)
    b['undo'] = True
    atoms.addAtom(b)

def ToolDisable():
  atoms = Atoms()
  b = BMS.get('BMS_SE_E_EN_Dis')
  b['state'] = Get1or0("false")
  b['undo'] = False
  atoms.addAtom(b)

#SetILBridge()   will be implemented later

def ClockWise(enable):
  atoms = Atoms()
  b = BMS.get('BMS_SE_E_CW')
  b['state'] = Get1or0(enable)
  b['undo'] = False
  atoms.addAtom(b)
  if b['state'] > 0:
    b['state'] = GetNOT1or0(enable)
    b['undo'] = True
    atoms.addAtom(b)

def ClockWiseDisable():
  atoms = Atoms()
  b = BMS.get('BMS_SE_E_CW_Dis')
  b['state'] = Get1or0("false")
  b['undo'] = False
  atoms.addAtom(b)


def ClearJobAppOut():
  if step['ClearJobAppOut'] and 'true' in step['ClearJobAppOut']:
    entryVal = "low"
    for i in range(32):
      AddSignalState(i, entryVal)
    SetTriggerOut()


def SetTriggerOut():
  atoms = Atoms()
  b = BMS.get('SetAppOutSignals')
  mask = 0
  states = 0
  for i, v in step['signals'].items():
    i += 1
    if 'low' in v:
      if i < 32:
        mask = mask + 2 **(i - 1)
      else:
        mask = mask - 2 ** (i - 1)
    elif('high' in v):
      if i < 32:
        mask = mask + 2 ** (i - 1)
        states = states + 2 ** (i - 1)
      else:
        mask = mask - 2 ** (i - 1)
        states = states - 2 ** (i - 1)
  b['dest'] = mask
  b['state'] = states
  atoms.addAtom(b)

def SetTriggerIn():
  atoms = Atoms()
  b = BMS.get('SetAppInSignals')
  b['text'] = step['text']
  mask = 0
  states = 0
  for i,v in step['signals'].items():
    i += 1
    if 'low' in v:
      if i < 32:
        mask = mask + 2 ** (i - 1)
      else:
        mask = mask - 2 ** (i - 1)
    elif 'high' in v:
      if i < 32:
        mask = mask + 2 ** (i - 1)
        states = states + 2 ** (i - 1)
      else:
        mask = mask - 2 ** (i - 1)
        states = states - 2 ** (i - 1)
  b['dest'] = mask
  b['state'] = states
  atoms.addAtom(b)


def serializeArray(t):
  content = '\n'.join(map(str, t))
  return content.decode('utf8')

def AddSignalState(i,entryVal):
  step['signals'][i] = entryVal


def _performActions(step):
  if step['actions']:
    for k, actions in step['actions'].items():
      if actions:
        exec actions in None, None


def BeginStep(stepname):
  step['name'] = stepname or ""
  step['displayName'] = ""
  step['actions'] = {}
  step['oknokcounter'] = {}
  step['signals'] = {}
  step['ScanCodes'] = []
  step['ScanMasking'] = []
  step['remotejobs'] = {}
  step['comment'] = ""
  step['FOxOkNokCounters'] = {}
  step['displayText'] = ""
  step['ScanErrMsg'] = ""
  step['ScanTimeout'] = 3
  step['ScanTarget'] = 0
  step['ScanAttempts'] = 3


def FinalizeStep():
    nodes = Step()
    atoms = Atoms()
    nodes.nextStep(step.get('name'))
    nodes.setDisplayName(step.get('displayName'))
    atoms.addAtom(BMS.get('TriggerOutModeStepInit'))
    _performActions(step)
    atoms.addAtom(BMS.get('TriggerOutModeStepFinal'))

    if step.get('name') == 'End':
     atoms.addAtom(BMS.get('DoNokResult'))


def AddText(text):
    step['text'] = text


def AddProperty(t, key, value):
    if key and value:
        if len(value) > 0:
            t[str(key)] = str(value)

# Remote Job Functions missing


def SetApplication(FOxOkNokCounter ,entry):
    if entry.value and int(entry.value):
        global table
        #table.insert(step['FOxOkNokCounters'], {FOxOkNokCounter,  entry.value})


def SetFOxOkNokCounters():
    for i, v in step['FOxOkNokCounters'].items():
        SetFOxOkNokCounter(v['FOx'], v['application'])
    for i, v in step['FOxOkNokCounters'].items():
        _FODisable(v['FOx'], "false")
    for i, v in step['FOxOkNokCounters'].items():
        _WaitForCycleComplete(v['FOx'], step['text'])
        _WaitForOkNokResult(v['FOx'], step['text'])
    for i, v in step['FOxOkNokCounters'].items():
        _FODisable(v['FOx'], "true")


def testWriteJob(dataJson, path, jobuser, session):
  global StartStep
  global step
  global idinput_source
  global idtrigger_list
  idinput_source = []
  idtrigger_list= []

  JOBPATH = path
  nodes = Step()
  atoms = Atoms()

  data = dataJson
  #from pprint import pprint
  #pprint(data)
  if not isinstance(data, list):
    data = [data]

  my_response = {}
  date = int(time.time())

  for job in data:
    filename = os.path.join(JOBPATH, 'job%03d.lua' % (job['Slot']))
    filename_atom = os.path.join(JOBPATH, 'atoms%03d.lua' % (job['Slot']))
    jobFileExists = os.access(filename, os.R_OK)
    atomFileExists = os.access(filename_atom, os.R_OK)
    my_response[job['id']] = date


    if job['Name'] == 'n.a':
      if jobFileExists:
        os.remove(filename)
        syslog.syslog(syslog.LOG_INFO, "Job with filename: " + filename + " removed.")
        notify_activity.configChanged(filename, Activity.JOB_REMOVED, [job['Slot']], session=session)
      if atomFileExists:
        os.remove(filename_atom)
        syslog.syslog(syslog.LOG_INFO, "Atom with filename: " + filename_atom + " removed.")
        notify_activity.configChanged(filename_atom, Activity.JOB_REMOVED, [job['Slot']], session=session)
      continue

    crnl = re.compile("\n|\r")


    def writeJob():
        #with open(filename, 'wb') as f:

        global s
        global g
        LuaJob    = []

        #f = file(filename, 'w')
        try:
          for steps in job['steps']:
            StartStep['Jobname'] = job['Name']
            step['IO_Next'] = steps['IO_Next']
            step['NIO_Next'] = steps['NIO_Next']
            if steps['execPy'] is not None:
              if len(steps['execPy'].split(';')) > 1:
                for cmd in steps['execPy'].split(';'):
                  exec cmd in None, None
              else:
                exec steps.get('execPy') in None, None
            for group in steps['children']:

              if group.get('execPy') is not None:
                  if len(group.get('execPy').split(';')) > 1:
                    for cmd in group.get('execPy').split(';'):
                      exec cmd in None, None
                  else:
                    exec group.get('execPy') in None, None

              for firstLevel in group.get('children'):
                if firstLevel.get('execPy') is not None:
                  if len(firstLevel.get('execPy').split(';')) > 1:
                    for cmd in firstLevel.get('execPy').split(';'):
                      exec cmd in None, None
                  else:
                    exec firstLevel.get('execPy') in None, None
                if firstLevel.get('children') is not None:
                  for secondLevel in firstLevel.get('children'):
                    if secondLevel.get('execPy') is not None:
                      if len(secondLevel.get('execPy').split(';')) > 1:
                        for cmd in secondLevel.get('execPy').split(';'):
                          exec cmd in None, None
                      else:
                        exec secondLevel.get('execPy') in None, None
                    if secondLevel.get('children') is not None:
                      for thirdLevel in secondLevel.get('children'):
                        if thirdLevel.get('execPy') is not None:
                          if len(thirdLevel.get('execPy').split(';')) > 1:
                            for cmd in thirdLevel.get('execPy').split(';'):
                              exec cmd in None, None
                          else:
                            exec thirdLevel.get('execPy') in None, None
        except:
            syslog.syslog(syslog.LOG_ERR, traceback.format_exc())
            # traceback.print_exc()


        strUnload = '--package.loaded[\"atoms%03d\"]=nil' % job['Slot']


        jobName = StartStep.get('Jobname')
        jobComment = job.get('Comment')

        if isinstance(jobName, unicode):
         jobName = jobName.encode('utf8')
        if isinstance(jobComment, unicode):
         jobComment = jobComment.encode('utf8')


        LuaJob.append('-- BS350 - JobCreation V02: Header --')
        LuaJob.append('--  jobName = {0} '.format(jobName))
        LuaJob.append(' ')
        LuaJob.append('c = require "constants"')
        LuaJob.append('f = require "runFunctions"')
        LuaJob.append('codes = require "scancodes"')
        LuaJob.append('--a = require \"atoms%03d\"' % job['Slot'])
        LuaJob.append('plc = require "plcsignals"')
        LuaJob.append('idsrc = require "idcodesources"')
        #LuaAtoms.append('module(..., package.seeall)')
        LuaJob.append('atoms = {}')
        LuaJob.append(' ')

        atoms.serialize(LuaJob)

        LuaJob.append('mode = mode or "job"')
        LuaJob.append('mid= mid or 0')
        LuaJob.append('if( mode == "job" ) then')
        LuaJob.append('	f.publishAtoms(atoms,function (a) cpp.job:addAtom(a) end)')
        LuaJob.append('else')
        LuaJob.append('	f.publishAtoms(atoms,function (a) print(a) end)')
        LuaJob.append('end')
        LuaJob.append(' ')
        LuaJob.append('---------- Job Step Start -------------------------')
        LuaJob.append('local initNode = {')
        LuaJob.append('    name = \"initNode\",')
        LuaJob.append('    type = c.TypeStartNode,')
        LuaJob.append('    timeout = %s,' % StartStep.get('timeout'))
        LuaJob.append('    selectsCw = %d,' % StartStep.get('selectsCw'))
        LuaJob.append('    selectsEn = %d,' % StartStep.get('selectsEn'))
        LuaJob.append('    displayJobSteps = %d,' % StartStep.get('displayJobSteps'))
        LuaJob.append('    displayTime = {0:.1f},'.format(float(StartStep.get('displayTime'))))
        LuaJob.append('    clearIDCode = %d,' % StartStep.get('ClearIDCode'))
        LuaJob.append('    jobName = \'%s\',' % jobName)
        LuaJob.append('    jobComment = \'%s\',' % jobComment)
        LuaJob.append('    jobUser = \'%s\',' % jobuser)
        LuaJob.append('    jobDate = %d,' % date)
        LuaJob.append('}')
        LuaJob.append('f.setInitNode(initNode)')
        LuaJob.append(' ')
        LuaJob.append('local config = {')
        LuaJob.append('    stopOnNok = %s,' % (StartStep.get('stopOnNok') or "false"))
        LuaJob.append('    stopOnTimeout = %s' % StartStep.get('stopOnTimeout'))
        LuaJob.append('}')
        LuaJob.append('f.setConfiguration(config)')
        LuaJob.append(' ')

        #------Serialize nodes start
        nodes.serialize(LuaJob)

        LuaJob.append(' ')
        LuaJob.append(' ')
        LuaJob.append('-- BS350 - JobCreation V02: Tail --')
        LuaJob.append('f.checkPlausib(nodes)')
        LuaJob.append('if( mode == "job" ) then')
        LuaJob.append('	f.go(nodes["' + nodes.getFirstNodeName() + '"])')
        LuaJob.append('else')
        LuaJob.append('	-- mode: op')
        LuaJob.append('	-- mid: xxx')
        LuaJob.append('	x=f.goOP(nodes["' + nodes.getFirstNodeName() + '"], mid, 0)')
        LuaJob.append('	--print(x)')
        LuaJob.append('	return x')
        LuaJob.append('end')
        LuaJob.append('f.cleanUpNodes(atoms, nodes)')
        LuaJob.append(strUnload)
        LuaJob.append(' ')
        _serialJob = serializeArray(LuaJob)
        _serialJob = _serialJob.encode('utf8')
        fsio.write(data=_serialJob, filename=filename)
        nodes.resetList()
        atoms.resetList()

    writeJob()

    if jobFileExists:
        createdOrChanged = Activity.JOB_CHANGED
    else:
        createdOrChanged = Activity.JOB_CREATED

    notify_activity.configChanged(filename, createdOrChanged, [job['Slot']], session=session)
    #notify_activity.configChanged(filename_atom, createdOrChanged, [job['Slot']], session=session)
    return my_response

