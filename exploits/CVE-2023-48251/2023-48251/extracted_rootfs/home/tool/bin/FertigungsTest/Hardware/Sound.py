# -*- coding: cp1252 -*-
'''
Created on 20.10.2011

@author: sth2mt
'''
import subprocess
import os
import sys
import time



class Treiber(object):
    '''
    classdocs
    '''
    # Achtung dies ist Pseudo Singleton -> variablen werden statisch verwendet. Aufgeraumt wird erst wenn alle instanzen weg sindwird nur einmal instaniiert !!!!
    ObjCount = 0
    _Thread_name = "Sound"
    stout = False
    Init = None
    output = None
    Laut = 18
    Leise = 5
    if stout==True:
        valueVolume=Leise
    else:
        valueVolume=Laut

    def __init__(self):
        '''
        Constructor
        '''
        Treiber.ObjCount += 1

        self.printf("%i.Construktor %s Anzahl" % (Treiber.ObjCount,Treiber._Thread_name))
        if Treiber.output == None:
            self.printf("Sound.open Log File")
            Treiber.output = open ("Lautsprecher.log","w")
        if Treiber.Init == None:
            self.Open()


        
    def __del__(self):
        #print "~WLAN_CL\n"
        '''
        Destructor
        '''
        self.printf("%i Destruktor %s" % (Treiber.ObjCount,Treiber._Thread_name))
            
        if Treiber.ObjCount == 1:
            self.printf("Reste aufraumen")
            if Treiber.output:
                Treiber.output.close()
            Treiber.output = None

            Treiber.Init = None

        if Treiber.ObjCount > 0:
            Treiber.ObjCount -= 1
            
        pass
    
    def Open(self):
        self.printf("Sound.Open()")
        if subprocess.call(["amixer","set","'HandsfreeL Mux'","AudioL2"],stderr=Treiber.output,stdout=Treiber.output,shell=False)!=0:
            self.printf("Sound.Open() Error Amixer set 'HandsfreeL Mux' AudioL2")
            return False
        if subprocess.call(["amixer","set","'HandsfreeL'","on"],stderr=Treiber.output,stdout=Treiber.output,shell=False)!=0:
            self.printf("Sound.Open() Error Amixer set 'HandsfreeL' on")
            return False
        if subprocess.call(["amixer","set","'DAC2 Analog'","on"],stderr=Treiber.output,stdout=Treiber.output,shell=False)!=0:
            self.printf("Sound.Open() Error Amixer set 'DAC2 Analog' on")
            Treiber.output.flush()
            return False
        if subprocess.call(["amixer","set","'DAC2 Analog'","%i"%Treiber.valueVolume],stderr=Treiber.output,stdout=Treiber.output,shell=False)!=0:
            self.printf("Sound.Open() Error Amixer set 'DAC2 Analog' %i"%Treiber.valueVolume)
            Treiber.output.flush()
            return False
        if subprocess.call(["amixer","set","'DAC2 Digital Coarse'","2"],stderr=Treiber.output,stdout=Treiber.output,shell=False)!=0:
            self.printf("Sound.Open() Error Amixer set 'DAC2 Digital Coarse' 2")
            Treiber.output.flush()
            return False
        if subprocess.call(["amixer","set","'DAC2 Digital Fine'","63"],stderr=Treiber.output,stdout=Treiber.output,shell=False)!=0:
            self.printf("Sound.Open() Error Amixer set 'DAC2 Digital Fine' 63")
            Treiber.output.flush()
            return False
        
        Treiber.output.flush()
        Treiber.Init = True
        

        pass

    def setVolume(self,iProzent):
        try:
            ireturn = True
            self.printf("Sound.setVolume()")
        
            if (iProzent < 0)|(iProzent>100):
                self.printf("Sound.setVolume(%i) < 0 oder > 100%% "%iProzent)
                Treiber.output.flush()
                return False
            Volume = (iProzent * 69) /100
            if subprocess.call(["amixer","set","'DAC2 Digital Fine'","%03i"%Volume],stderr=Treiber.output,stdout=Treiber.output,shell=False)!=0:
                self.printf("Sound.Open() Error Amixer set 'DAC2 Analog' on")
                ireturn =  False
        
        except Exception,e:
            self.printf("Sound.setVolume(%i) Error %s"%(iProzent, e))
            ireturn =  False
        
        
        Treiber.output.flush()
        return ireturn
        
        
    
    def playSound(self,sPathFilename):
        try:
            self.printf("Sound.playSound()")
            ireturn = True
            #os.system("aplay -q %s"%sPathFilename)
            #sys.stdin.flush()
            #sys.stdout.flush()
            #sys.stderr.flush()
            if subprocess.check_call(["aplay","-q","%s" % sPathFilename],stderr=Treiber.output,stdout=Treiber.output,shell=False)!=0:
            #if subprocess.check_call(["aplay","-q","%s" % sPathFilename],stdin=None,stdout=None,stderr=None,shell=False)!=0:
                self.printf("Sound.Open() Error aplay %s"%sPathFilename)
                ireturn = False
            #p=subprocess.Popen(["aplay","-q","%s" % sPathFilename],stderr=Treiber.output,stdout=Treiber.output,stdin=subprocess.PIPE,shell=False)
            #if p._child_created==False:
                #sys.stdout = stdout
            #    ireturn =  False
            #time.sleep(1)
            #print  >> p.stdin, "aplay -q %s" % sPathFilename

        except Exception,e:
            self.printf("Sound.Open() Error aplay %s %s"%(sPathFilename, e))
            ireturn =  False
            
        
        #sys.stdin.flush()
        #sys.stdin.write("Test")    
        Treiber.output.flush()
        return ireturn
        
        
    
    
    

    def printf(self,string):
        if Treiber.stout:
            print string
        pass
        