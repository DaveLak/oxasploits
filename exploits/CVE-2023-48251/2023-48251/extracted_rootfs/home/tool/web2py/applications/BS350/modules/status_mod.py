import datetime
import os
import time
import subprocess
import traceback
from gluon.serializers import json
import WGDBus
import FileIface
import syslog
import threading
import fsio

__author__ = 'frank.sattelberger@bittwister.com'

_enable_syslog = False

_useSessionTimeout = True

class userMgr:
    def __init__(self):
        self.users = {}
        self.skipOnSetTimeList = {}
        self.__settime_lock = threading.RLock()

    def lockUserList(self):
        self.__settime_lock.acquire()

    def releaseUserList(self):
        self.__settime_lock.release()

    def rmvUser(self, session):
        try:
            if session == None:
                #print '---no remove---session none'
                return
            if session.auth == None:
                #print '---no remove---auth none'
                return

            if len(self.users) == 0:
                #print 'the list is empty no remove'
                return
            if 'hmac_key' in session.auth.keys():
                if session.auth.hmac_key in self.users.keys():
                    self.users.pop(session.auth.hmac_key, None)
                    if session.auth.hmac_key in self.skipOnSetTimeList.keys():
                        self.skipOnSetTimeList.pop(session.auth.hmac_key, None)
                        #print 'user has been removed', session.auth.hmac_key, self.skipOnSetTimeList, self.users
            else:
                pass#print 'No hmac_key'
        except:
            print 'Exception in rmvUser'#, sys.exc_info()[0] , sys.exc_info()[1]

    def setLastVisitAll(self):
        try:
            if len(self.users) == 0:
                return
            self.skipOnSetTimeList = {}
            for k in self.users.keys():
                self.skipOnSetTimeList[k] = datetime.datetime.now()
                self.users[k] = datetime.datetime.now()
                #print'--skipOnSetTimeList--', self.skipOnSetTimeList
        except:
            pass

    def skipSessionTimeout(self, session):
        try:
            if self.skipOnSetTimeList != {}:
                k = session.auth.hmac_key
                if k in self.skipOnSetTimeList.keys():
                    if k in self.users.keys():
                        self.users[k] = self.skipOnSetTimeList[k]
                        session.auth.last_visit = self.users[k]
                    self.skipOnSetTimeList.pop(k, None)
                    return True
        except:
            pass  # traceback.print_stack()
        return False

    def setLastVisit(self, session, request):
        import sys
        try:
            if session == None:
                #print 'No session'
                return
            if 'auth' not in session.keys():
                #print 'No session auth'
                return

            key = session.auth.hmac_key
            if key not in self.users.keys():
                #print 'NEW USER ADDED', key
                #print 'Size', (len(self.users) + 1)
                toremove = []
                for k in self.users.keys():
                    #print 'elapsed', (request.now - self.users[k]).seconds, session.auth.expiration
                    if (request.now - self.users[k]).seconds > session.auth.expiration:
                        #print 'session expired', k
                        toremove.append(k)
                if toremove != []:
                    for k in toremove:
                        self.users.pop(k, None)
                        self.skipOnSetTimeList.pop(k, None)
                        #print 'removed dead session', k
            self.users[key] = request.now
            #print 'Set last visit  known user', key
        except:
            print 'Exception in setLastVisit', sys.exc_info()[0] , sys.exc_info()[1]

    def getLastVisit(self, session, request):
        if _useSessionTimeout:
            try:
                key = session.auth.hmac_key
                #print'get last visit for', key
                if key in self.users.keys():
                    return self.users[key]
                #print '---user does not exist- added-now', key
                self.users[key] = request.now
            except:
                print 'Exception in getLastVisit'#, sys.exc_info()[0] , sys.exc_info()[1]
        return request.now

    def getUserCnt(self):
        return len(self.users)

try:
  sessionUserMgr = userMgr()
  #print 'sessionUserMgr created'
except:
  print 'Exception in create sessionUserMgr'


def noauthstatus(session, request):
    return authstatus(session, request, False)


def authstatus(session, request, withtimeoutcheck=True):
    now = time.time()
    status = {'time': 0, 'user': '-', 'cycle': 0, 'battery': 0, 'ready': False, 'sysfault': False, 'enabled': False,
              'expired': False, 'wlanConnection': False, 'wlanRssiLevel': 0, 'fcc-test-mode': False,
              'cfgFileChanged': False, 'shutdownSig': 0, 'number_of_failed': 0, 'conn_status': 0}

    t = time.localtime()
    status['time'] = {"year": t.tm_year, "month": t.tm_mon, "day": t.tm_mday, "hour": t.tm_hour, "min": t.tm_min,
                      "sec": t.tm_sec}

    if withtimeoutcheck:
        if session.auth:
            auth = session.auth
            # print "last_visit as got from session", calendar.timegm(auth.last_visit.timetuple())
            status['user'] = auth.user.username
            if auth.last_visit and auth.last_visit + datetime.timedelta(days=0, seconds=auth.expiration) > request.now:
                # print 'time elapsed in seconds', (request.now - auth.last_visit).seconds, auth.expiration, session.auth.hmac_key, "NOW", calendar.timegm(request.now.timetuple())
                if (request.now - auth.last_visit).seconds > (auth.expiration/10):
                    # print "SETTING the auth.last_visit. (IS THIS PROPAGATED TO FILE?)"
                    auth.last_visit = sessionUserMgr.getLastVisit(session, request)
            else:
                sessionUserMgr.lockUserList()
                # print 'about to remove user', session.auth.hmac_key
                if not sessionUserMgr.skipSessionTimeout(session):
                    auth.user = None
                    status['expired'] = True
                    sessionUserMgr.rmvUser(session)
                    #print '--expired--'
                else:
                    pass#print '------skipped-----', session.auth.hmac_key
                sessionUserMgr.releaseUserList()

    retrieve = request.vars.retrieve
    status['tcpdump'] = 0
    if retrieve == "DiagnosisNetworkTcpdumpCtrl":
        try:
            p = subprocess.Popen(['/etc/log/tcpdump.sh', 'status'])
            p.communicate()
            status['tcpdump'] = p.returncode
        except Exception, e:
            syslog.syslog(syslog.LOG_ERR, traceback.format_exc())
            status['tcpdump'] = 1

    status['client_list'] = ""
    if retrieve == "DiagnosisNetworkFindClientsCtrl":
        try:
            if os.path.exists('/var/run/client-list.txt'):
                client_list = fsio.read('/var/run/client-list.txt')
                status['client_list'] = client_list
        except Exception, e:
            syslog.syslog(syslog.LOG_ERR, traceback.format_exc())



    def res_conn_state():
        conn_state = WGDBus.getCurrentResConnState()
        op = WGDBus.getCurrentOperationMode()
        state = 0

        if conn_state == -1 or conn_state == 0:
            state = 3 if op == 2 else 0
        elif conn_state == 1:
            state = 4 if op == 2 else 1
        elif conn_state == 2:
            state = 5 if op == 2 else 2

        return state


    def status_find_clients():
        try:
            p = subprocess.Popen(['pidof', 'find-clients.sh'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            (stdout, stderr) = p.communicate()
            if stdout == "":
                return False
            else:
                return True
        except Exception, e:
            pass
        return False

    status['status_find_clients'] = status_find_clients()

    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before cycle " + str(time.time() - now))
    status['cycle'] = WGDBus.getCycle()
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before reading wlan.json " + str(time.time() - now))
    status['wlanActive'] = WGDBus.getWlanActive()  # fsio.jsonload(WLAN_FILENAME)['interface']
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before getFccTestMode " + str(time.time() - now))
    status['fcc-test-mode'] = WGDBus.getFccTestMode()
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before getBatteryPower " + str(time.time() - now))
    status['battery'] = WGDBus.getBatteryPower()
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before rdyGet " + str(time.time() - now))
    rdy = WGDBus.rdyGet()
    status['ready'] = True if rdy and rdy[0] == rdy[1] else False
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before sysErrorGet " + str(time.time() - now))
    sysError = WGDBus.get_sysfault()  # CR17204 (on sysfault and acksysfault syserrors from db are retrieved)
                                      #  WGDBus.sysErrorGet()
    status['sysfault'] = True if sysError and sysError[1] > 0 else False
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before toolEnableGet " + str(time.time() - now))
    status['enabled'] = WGDBus.toolEnableGet() > 0
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before wlanConnection " + str(time.time() - now))
    wlanConnection = WGDBus.wlanConnection()
    status['wlanConnection'] = True if wlanConnection and wlanConnection == 3 else False
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "before wlanRssiLevel " + str(time.time() - now))
    status['wlanRssiLevel'] = WGDBus.wlanRssiLevel()
    if _enable_syslog: syslog.syslog(syslog.LOG_DEBUG, "about to leave status function " + str(time.time() - now))
    status['cfgFileChanged'] = WGDBus.getChanCfgChanged()
    status['shutdownSig'] = WGDBus.getShutdownSignal()
    status['conn_status'] = res_conn_state()

    return json(status)
