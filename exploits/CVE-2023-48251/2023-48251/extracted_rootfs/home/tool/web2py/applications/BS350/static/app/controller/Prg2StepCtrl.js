/*global Ext: false, TR: false, APP: false */
Ext.define('BS350.controller.Prg2StepCtrl', {
  extend: 'BS350.custom.ViewController',
  models: ['PrgTask'],
  views: ['Prg2StepView', 'BS350.custom.ToggleColumn'],

  items: [
    { name: 'btnOk', query: '#btnOK', actions: {click: 'setAndClose'}},
    { name: 'btnCancel', query: '#btnCancel', actions: {click: 'close'}},

    { name: 'formPanel', query: '#formPanel', actions: {change: 'updateButtons', dirtychange: 'updateButtons', validitychange: 'updateButtons' } },
    { name: 'generalTree', query: '#generalTree'}
  ],
  progs_pairs: Ext.create('Ext.data.Store', { fields: [{ name: 'number', type: 'int' }, { name: 'name', type: 'string' }] }),
  pcons: BS350.custom.PCons,
  initView: function () {
    var me = this,
      //panel = this.V.formPanel,
      treePanel = this.V.generalTree,
      treeStore = treePanel.getStore(),
      stepData = this.step.getData();
    var prgtoolctrl = APP.getController("PrgToolCtrl");
    var torqueUnit = prgtoolctrl.currentProgram.get('TorqueUnit');
    var type = parseInt(stepData.Type, 10);
    if (type !== 1) {
      me.view.down('#switchingColumnId').setVisible(false);
    }

    var ce = treePanel.getPlugin(); //'prg2celled');
    ce.on('validateedit', function () {
      //me.updateButtons();
    });
    treeStore.on('update', function () {
      me.updateButtons();
    });
    /*stepDataCopy = Ext.decode(Ext.encode(stepData));*/
    var torqueUnitCombo = function (myValue) {
      if (myValue === undefined) {
        myValue = 0;
      }
      return {
        "readonly": false,
        "leaf": true,
        "treeId": me.pcons["Identity.TorqueUnit"].treeId,
        "myText": me.pcons["Identity.TorqueUnit"].text,
        "myValue": myValue,
        "invisible": false,
        "choice": APP.torqueUnitFactors.edAddedChoice,
        "type": "COMBOBOX"
      }
    };
    var categoryCombo = function (myValue) {
      return {
        "readonly": false,
        "leaf": true,
        "treeId": me.pcons["Identity.Name.Category"].treeId,
        "myText": me.pcons["Identity.Name.Category"].text,
        "myValue": myValue,
        "invisible": false,
        "choice": [
          ["0", "0: None"],
          ["1", "1: Tightening"],
          ["2", "2: Prelim. torque"],
          ["3", "3: End torque"],
          ["4", "4: Loosen"],
          ["5", "5: Rework"],
          ["6", "6: Function A"],
          ["7", "7: Function B"],
          ["8", "8: Function C"],
          ["9", "9: Function D"],
          ["10", "10: Function E"],
          ["11", "11: Start"]
        ],
        "type": "COMBOBOX"
      }
    };

    var graphResolutionCombo = function (myValue, type) {
      var choices = [
        ["0.25", "0.25"],
        ["0.5", "0.5"],
        ["1", "1"],
        ["2", "2"],
        ["5", "5"],
        ["10", "10"],
        ["20", "20"],
        ["50", "50"]
      ];
      if (type !== 0) {
        choices.splice(0, 0, ["0", "As start"]);
      }
      return {
        "readonly": false,
        "myValue": myValue.toString(),
        "invisible": false,
        "leaf": true,
        "choice": choices,
        "type": "COMBOBOX",
        "treeId": me.pcons["Graph properties.Graph Resolution"].treeId,
        "myText": me.pcons["Graph properties.Graph Resolution"].text
      }
    };

    var editBox = function (pconsObj, myValue, readonly) {
      var myEditBox = {
        "readonly": readonly,
        "leaf": true,
        "treeId": pconsObj.treeId,
        "myText": pconsObj.text,
        "myValue": myValue,
        "type": "EDITBOX"
      };
      if (pconsObj.enforceMaxLength) {
        myEditBox.enforceMaxLength = true;
        myEditBox.maxLength = pconsObj.maxLength;
      }

      return myEditBox;
    };

    var getGraphProperties = function (type, stepData) {
      var graphPropertiesRoot = {
        "expanded": true,
        treeId: me.pcons["Graph properties"].treeId,
        "myText": me.pcons["Graph properties"].text,
        "children": null
      };
      if (type === 0) {
        var items = [];
        items.push(graphResolutionCombo(stepData.GraphResolution, type));
        items.push({
          "readonly": false,
          "leaf": true,
          "myValue": stepData.MeasuringPoints,
          "invisible": false,
          "choice": [
            ["100", "100"],
            ["200", "200"],
            ["500", "500"],
            ["1000", "1000"],
            ["1500", "1500"],
            ["2000", "2000"]
          ],
          "type": "COMBOBOX",
          "treeId": me.pcons["Graph properties.Measuring Points"].treeId,
          "myText": me.pcons["Graph properties.Measuring Points"].text
        });
        graphPropertiesRoot.children = items;
        return graphPropertiesRoot;
      }
      return graphResolutionCombo(stepData.GraphResolution, type);
    };

    var getTargetParameters = function (type, stepData) {
      var items = [];
      if (type === 0) {
        items.push({
          "leaf": true,
          "treeId": me.pcons["Parameters.PlayAtStartSwitch"].treeId,
          "myText": me.pcons["Parameters.PlayAtStartSwitch"].text,
          "myValue": stepData.PlayStartSwitch,
          "min": 0,
          "max": 100,
          "step": 10,
          "default": 5,
          allowDecimals: false,
          decimalPrecision: 0,
          "unit": '%',
          "type": "NUMBERFIELD_U"
        });

        items.push({
          "leaf": true,
          "treeId": me.pcons["Parameters.CorrectionTorqueCt"].treeId,
          "myText": me.pcons["Parameters.CorrectionTorqueCt"].text,
          "myValue": stepData.CorrectionTorqueCt,
          "min": 0.8,
          "max": 1.2,
          "step": 0.0001,
          allowDecimals: true,
          decimalPrecision: 6,
          "default": 1,
          "allowBlank": false,
          "type": "NUMBERFIELD"
        });
      }

      if (type === 1) {
        var prg2stepctrl = APP.getController("Prg2StepCtrl");
        var limits = prg2stepctrl.limits;
        var value = Math.abs(stepData.Speed);
        var inLimits = true;
        if (value < limits.DrehzahlMinReduziert || value > limits.DrehzahlMax) {
          inLimits = false;
        }
        items.push({
          "leaf": true,
          "treeId": me.pcons["Target.Parameters.Speed"].treeId,
          "myText": me.pcons["Target.Parameters.Speed"].text,
          "myValue": stepData.Speed,
          "min": -20000,
          "max": 20000,
          "step": 10,
          "default": 0,
          "inLimits": inLimits,
          "inLimitsTooltip": inLimits ? "": TR("Speed exceeds specification limits. Must be between [-{1}, -{0}] and [{0}, {1}]").format(limits.DrehzahlMinReduziert, limits.DrehzahlMax),
          "unit": 'rpm',
          "type": "NUMBERFIELD_U"
        });
        items.push({
          "leaf": true,
          "treeId": me.pcons["Target.Parameters.Start suppression"].treeId,
          "myText": me.pcons["Target.Parameters.Start suppression"].text,
          "myValue": stepData.StartSuppression,
          "min": 0,
          "max": 100,
          "step": 1,
          "default": 0,
          "unit": 'ms',
          "type": "NUMBERFIELD_U"
        });
        function isTorqueThresholdReadonly() {
          var tfAngle = stepData.TF1_Angle != null ? stepData.TF1_Angle : stepData.TF2_Angle;
          var monAngleMin = stepData.MF_AngleMin != null ? stepData.MF_AngleMin : stepData.MF_AngleMin_Switching;
          var monAngleMax = stepData.MF_AngleMax != null ? stepData.MF_AngleMax : stepData.MF_AngleMax_Switching;
          var torqueThresholdReadonly = false;
          if (tfAngle == null && monAngleMin == null && monAngleMax == null) {
            torqueThresholdReadonly = true;
          }
          return torqueThresholdReadonly;
        }
        items.push({
          "leaf": true,
          "treeId": me.pcons["Target.Parameters.Torque threshold"].treeId,
          "myText": me.pcons["Target.Parameters.Torque threshold"].text,
          "myValue": stepData.TorqueThreshold,
          "min": 0,
          "max": BS350.custom.Torque.getValidationMax(torqueUnit),
          "step": 0.001,
          "default": 0,
          "allowDecimal": true,
          "readonly": isTorqueThresholdReadonly(),
          "decimalPrecision": BS350.custom.Torque.getUnitId2Precision(torqueUnit),
          "unit": BS350.custom.Torque.getUnitPres(torqueUnit),
          "type": "NUMBERFIELD_U"
        });
      }

      return items;
    };

    var getPlayStartSwitch = function (stepData) {
      return {
        "leaf": false,
        "expanded": true,
        "treeId": me.pcons["Parameters"].treeId,
        "myText": me.pcons["Parameters"].text,
        children: [{
            "leaf": true,
            "treeId": me.pcons["Parameters.PlayAtStartSwitch"].treeId,
            "myText": me.pcons["Parameters.PlayAtStartSwitch"].text,
            "myValue": stepData.PlayStartSwitch,
            "min": 0,
            "max": 100,
            "step": 5,
            allowDecimals: false,
            decimalPrecision: 0,
            "default": 5,
            "unit": "%",
            "invisible": false,
            "type": "NUMBERFIELD_U"
          },
          {
            "leaf": true,
            "treeId": me.pcons["Parameters.CorrectionTorqueCt"].treeId,
            "myText": me.pcons["Parameters.CorrectionTorqueCt"].text,
            "myValue": stepData.CorrectionTorqueCt,
            "min": 0.8,
            "max": 1.2,
            "step": 0.0001,
            allowDecimals: true,
            decimalPrecision: 4,
            "default": 1,
            "invisible": false,
            "type": "NUMBERFIELD"
          }
        ]
      }
    };

    var getStartupTests = function () {
      return {
        "expanded": stepData.StartupTest === false ? false: true,
        "leaf": false,
        "expandable": false,
        "treeId": me.pcons["Startup test.Active"].treeId,
        "myText": me.pcons["Startup test.Active"].text,
        "readonly": false,
        "myValue": stepData.StartupTest === false ? false: true,
        "invisible": false,
        "type": "CHECKBOX",
        "children": [
          {
            "leaf": true,
            "treeId": me.pcons["Startup test.Active.Speed"].treeId,
            "myText": me.pcons["Startup test.Active.Speed"].text,
            "myValue": stepData.Speed,
            "min": 0,
            "max": 100,
            "step": 5,
            allowDecimals: true,
            "default": 5,
            "unit": "%",
            "invisible": false,
            "type": "NUMBERFIELD_U"
          },
          {
            "leaf": true,
            "treeId": me.pcons["Startup test.Active.Start suppression"].treeId,
            "myText": me.pcons["Startup test.Active.Start suppression"].text,
            "myValue": stepData.StartSuppression,
            "min": 0,
            "max": 100,
            "step": 1,
            "default": "0",
            "unit": "ms",
            "invisible": false,
            "type": "NUMBERFIELD_U"
          },
          {
            "leaf": false,
            "expanded": true,
            "treeId": me.pcons["Startup test.Active.Target function"].treeId,
            "myText": me.pcons["Startup test.Active.Target function"].text,
            "invisible": false,
            "children": [
              {
                "leaf": true,
                "treeId": me.pcons["Startup test.Active.Target function.Angle"].treeId,
                "myText": me.pcons["Startup test.Active.Target function.Angle"].text,
                "myValue": stepData.TF_Angle,
                "min": 0,
                "max": 200000,
                "step": 1,
                "default": "0",
                "unit": "°",
                "invisible": false,
                "type": "NUMBERFIELD_U"
              }
            ]
          },
          {
            "leaf": false,
            "expanded": true,
            "treeId": me.pcons["Startup test.Active.Monitoring functions (Switching)"].treeId,
            "myText": me.pcons["Startup test.Active.Monitoring functions (Switching)"].text,
            "invisible": false,
            "children": [
              {
                "leaf": true,
                "treeId": me.pcons["Startup test.Active.Monitoring functions (Switching).Torque max."].treeId,
                "myText": me.pcons["Startup test.Active.Monitoring functions (Switching).Torque max."].text,
                "myValue": stepData.MF_TorqueMax_Switching,
                "min": 0,
                "max": 100,
                "step": 1,
                "default": "5",
                "unit": "%",
                "invisible": false,
                "type": "NUMBERFIELD_U"
              },
              {
                "leaf": true,
                "treeId": me.pcons["Startup test.Active.Monitoring functions (Switching).Time max."].treeId,
                "myText": me.pcons["Startup test.Active.Monitoring functions (Switching).Time max."].text,
                "myValue": stepData.MF_Time_Switching,
                "min": 0,
                "max": 1000,
                "step": 1,
                "default": "10",
                "unit": "s",
                "invisible": false,
                "type": "NUMBERFIELD_U"
              }
            ]
          }
        ]
      }
    };

    var getTargetFunctionComboUnit = function (stepData, count) {
      if (stepData["TF{0}_Angle".format(count)]) {
        return "2";
      } else if (stepData["TF{0}_Time".format(count)]) {
        return "3";
      } else if (stepData["TF{0}_UpperTorque".format(count)]) {
        return "1";
      }
      return "0";
    };

    var getTargetFunctionUnit = function (stepData, count) {
      if (stepData["TF{0}_Angle".format(count)]) {
        return "°";
      } else if (stepData["TF{0}_Time".format(count)]) {
        return "s";
      } else if (stepData["TF{0}_UpperTorque".format(count)]) {
        return BS350.custom.Torque.getUnitPres(torqueUnit);
      }
      return "";
    };

    var getTargetFunctionValue = function (stepData, count) {
      if (stepData["TF{0}_Angle".format(count)]) {
        return stepData["TF{0}_Angle".format(count)];
      } else if (stepData["TF{0}_Time".format(count)]) {
        return stepData["TF{0}_Time".format(count)];
      } else if (stepData["TF{0}_UpperTorque".format(count)]) {
        return stepData["TF{0}_UpperTorque".format(count)];
      }
      return "0";
    };

    var prg2stepctrl = APP.getController("Prg2StepCtrl");
    var limits = prg2stepctrl.limits;

    function getValidationLimits(value, type) {
        var res = {inLimits: true, decimalPrecision: 2, validationMax: undefined, type: type};
        if (type === "1") { /* Torque */
          res.decimalPrecision = BS350.custom.Torque.getUnitId2Precision(torqueUnit);

          var maxMoment;
          if (Math.abs(stepData.Speed) < limits.DrehzahlMin){
            maxMoment = limits.MomentMaxReduziert;
          }else {
            maxMoment = limits.MomentMax;
          }
          if (value < BS350.custom.Torque.getValidationWert(limits.MomentMin, torqueUnit)
              || value > BS350.custom.Torque.getValidationWert(maxMoment, torqueUnit)) {
            res.inLimits = false;
          }
          res.validationMax = BS350.custom.Torque.getValidationMax(torqueUnit);
        } else if (type === "2") { /* Angle */
          res.validationMax = 200000;
        } else if (type === "3") { /* Time */
          res.validationMax = 1000;
        }
        return res;
      }

      var secTgtFunVal = parseFloat(getTargetFunctionValue(stepData, 2));
      var secUnit = getTargetFunctionComboUnit(stepData, 2);
      var secValLimits = getValidationLimits(secTgtFunVal, secUnit);
      var secTargetFunActive = false;
      if (getTargetFunctionComboUnit(stepData, 2) != 0 && getTargetFunctionComboUnit(stepData, 2) != "None") {
          secTargetFunActive = true;
      }
      function getTargetFunctions() {

        var getInLimitsTooltip = function (valLimits, torqueUnit) {
          if (valLimits.inLimits) {
            return "";
          }
          switch (valLimits.type) {
            case "1": /* Torque */
              return TR("Torque exceeds specification limits [{0}, {1}]").format(
                BS350.custom.Torque.getValidationWert(limits.MomentMin, torqueUnit),
                BS350.custom.Torque.getValidationWert(limits.MomentMax, torqueUnit));
            case "2": /* Angle */
            case "3": /* Time */
            default:
              return "";
          }
        };
        var firstTgtFunVal = parseFloat(getTargetFunctionValue(stepData, 1));
        var unit = getTargetFunctionComboUnit(stepData, 1);
        var valLimits = getValidationLimits(firstTgtFunVal, unit);
        var children = [
          {
            "expanded": true,
            "treeId": me.pcons["Target function.First target function"].treeId,
            "myText": me.pcons["Target function.First target function"].text,
            "myValue": getTargetFunctionComboUnit(stepData, 1),
            "valid": unit === "0" ? false : true,
            "validTooltip": TR("Program needs a first target function"),
            "choice": [
              ["0", "None"],
              ["1", "Torque"],
              ["2", "Angle"],
              ["3", "Time"]
            ],
            "type": "COMBOBOX",
            children: [
              {
                "leaf": true,
                "treeId": me.pcons["Target function.First target function.First Target"].treeId,
                "myText": me.pcons["Target function.First target function.First Target"].text,
                "myValue": getTargetFunctionValue(stepData, 1),
                "valid": unit === "0" ? false : true,
                "inLimits": valLimits.inLimits,
                "inLimitsTooltip": getInLimitsTooltip(valLimits, torqueUnit),
                "min": 0.001,
                "max": valLimits.validationMax,
                "step": 1,
                "allowDecimal": true,
                "decimalPrecision": valLimits.decimalPrecision,
                "unit": getTargetFunctionUnit(stepData, 1),
                "type": "NUMBERFIELD_U"
              }
            ]
          }
        ];

        var firstTargetFunComboUnit = getTargetFunctionComboUnit(stepData, 1);
        var choices = [
          ["0", me.pcons["None"].text],
          ["1", me.pcons["Torque"].text],
          ["2", me.pcons["Angle"].text],
          ["3", me.pcons["Time"].text]
        ];
        var refchoices = {
          "0": me.pcons["None"].text,
          "1": me.pcons["Torque"].text,
          "2": me.pcons["Angle"].text,
          "3": me.pcons["Time"].text
        };
        var index = -1;
        Ext.Array.forEach(choices, function (elem, idx) {
          if (idx > 0 && (me.pcons[elem[1]].text === me.pcons[refchoices[firstTargetFunComboUnit]].text)) {
            index = idx;
          }
        });
        if (index > -1) {
          choices.splice(index, 1);
        }
        var valid = false;
        var unit = getTargetFunctionComboUnit(stepData, 2);
        if (unit != 0 && unit != "None") {
          valid = true;
        }
        for (var i = 0; i < choices.length; i++) {
          choices[i][0] = choices[i][0].toString();
        }
        var valueValid = false;
        var secTgtFunVal = parseFloat(getTargetFunctionValue(stepData, 2));
        if (secTgtFunVal > 0) {
          valueValid = true;
        }

        children.push({
          "expanded": true,
          "invisible": false,
          "treeId": me.pcons["Target function.2nd target function"].treeId,
          "myText": me.pcons["Target function.2nd target function"].text,
          "myValue": getTargetFunctionComboUnit(stepData, 2),
          "valid": true,
          "choice": choices,
          "type": "COMBOBOX",
          children: [
            {
              "leaf": true,
              "invisible": false,
              "treeId": me.pcons["Target function.2nd target function.2nd Target"].treeId,
              "myText": me.pcons["Target function.2nd target function.2nd Target"].text,
              "myValue": getTargetFunctionValue(stepData, 2),
              "valid": true,
              "inLimits": secValLimits.inLimits,
              "inLimitsTooltip": getInLimitsTooltip(secValLimits, torqueUnit),
              "min": 0.001,
              "max": secValLimits.validationMax,
              "step": 1,
              "allowDecimal": true,
              "decimalPrecision": secValLimits.decimalPrecision,
              "unit": getTargetFunctionUnit(stepData, 2),
              "type": "NUMBERFIELD_U"
            }
          ]
        });
        return children;
      };

    var getTargetAndMonitorFuncs = function (stepData) {
      var prg2stepctrl = APP.getController("Prg2StepCtrl");
      var limits = prg2stepctrl.limits;
      var value = getTargetFunctionValue(stepData, 1);
      var unit = getTargetFunctionComboUnit(stepData, 1);


      var valLimits = getValidationLimits(value, unit);

      //var children = getTargetFunctions();
      var value = getTargetFunctionValue(stepData, 1);
      var unit = getTargetFunctionComboUnit(stepData, 1);
      var secTargetFuncPossible = false;
      if (unit !== "None" && (value != "0" && value != "")) {
        secTargetFuncPossible = true;
      }
      /* CR16019 start: Plausi anzeigen das schaltend mit None nicht möglich ist */
      var monTorqueMinMyValue = stepData.MF_TorqueMin != null ? stepData.MF_TorqueMin : stepData.MF_TorqueMin_Switching;
      var isNotSet = function (myValue) {
        return typeof myValue === "undefined" || myValue === null || (typeof myValue === "string" && Ext.String.trim(myValue) === "")
      }
      var monTorqueMinSwitching_readonly = false;
      var monTorqueMaxSwitching_readonly = false;
      if (isNotSet(monTorqueMinMyValue)) {
        monTorqueMinSwitching_readonly = true;
      }
      var monTorqueMaxMyValue = stepData.MF_TorqueMax != null ? stepData.MF_TorqueMax : stepData.MF_TorqueMax_Switching;
      if (isNotSet(monTorqueMaxMyValue)) {
        monTorqueMaxSwitching_readonly = true;
      }

      var monAngleMaxSwitching_readonly = false;
      var monAngleMaxMyValue = stepData.MF_AngleMax != null ? stepData.MF_AngleMax : stepData.MF_AngleMax_Switching
      if (isNotSet(monAngleMaxMyValue)) {
        monAngleMaxSwitching_readonly = true;
      }
      /* CR16019 end */

      var items = [
      {
        "expanded": true,
        "leaf": false,
        "treeId": me.pcons["Monitor"].treeId,
        "myText": me.pcons["Monitor"].text,
        "children": [
          {
            expanded: true,
            "leaf": true,
            "treeId": me.pcons["Monitor.Torque.Min"].treeId,
            myText: me.pcons["Monitor.Torque.Min"].text,
            "myValue": monTorqueMinMyValue,
            "switching": stepData.MF_TorqueMin_Switching != null ? true : false,
            "switching_readonly": monTorqueMinSwitching_readonly,
            "min": -1*BS350.custom.Torque.getValidationMax(torqueUnit),
            "max": BS350.custom.Torque.getValidationMax(torqueUnit),
            "step": 1,
            "allowDecimal": true,
            "decimalPrecision": BS350.custom.Torque.getUnitId2Precision(torqueUnit),
            "unit": BS350.custom.Torque.getUnitPres(torqueUnit),
            "allowBlank": true,
            "blankText": "None",
            "type": "NUMBERFIELD_U"/*,
            children: [
              {
                leaf: true,
                treeId: me.pcons["Monitor.Torque.Min.Switching"].treeId,
                myText: me.pcons["Monitor.Torque.Min.Switching"].text,
                readonly: false,
                myValue: stepData.MF_TorqueMin_Switching ? true : false,
                invisible: false,
                type: "CHECKBOX"
              }
            ]*/
          },
          {
            leaf: true,
            treeId: me.pcons["Monitor.Torque.Target"].treeId,
            myText: me.pcons["Monitor.Torque.Target"].text,
            readonly: true,
            myValue: me.pcons["Monitor.Torque.Target"].getTorqueTargetValue(stepData),
            invisible: false,
            "allowDecimal": true,
            "decimalPrecision": BS350.custom.Torque.getUnitId2Precision(torqueUnit),
            "unit": BS350.custom.Torque.getUnitPres(torqueUnit),
            "allowBlank": true,
            "blankText": "-",
            type: "NUMBERFIELD_U"
          },
          {
            expanded: true,
            leaf: true,
            treeId: me.pcons["Monitor.Torque.Max"].treeId,
            myText: me.pcons["Monitor.Torque.Max"].text,
            "myValue": monTorqueMaxMyValue,
            "switching":  stepData.MF_TorqueMax == null ? true : false,
            "switching_readonly": monTorqueMaxSwitching_readonly,
            "min": -1*BS350.custom.Torque.getValidationMax(torqueUnit),
            "max": BS350.custom.Torque.getValidationMax(torqueUnit),
            "step": 1,
            "allowDecimal": true,
            "decimalPrecision": BS350.custom.Torque.getUnitId2Precision(torqueUnit),
            "unit": BS350.custom.Torque.getUnitPres(torqueUnit),
            "allowBlank": true,
            "blankText": "None",
            "type": "NUMBERFIELD_U" /*,
            children: [
              {
                leaf: true,
                treeId: me.pcons["Monitor.Torque.Max.Switching"].treeId,
                myText: me.pcons["Monitor.Torque.Max.Switching"].text,
                readonly: false,
                myValue: stepData.MF_TorqueMax_Switching ? true : false,
                invisible: false,
                type: "CHECKBOX"
              }
            ]*/
          },
          {
            expanded: true,
            leaf: true,
            treeId: me.pcons["Monitor.Angle.Min"].treeId,
            myText: me.pcons["Monitor.Angle.Min"].text,
            "myValue": stepData.MF_AngleMin,
            /*"switching": stepData.MF_AngleMin_Switching != null ? true : false,*/
            "min": 0,
            "max": 200000,
            "step": 1,
            "unit": "°",
            "allowBlank": true,
            "blankText": "None",
            "type": "NUMBERFIELD_U"/*,
            children: [
              {
                leaf: true,
                treeId: me.pcons["Monitor.Angle.Min.Switching"].treeId,
                myText: me.pcons["Monitor.Angle.Min.Switching"].text,
                readonly: true,
                myValue: stepData.MF_AngleMin_Switching != null ? true : false,
                invisible: true,
                type: "CHECKBOX"
              }
            ]*/
          },
          {
            leaf: true,
            treeId: me.pcons["Monitor.Angle.Target"].treeId,
            myText: me.pcons["Monitor.Angle.Target"].text,
            readonly: true,
            myValue: me.pcons["Monitor.Angle.Target"].getAngleTargetValue(stepData),
            invisible: false,
            "unit": "°",
            "allowBlank": true,
            "blankText": "-",
            type: "NUMBERFIELD_U"
          },
          {
            expanded: true,
            leaf: true,
            treeId: me.pcons["Monitor.Angle.Max"].treeId,
            myText: me.pcons["Monitor.Angle.Max"].text,
            "myValue": monAngleMaxMyValue,
            "switching": stepData.MF_AngleMax == null ? true : false,  //stepData.MF_AngleMax_Switching != null ? true : false,
            "switching_readonly": monAngleMaxSwitching_readonly,
            "min": 0,
            "max": 200000,
            "step": 1,
            "unit": "°",
            "allowBlank": true,
            "blankText": "None",
            "type": "NUMBERFIELD_U" /*,
            children: [
              {
                leaf: true,
                treeId: me.pcons["Monitor.Angle.Max.Switching"].treeId,
                myText: me.pcons["Monitor.Angle.Max.Switching"].text,
                readonly: false,
                myValue: stepData.MF_AngleMax_Switching != null ? true : false,
                invisible: false,
                type: "CHECKBOX"
              }
            ]*/
          },
          /*{
            expanded: true,
            treeId: me.pcons["Monitor.Time"].treeId,
            myText: me.pcons["Monitor.Time"].text,
            children: [*/
              /*{
                expanded: true,
                readonly: true,
                treeId: me.pcons["Monitor.Time.Min"].treeId,
                myText: me.pcons["Monitor.Time.Min"].text,
                "myValue": "None",
                "min": 0,
                "max": 1000,
                "step": 1,
                "unit": "",
                "allowBlank": true,
                "blankText": "None",
                "type": "NUMBERFIELD_U",
                children: [
                  {
                    leaf: true,
                    treeId: me.pcons["Monitor.Time.Min.Switching"].treeId,
                    myText: me.pcons["Monitor.Time.Min.Switching"].text,
                    readonly: true,
                    myValue: true,
                    invisible: false,
                    type: "CHECKBOX"
                  }
                ]
              },*/
              {
                expanded: true,
                leaf: true,
                treeId: me.pcons["Monitor.Time.Max"].treeId,
                myText: me.pcons["Monitor.Time.Max"].text,
                "myValue": stepData.MF_Time_Switching,
                "switching": true,
                "switching_readonly": true,
                "min": 0,
                "max": 1000,
                "step": 1,
                "unit": "s",
                "allowBlank": true,
                "blankText": "None",
                "type": "NUMBERFIELD_U"/*,
                children: [
                  {
                    leaf: true,
                    treeId: me.pcons["Monitor.Time.Max.Switching"].treeId,
                    myText: me.pcons["Monitor.Time.Max.Switching"].text,
                    readonly: true,
                    myValue: true,
                    invisible: false,
                    type: "CHECKBOX"
                  }
                ]*/
              }
            /*]
          }*/
        ]
      }
      ];
      return items;
    };

    var switchBetweenTypes = function (type, stepData) {
      if (type === 0) {
        res = [];

        res.push(getPlayStartSwitch(stepData));

        res.push(getStartupTests(stepData));
        return res;
      } else {
        return getTargetAndMonitorFuncs(stepData);
      }
    };

    var getRootsChildren = function (type, stepData) {
      var items = [
        editBox(me.pcons["Identity.Name"], stepData.Name, false)
      ];
      //return items;
      if (type === 2) {
        //items[0].children[0].leaf = true;
      }
      if (type !== 2) {
        items.push(categoryCombo(stepData.Category));
        items.push(getGraphProperties(type, stepData));
        if (type === 0) {
          items.push(torqueUnitCombo(torqueUnit));
        }
        /*var targetParams = getTargetParameters(type, stepData);
        var k;
        for (k = 0; k < targetParams.length; k++) {
          items.push(targetParams[k]);
        }*/
        var target = {
          "expanded": true,
          treeId: me.pcons["Target"].treeId,
          "myText": me.pcons["Target"].text,
          "children": getTargetParameters(type, stepData)
        };
        if (type === 1) {
          items.push(target);
          var tfs = getTargetFunctions();
          var k;
          for (k = 0; k < tfs.length; k++) {
            target.children.push(tfs[k]);
          }
        }
        var toAppend = switchBetweenTypes(type, stepData);
        Ext.Array.forEach(toAppend, function (append) {
          items.push(append);
        });
      }
      return items;
    };


    var getStepTreeData = function (type, stepData) {
      return {
        "Column": stepData.Column,
        "IO_Next": stepData.IO_Next,
        "Type": stepData.Type,
        "id": stepData.id,
        "Row": stepData.Row,
        "children": getRootsChildren(type, stepData)
      };
    };
    var stepDataCopy = getStepTreeData(type, stepData);

    this.invalid = false;

    if (me.access !== 'w') {
      me.V.btnOk.hide();
    }

    treeStore.loadNewData(stepDataCopy);
    if (me.access !== 'w') {
      treeStore.getRootNode().cascadeBy(function (el) {
        el.set("readonly", true);
      });
    }
    // Window title
    this.view.setTitle(TR('Step') + ':' + this.step.getData().Name);
  },

  getValueOfNode: function (rootNode, attr, targetObj, targetAttr) {
    var foundChild = rootNode.findChild("myText", attr, true);
    if (foundChild) {
      var value = foundChild.get('myValue');
      if (value !== undefined && value !== null) {
        targetObj[targetAttr] = value;
      } else {
        delete targetObj[targetAttr];
      }
    }
  },
  getValueOfNodeFromTreeId: function (rootNode, attr, targetObj, targetAttr, callback) {
    var foundChild = rootNode.findChild("treeId", attr, true);
    if (foundChild) {
      var value = foundChild.get('myValue');
      if (callback !== undefined) {
        callback();
      }
      if (value !== undefined && value !== null) {
        targetObj[targetAttr] = value;
      } else {
        delete targetObj[targetAttr];
      }
    }
  },

  setAndClose: function () {

    var me = this;
    var tree = this.V.generalTree;
    tree.getPlugin().completeEdit();
    var startNode = tree.getRootNode();
    var editedData = {};
    var torqueUnit = startNode.findChild("treeId", "Identity.TorqueUnit", true);
    if (torqueUnit !== null
      && torqueUnit.isModified("myValue") === true) {

      var me = this;
      Ext.MessageBox.show({
        title: TR("Torque Unit is changed"),
        msg: TR("Torque unit will be changed -- Please review the converted torque values."),
        buttons: Ext.Msg.YESNO,
        buttonText: {yes: TR("Continue"), no: TR("Cancel")},
        fn: function (btn, dd, obj) {
        if (btn === "yes") {
          me.getValueOfNodeFromTreeId(startNode, "Identity.TorqueUnit", editedData, "TorqueUnit");
          var prgtoolctrl = APP.getController("PrgToolCtrl");
          var currentProgram = prgtoolctrl.currentProgram;
          var oldTorqueUnit = currentProgram.get('TorqueUnit');
          var newTorqueUnit = torqueUnit.get('myValue');
          currentProgram.set('TorqueUnit', torqueUnit.get('myValue'));
          Ext.Array.each(currentProgram.stepsStore.data.items, function (item) {
            if (item.get('Type') === 1) {
              Ext.Array.each(['TorqueThreshold', 'TF1_UpperTorque', 'TF2_UpperTorque', 'MF_TorqueMin', 'MF_TorqueMin_Switching', 'MF_TorqueMax', 'MF_TorqueMax_Switching'],
                function (prop) {
                  var value = item.get(prop);
                  if (value !== null) {
                    var torque = Ext.create('BS350.custom.Torque', {value: parseFloat(value), unit: parseInt(oldTorqueUnit, 10)});
                    item.set(prop, torque.convert(parseInt(newTorqueUnit, 10)).getRoundedValByUnit());
                  }
                }
              );
            }
          });
          //var prg2stepctrl = APP.getController("Prg2StepCtrl");
          //prg2stepctrl.setAndClose();
          me.innerSetAndClose(editedData);
        } else if (btn === "no") {
          me.view.close();
          //newVal = oldVal;
          //me.data.set('myValue', oldVal);
        } else {

        }
      }});
    } else {
      this.innerSetAndClose(editedData);
    }

  },
  innerSetAndClose: function (editedData) {
    var me = this;
    var tree = this.V.generalTree;
    var startNode = tree.getRootNode();
    var stepData = this.step.getData();
    var stepDataCopy = Ext.decode(Ext.encode(stepData));
    editedData.Type = stepDataCopy.Type;
    editedData.Column = stepDataCopy.Column;
    editedData.Row = stepDataCopy.Row;
    editedData.NIO_Next = stepDataCopy.NIO_Next;
    editedData.IO_Next = stepDataCopy.IO_Next;
    me.getValueOfNode(startNode, "Name", editedData, "Name");
    me.getValueOfNode(startNode, "Category", editedData, "Category");
    me.getValueOfNode(startNode, "Graph Resolution", editedData, "GraphResolution");
    me.getValueOfNode(startNode, "Measuring Points", editedData, "MeasuringPoints");
    me.getValueOfNode(startNode, "Play Startbutton", editedData, "PlayStartSwitch");
    me.getValueOfNode(startNode, "Speed", editedData, "Speed");
    me.getValueOfNode(startNode, "Start Suppression", editedData, "StartSuppression");
    me.getValueOfNode(startNode, "Torque correction", editedData, "CorrectionTorqueCt");

    if (stepData.Type == 0) {
      var activeNode = startNode.findChild("treeId", "Startup test.Active", true);
      var active = false;
      if (activeNode) {
        active = activeNode.get('myValue') === "true";
      }
      if (active == true) {
        editedData.StartupTest = true;
        me.getValueOfNode(activeNode, "Speed", editedData, "Speed");
        me.getValueOfNode(activeNode, "Start Suppression", editedData, "StartSuppression");
        me.getValueOfNode(activeNode, "Angle", editedData, "TF_Angle");
        me.getValueOfNode(activeNode, "Torque Max", editedData, "MF_TorqueMax_Switching");
        me.getValueOfNode(activeNode, "Time Max", editedData, "MF_Time_Switching");
      } else {
        editedData.StartupTest = false;
        editedData.Speed = null;
        editedData.StartSuppression = null;
        editedData.TF_Angle = null;
        editedData.MF_TorqueMax_Switching = null;
        editedData.MF_Time_Switching = null;
      }
    }

    function getMonitorValue(attr) {
      var generalTree = Ext.ComponentQuery.query("#generalTree")[0];
      var rootNode = generalTree.getRootNode();
      var attrMinNode = rootNode.findChild("treeId", me.pcons["Monitor.{0}.Min".format(attr)].treeId, true);
      var switching = false;
      if (attr === "Torque") {
        var attrMinSwitchingNode = rootNode.findChild("treeId", me.pcons["Monitor.{0}.Min".format(attr)].treeId, true);
        switching = attrMinSwitchingNode.get("switching");
      }
      if (switching === true) {
        if (attrMinNode.get("myValue") === "") {
          editedData["MF_{0}Min_Switching".format(attr)] = null;
        } else {
          editedData["MF_{0}Min_Switching".format(attr)] = attrMinNode.get("myValue");
        }
        editedData["MF_{0}Min".format(attr)] = null;
      } else {
        if (attrMinNode.get("myValue") === "") {
          editedData["MF_{0}Min".format(attr)] = null;
        } else {
          editedData["MF_{0}Min".format(attr)] = attrMinNode.get("myValue");
        }
        editedData["MF_{0}Min_Switching".format(attr)] = null;
      }
      var attrMaxNode = rootNode.findChild("treeId", me.pcons["Monitor.{0}.Max".format(attr)].treeId, true);
      var attrMaxSwitchingNode = rootNode.findChild("treeId", me.pcons["Monitor.{0}.Max".format(attr)].treeId, true);
      var switchingMax = attrMaxSwitchingNode.get("switching");
      editedData["MF_{0}Max_Switching".format(attr)] = null;
      editedData["MF_{0}Max".format(attr)] = null;
      if (attrMaxNode.get("myValue") !== "") {
        if (switchingMax === true) {
          editedData["MF_{0}Max_Switching".format(attr)] = attrMaxNode.get("myValue");
        } else {
          editedData["MF_{0}Max".format(attr)] = attrMaxNode.get("myValue");
        }
      }
    }

    var getTargetFunction = function (count) {
      var targetFunctionText = "Target function.First target function";
      var subTargetFunText = "Target function.First target function.First Target";
      if (count === 2) {
        targetFunctionText = "Target function.2nd target function";
        subTargetFunText = "Target function.2nd target function.2nd Target";
      }
      var targetFunctionNode = startNode.findChild("treeId", targetFunctionText, true);
      var targetFunctionType = targetFunctionNode.get('myValue');
      editedData["TF{0}_UpperTorque".format(count)] = null;
      editedData["TF{0}_Angle".format(count)] = null;
      editedData["TF{0}_Time".format(count)] = null;
      if (targetFunctionType == 1 || targetFunctionType == "Torque") {
        editedData["TF{0}_UpperTorque".format(count)] = parseFloat(targetFunctionNode.findChild("treeId", subTargetFunText, true).get('myValue'));
      } else if (targetFunctionType == 2 || targetFunctionType == "Angle") {
        editedData["TF{0}_Angle".format(count)] = parseFloat(targetFunctionNode.findChild("treeId", subTargetFunText, true).get('myValue'));
      } else if (targetFunctionType == 3 || targetFunctionType == "Time") {
        editedData["TF{0}_Time".format(count)] = parseFloat(targetFunctionNode.findChild("treeId", subTargetFunText, true).get('myValue'));
      }
    };
    me.getValueOfNode(startNode, "Name", editedData, "Name");
    if (stepData.Type == 1) {

      me.getValueOfNode(startNode, "Torque Threshold", editedData, "TorqueThreshold");
      getTargetFunction(1);
      getTargetFunction(2);

      getMonitorValue("Torque");
      getMonitorValue("Angle");
      var timeMaxNode = startNode.findChild('treeId', "Monitor.Time.Max", true);

      var timeMaxValue = timeMaxNode.get('myValue');
      if (timeMaxValue === "") {
        timeMaxValue = null;

      }
      editedData.MF_Time_Switching = timeMaxValue;
    }

    startNode.cascadeBy(function (currNode) {
      tree.fireEvent('deselect', this, currNode);
    });

    if (tree.getStore().isDirty()) {
      this.step.set(editedData);
    }
    Ext.ComponentQuery.query('#myToolview')[0].view.refresh();
    this.view.close();
  },
  close: function () {
    this.view.close();
  },

  updateButtons: function () {

    var generalTree = Ext.ComponentQuery.query("#generalTree")[0];
    var rootNode = generalTree.getRootNode();

    var isvalid = true;
    //var hasChanged = false;
    rootNode.cascadeBy(function (currNode) {
      if ( ! currNode.get('valid')) {
        isvalid = false;
        return false;
      }
    });

    /*rootNode.cascadeBy(function (currNode) {
      if (currNode.isModified('myValue')) {
        hasChanged = true;
        return false;
      }
    });*/
    if (this.V.btnOk !== undefined) {
      if (isvalid === false) {
        this.V.btnOk.setDisabled(true);
      } else {
        this.V.btnOk.setDisabled(false);
      }
    }
  }

});
