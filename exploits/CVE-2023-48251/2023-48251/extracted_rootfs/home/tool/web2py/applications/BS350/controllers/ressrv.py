# coding: utf8
import json
import shutil
import WGDBus
import Activity
import FilePaths
import os
from glob import glob
from xml.etree import ElementTree as ET
import fsio
import logConfig
import status_mod
import fcntl

# Fake globals for syntax check
import notify_activity

if False:
  response = None
  request = None
  session = None
  db = None

status_mod.sessionUserMgr.setLastVisit(session, request)
if logConfig.ressrvSessFrgt:
  session.forget(response)

RESULT_DATABASE = '/home/tool/data/result.sq3'

ACTIVITY_CODE = {
  'FTP': Activity.RESFTP_CHANGED,
  'Open protocol': Activity.OPENPRT_CHANGED,
  'OPEN PROTOCOL': Activity.OPENPRT_CHANGED,
  'IPM': Activity.IPM_CHANGED,
  'NXSD': Activity.NXSD_CHANGED,
  'HTTP': Activity.HTTP_CHANGED,
  'NFS': Activity.NFS_CHANGED
}


@auth.requires(request.ajax==True, requires_login=True)
def resultstorage():
  if request.env.request_method == "GET":
    res = fsio.jsonload(FilePaths.RESSRV_FILENAME)
    #ftpToSdCard = fsio.jsonload(FilePaths.FTP_TO_SD_CARD_FILENAME)
    #res['database']['format'] = ftpToSdCard['format']
    return response.json(res)

  if request.env.request_method == "POST":
    orig = fsio.jsonload(FilePaths.RESSRV_FILENAME)

    if not orig == []:
      sdCardActiveChanged = False
      data = json.loads(request.body.read())
      #format = data['database']['format']
      #del data['database']['format']
      if 'procName' in data:
        for p in orig['proc']:
          if p['name'] == data['procName']:
            p['active'] = data['active']
      else:
        if 'trgtProc' in data:
          for p in orig['proc']:
            if p['name'] == data['trgtProc']['name']:
              if p['active'] != data['trgtProc']['active']:
                sdCardActiveChanged = True
              p['active'] = data['trgtProc']['active']
          del data['trgtProc']
        for k, v in data.iteritems():
          orig[k].update(v)

      #ftpToSdCard = fsio.jsonload(FilePaths.FTP_TO_SD_CARD_FILENAME)
      #ftpToSdCard['format'] = format
      #fsio.jsondump_sorted(FilePaths.FTP_TO_SD_CARD_FILENAME, ftpToSdCard)

      fsio.jsondump_sorted(FilePaths.RESSRV_FILENAME, orig)

      notify_activity.configChanged(FilePaths.RESSRV_FILENAME, Activity.RESSRV_CHANGED, session=session)
      #if sdCardActiveChanged:
      #  WGDBus.configurationChanged(FilePaths.FTP_TO_SD_CARD_FILENAME)


@auth.requires(request.ajax==True, requires_login=True)
def resetResSrvToFactory():
  fsio.shcopyfile('/home/tool/config/default/ResSrv.json', FilePaths.RESSRV_FILENAME)
  notify_activity.configChanged(FilePaths.RESSRV_FILENAME, Activity.RESSRV_CHANGED, session=session)
  return ''



def _isProcessActive(procName):
  data = fsio.jsonload(FilePaths.RESSRV_FILENAME)
  return reduce(lambda x,y:x or (y['name'].upper() == procName.upper() and y['active']), data['proc'], False)



def _setProcessActive(procName, active):
  data = fsio.jsonload(FilePaths.RESSRV_FILENAME)
  for proc in data['proc']:
    if proc['name'].upper() == procName.upper():
      proc['active'] = active

  fsio.jsondump(FilePaths.RESSRV_FILENAME, data)
  notify_activity.configChanged(FilePaths.RESSRV_FILENAME, Activity.RESSRV_CHANGED, session=session)



def _getProcessData(procName):
  if not procName:
    return None

  data = fsio.jsonload(FilePaths.RESSRV_FILENAME)
  res = None
  for proc in data['proc']:
    if proc['name'].upper() == procName.upper():
      res = proc
  return res


@auth.requires(request.ajax==True, requires_login=True)
def get_res_services_header_status():
  if request.env.request_method == "GET":
    res = []

    res_files = glob("/var/run/diag/ResConStates/*")
    for srv in res_files:
        if "~" not in srv:
            res.append({"name": os.path.basename(srv), "connected": bool(int(fsio.readNb(srv)))})

    return response.json(res)


@auth.requires(request.ajax==True, requires_login=True)
def retrieveKanalNr():
  chanCfg = fsio.jsonload('/home/tool/config/ChanCfg.json')
  kanalNr = chanCfg['KanalNr']
  return kanalNr



def _parseIPM(filename):
  kanalNr = retrieveKanalNr()
  globalData = {}
  afoList = []
  tree = fsio.readXml(filename)
  for e in tree.getroot():
    if e.tag == 'global':
      for k,v in e.attrib.iteritems():
        if k in ['IPMVersion', 'IPMIPPort']:
          globalData[k] = int(v)
        else:
          globalData[k] = v
    elif e.tag == 'afolist':
      for afo in e:
        afoData = {}
        for k,v in afo.attrib.iteritems():
          if k in ['enabled', 'unwind', 'absolute', 'loosen']:
            afoData[k] = v == "1"
          elif k in ['filter', 'modeNok', 'modeOk', 'prg', 'stepFilter', 'stepNumbering', 'stepOrdering', 'stepTypifying']:
            afoData[k] = int(v)
          elif k in ['chn']:
            afoData[k] = kanalNr
          else:
            afoData[k] = v
        afoList.append(afoData)

  return { 'settings': {'global':globalData, 'afolist':afoList}}



def _writeTag(name, attribs={}, close=False):
    return '<{0}{1}{2}>'.format(name, reduce(lambda x,y:x+' {0}="{1}"'.format(*y), attribs.iteritems(), ''), '/' if close else '')



def _writeIPM(filename, data):
    kanalNr = retrieveKanalNr()
    result = ''
    result += _writeTag('settings')
    result += _writeTag('global', data['settings']['global'], True)
    result += _writeTag('afolist')
    for afoElement in data['settings']['afolist']:
        afoElement["chn"] = str(kanalNr)
        # convert bool into string for some keys
        for k in ['enabled', 'unwind', 'absolute', 'loosen']:
            afoElement[k] = "1" if afoElement[k] else "0"
        result += _writeTag('afo', afoElement, True)
    result += _writeTag('/afolist')
    result += _writeTag('/settings')
    fsio.write(filename, result)


@auth.requires(request.ajax==True, requires_login=True)
def transferCfg():
    pdata = _getProcessData(request.vars.proc)
    if pdata:
        if request.env.request_method == "GET":
            cfg = fsio.jsonload(pdata['cfg_path'])
            transfer = fsio.jsonload(cfg['transfer_cfg'])
            return response.json(transfer)


@auth.requires(request.ajax==True, requires_login=True)
def storageCfg():
    pdata = _getProcessData(request.vars.proc)
    if pdata:
        if request.env.request_method == "GET":
            cfg = fsio.jsonload(pdata['cfg_path'])
            storage = fsio.jsonload(cfg['storage_cfg'])
            return response.json(storage)


def getTypeVar(request):
    typeparam = request.vars.type
    typeparam = typeparam[:1].upper() + typeparam[1:]
    return typeparam


@auth.requires(request.ajax==True, requires_login=True)
def restransfer():
    typeparam = getTypeVar(request)
    data = json.loads(request.body.read())

    pdata = _getProcessData(typeparam)
    cfg = fsio.jsonload(pdata['cfg_path'])

    fsio.jsondump_sorted(cfg['transfer_cfg'], data)
    notify_activity.configChanged(cfg['transfer_cfg'],
                                  ACTIVITY_CODE[typeparam.upper()], session=session)


@auth.requires(request.ajax==True, requires_login=True)
def resstorage():
    typeparam = getTypeVar(request)
    data = json.loads(request.body.read())

    pdata = _getProcessData(typeparam)
    cfg = fsio.jsonload(pdata['cfg_path'])

    fsio.jsondump_sorted(cfg['storage_cfg'], data)
    notify_activity.configChanged(cfg['storage_cfg'],
                                  ACTIVITY_CODE[typeparam.upper()], session=session)



@auth.requires(request.ajax==True, requires_login=True)
def processCfg():
  pdata = _getProcessData(request.vars.proc)
  if pdata:
    if request.env.request_method == "GET":
      if request.vars.factory:
        # Factory reset
        default_dir = '/home/tool/config/default'
        if request.vars.proc == 'IPM' and request.vars.factory == 'true':
            default_dir += '/ipm'
        fsio.shcopyfile(os.path.join(default_dir, os.path.basename(pdata['cfg_path'])), pdata['cfg_path'])
        _setProcessActive(pdata['name'], False)
        notify_activity.configChanged(pdata['cfg_path'], ACTIVITY_CODE[pdata['name'].upper()], session=session)
      else:
        if pdata['name'].upper() == 'IPM':
          data = _parseIPM(pdata['cfg_path'])
          data['loggingenable'] = getIpmLoggerEnableState()
        else:
          data = fsio.jsonload(pdata['cfg_path'])
          if pdata['name'].upper() == 'OPEN PROTOCOL':
              data['loggingenable'] = getOppLoggerEnableState()
        data['active'] = pdata['active']
        return response.json(data)

    if request.env.request_method == "POST":
      data = json.loads(request.body.read())
      _setProcessActive(pdata['name'], data['active'])
      #active = data['active']
      del data['active']
      if pdata['name'].upper() == 'IPM':
        setIpmLoggingEnable(data['loggingenable'])
        del data['loggingenable']
        _writeIPM(pdata['cfg_path'], data)
        notify_activity.configChanged(pdata['cfg_path'], ACTIVITY_CODE[pdata['name'].upper()], session=session)
        return

      if pdata['name'].upper() in ['FTP', 'NXSD', 'NFS', 'CIFS', 'HTTP']:
          if pdata['name'].upper() == 'NFS':
              if data['server']['type'].upper() == "NFS":
                  del data['server']['user']
                  del data['server']['pass']

          if 'port' in data['server']:
              data['server']['port'] = int(data['server']['port'])
          if 'ssl' in data['server']:
              data['server']['ssl'] = True if data['server']['ssl'] == "true" else False

          fsio.jsondump(pdata['cfg_path'], data['server'])
          notify_activity.configChanged(pdata['cfg_path'], ACTIVITY_CODE[pdata['name'].upper()], session=session)
          return

      if pdata['name'].upper() == 'OPEN PROTOCOL':
          setOppLoggerEnableState(data['loggingenable'])
          del data['loggingenable']
      fsio.jsondump(pdata['cfg_path'], data)

      notify_activity.configChanged(pdata['cfg_path'], ACTIVITY_CODE[pdata['name'].upper()], session=session)


@auth.requires(request.ajax==True, requires_login=True)
def IDCodeActive():
  res = fsio.jsonload(FilePaths.RESSRV_FILENAME)
  return response.json(res['id_code']['active'] > 0)


@auth.requires(request.ajax==True, requires_login=True)
def processActive():
    procName = request.vars.proc
    if procName:
        return response.json(_isProcessActive(procName))


@auth.requires(request.ajax==True, requires_login=True)
def anyStandardProcessActive():
    data = fsio.jsonload(FilePaths.RESSRV_FILENAME)
    def isActive(x, y):
        if y['name'].upper() in ["FTP", "NXSD", "HTTP", "NFS"]:
            return (x or y['active'])
        return x
    return response.json(reduce(isActive, data['proc'], False))


@auth.requires(request.ajax==True, requires_login=True)
def anyDataActive():
    data = fsio.jsonload(FilePaths.RESSRV_FILENAME)
    def isActive(x, y):
        if y['name'].upper() in ["FTP", "NXSD", "HTTP", "NFS", "OPEN PROTOCOL", "IPM", "VW-XML"]:
            return (x or y['active'])
        return x
    return response.json(reduce(isActive, data['proc'], False))


@auth.requires(request.ajax==True, requires_login=True)
def removeResDb():
    res = 'rm ' + RESULT_DATABASE
    notify_activity.configChanged(res, Activity.RESULT_DB_REMOVED, session=session)

# for reading ini files windows like can be moved in a module for global use.


def _getPrivateProfileStr(inipath, section, entry):
  import ConfigParser   #makes sense here
  try:
    fsio.fsLock.acquire()
    config = ConfigParser.ConfigParser()
    config.read(inipath)
    return config.get(section, entry)
  finally:
    fsio.fsLock.release()
  return ''


def getPrivateProfileStr(inipath, section, entry):
  # just lock file globally
  with open(inipath, 'a') as f:
    try:
      fcntl.lockf(f, fcntl.LOCK_EX)
      return _getPrivateProfileStr(inipath, section, entry)
    finally:
      fcntl.lockf(f, fcntl.LOCK_UN)
  return ''



def _setPrivateProfileStr(inipath, section, entry, value, f):
  import ConfigParser   #makes sense here
  try:
    fsio.fsLock.acquire()
    config = ConfigParser.ConfigParser()
    config.read(inipath)
    config.set(section, entry, value)
    #with open(inipath, 'w') as cfgfile:
    f.truncate(0)
    config.write(f)
  except:
    return False
  finally:
    fsio.fsLock.release()
  return True


def setPrivateProfileStr(inipath, section, entry, value):
  # just lock file globally
  with open(inipath, 'a') as f:
    try:
      fcntl.lockf(f, fcntl.LOCK_EX)
      return _setPrivateProfileStr(inipath, section, entry, value, f)
    finally:
      fcntl.lockf(f, fcntl.LOCK_UN)
  return False

#This app specific
# open proto
OPPLOGGER_INI_PATH = '/home/tool/config/oppLogger.ini'
IPMLOGGER_INI_PATH = '/home/tool/config/ipm/ipmLogger.ini'
IPMLOGTT_INI_PATH = '/home/tool/config/ipm/ipmLogTT.ini'
IPMLOGDB_INI_PATH = '/home/tool/config/ipm/ipmLogDB.ini'
#
LOG_SECTION = 'logger1'
ENABLE_ENTRY = 'enabled'



def setOppLoggerEnableState(flag):
  newVal = 'off'
  if flag:
    newVal = 'on'
  return setPrivateProfileStr(OPPLOGGER_INI_PATH, LOG_SECTION, ENABLE_ENTRY, newVal)


@auth.requires(request.ajax==True, requires_login=True)
def getOppLoggerEnableState():
  if getPrivateProfileStr(OPPLOGGER_INI_PATH, LOG_SECTION, ENABLE_ENTRY).lower() == 'on'.lower():
    return True
  return False


#ipm
def ipmLoggerEnable(newVal):
  setPrivateProfileStr(IPMLOGGER_INI_PATH, LOG_SECTION, ENABLE_ENTRY, newVal)


def ipmLogTTEnable(newVal):
  setPrivateProfileStr(IPMLOGTT_INI_PATH, LOG_SECTION, ENABLE_ENTRY, newVal)


def ipmLogDBEnable(newVal):
  setPrivateProfileStr(IPMLOGDB_INI_PATH, LOG_SECTION, ENABLE_ENTRY, newVal)


def setIpmLoggingEnable(flag):
  newVal = 'off'
  if flag:
    newVal = 'on'
  ipmLoggerEnable(newVal)
  ipmLogTTEnable(newVal)
  ipmLogDBEnable(newVal)


@auth.requires(request.ajax==True, requires_login=True)
def getIpmLoggerEnableState():
  if getPrivateProfileStr(IPMLOGGER_INI_PATH, LOG_SECTION, ENABLE_ENTRY).lower() == 'on'.lower() and \
     getPrivateProfileStr(IPMLOGTT_INI_PATH, LOG_SECTION, ENABLE_ENTRY).lower() == 'on'.lower() and \
     getPrivateProfileStr(IPMLOGDB_INI_PATH, LOG_SECTION, ENABLE_ENTRY).lower() == 'on'.lower():
    return True
  return False


@auth.requires(request.ajax==True, requires_login=True)
def reset_storage():
    pdata = _getProcessData(request.vars.type)
    if pdata:
        if request.env.request_method == "GET":
            # Factory reset
            if pdata['name'].upper() in ['FTP', 'NXSD', 'HTTP', 'NFS']:
                cfg = fsio.jsonload(pdata['cfg_path'])
                transfer_file_name = cfg.get('storage_cfg')
                fsio.shcopyfile(os.path.join('/home/tool/config/default', os.path.basename(transfer_file_name)), transfer_file_name)
                WGDBus.configurationChanged(transfer_file_name)


@auth.requires(request.ajax==True, requires_login=True)
def reset_transfer():
    pdata = _getProcessData(request.vars.type)
    if pdata:
        if request.env.request_method == "GET":
            # Factory reset
            if pdata['name'].upper() in ['FTP', 'NXSD', 'HTTP', 'NFS']:
                cfg = fsio.jsonload(pdata['cfg_path'])
                transfer_file_name = cfg.get('transfer_cfg')
                fsio.shcopyfile(os.path.join('/home/tool/config/default', os.path.basename(transfer_file_name)), transfer_file_name)
                WGDBus.configurationChanged(transfer_file_name)

