c = require "constants"
f = require "runFunctions"
plc = require "plcsignals"
codes = require "scancodes"
local initNode = {
   name = "initNode",
   timeout = 300,
   type = c.TypeIdleStartNode,
   selectsCw = 0,
   selectsEn = 0,
   displayJobSteps = 1,
   displayTime = 1,
   clearIDCode = 0,
   ignoreResults = 0,
   jobComment = '',
   jobUser = '',
   jobDate = 0
}
-- Atoms for Idle Script ---
atoms  = {}
-- Lokaler Knoten --
atoms["$Local"] = {
   type = c.TypeDevice, 
   mode = c.DeviceModeLocal,
   dest = "0"
}
atoms["$EnableUNDO"] = {
   type = c.TypeTriggerOut,
   mode = c.TriggerOutModeBmsIn,
   dest  = plc.In.En,
   state = 0,
   range = 0,
   valueList = {}
}
atoms["$ClockUNDO"] = {
   type = c.TypeTriggerOut,
   mode = c.TriggerOutModeBmsIn,
   dest  = plc.In.Cw,
   state = 0,
   range = 0,
   valueList = {}
}
atoms["Job     Enabled"] = {
   type = c.TypeTriggerIn,		-- TriggerIn --
   mode = c.TriggerInModeCwJob, 	-- Warten auf Job Cw --
   dest = 0,
   state = 0,
   range = 0
}
f.publishAtoms(atoms,function (a) cpp.job:addAtom(a) end)
nodes = {}
nodes[1] = {}
nodes[2] = {}
nodes[3] = {}
nodes[4] = {}
nodes[5] = {}
nodes[6] = {}
nodes[7] = {}
nodes[11] = {}
nodes[12] = {}
nodes[13] = {}
nodes[14] = {}
nodes[15] = {}
------------ CS/SE System ------- Channel Signals -------------------------
nodes[1].atom = atoms["$Local"]
nodes[1].successor = {{var = "dummy",val = nil, next = nodes[2] }}
nodes[2].atom = atoms["$EnableUNDO"]
nodes[2].successor = {{var = "dummy",val = nil, next = nodes[3] }}
nodes[3].atom = atoms["$ClockUNDO"]
nodes[3].successor = {{var = "dummy",val = nil, next = nodes[4] }}
nodes[4].atom = atoms["Job     Enabled"]
nodes[4].successor = {{var = "dummy",val = nil, next = f.EndNode }}
------------ CS/SE System ------- END -------------------------------------
--Eigentlicher Start Code--
f.setInitNode(initNode)
f.checkPlausib(nodes)
if( BMS == "FO" ) then
	f.go(nodes[11])
else
	f.go(nodes[2])
end
f.cleanUpNodes(atoms, nodes)
package.loaded["atoms"]=nil
